{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Conclave \u00b6 Conclave is a toolkit for building enclaves , small pieces of software that are protected from attack by the owner of the computer on which they run. It is ideally suited to solving multi-party collaboration and privacy problems but can also be used to secure your infrastructure against attack. Visit the Conclave website Get Conclave Conclave 1.0 SHA2: c3430d7172b2b0ab15a19930558f8c18c64974bb113dfd2c0722d067cdf3fee5 Conclave 1.1 SHA2: xxx Why Conclave? \u00b6 High level, simple API that is much easier to use than other enclave APIs. Write your host app in any language that can run on a Java Virtual Machine like Java, Kotlin or even JavaScript . Write your enclave using the GraalVM native image technology for incredibly tight memory usage, support for any GraalVM language and instant startup time. Eliminate all memory management errors that would undermine the security of your enclave, thanks to the built-in compacting generational garbage collector. Develop gracefully on all operating systems, not just Linux: Windows and macOS are fully supported as well. Full support for auditing enclaves over the internet, including remote attestation. A user can verify what the source code of the remotely running enclave is, to ensure it will behave as they expect. A message oriented communication and storage system that eliminates size-based side channel attacks and integrates with the Intel SGX secure upgrade mechanisms. Roll forward through security upgrades without clients being aware of it. A Gradle plugin to automate compiling, signing and calculating the code hash of your enclave. No need to use the Intel SDK - everything needed is included. API designs that guide you towards SGX best practices and avoidance of security pitfalls. Easily deploy to Microsoft Azure by just uploading your Java host app and running it as normal. There is no setup! A powerful unit testing framework to verify the operation of your enclave and remote attestation functionality, using just JUnit. Integrate and benefit from Corda , an open source peer-to-peer network for business uses with enterprise support. Tutorials , guides, design assistance and commercial support from the SGX experts at R3. Friendly devs on our Slack channel and mailing list, even if you don't have a proper support contract! Finally, Conclave is free for individuals and early-stage startups! Documentation \u00b6 Click through the tabs above to see all our documentation. If you're not sure where to start, these pages are good: Concepts Enclaves. If you're totally new to enclave development start with our introduction to enclave-oriented design. This will explain the concepts referred to in the rest of the documentation. Architectural overview. This explains the core Conclave APIs and how it's structured. Writing and Running your First Conclave Application Tutorial. Once you understand the concepts go straight to writing your first enclave. Enclave Configuration. Now you've created your first enclave, take a deeper look at the configuration options available for creating enclaves. Deploying and Operating Conclave Applications Machine setup. Learn how to obtain SGX capable hardware, set it up, deploy to production and then keep your machine trusted by applying updates. Exploring more of Conclave's capabilities Using JavaScript. How to use JIT compiled JavaScript inside the enclave. Integrating Conclave with Blockchain Applications You'll need a way for your users to get data to and from your service that has integrated identity, workflow, firewall handling, database integration and more. Corda is an enterprise blockchain platform that offers many useful features when you progress beyond encrypting your business logic. Reference guide. We provide detailed JavaDocs for the API. Samples. The Conclave Developer Relations team maintains a library of samples here. Samples include machine learning within a Conclave enclave and an example of a lightweight host application. Get in touch \u00b6 R3 offers full ticket based commercial support . There's a public mailing list for discussion of using Conclave and we also welcome general SGX talk. A Slack channel is available where you can find the development team during UK office hours (GMT 0900-1700). Join conclave-discuss@groups.io Email us directly Slack us in #conclave Release notes \u00b6 1.1 \u00b6 Important There have been some breaking changes in this version of Conclave. Be sure to check out the API changes you might need to make to get your current project building with Conclave 1.1. Deprecation The Avian runtime is deprecated as of Conclave 1.1. Previously Conclave gave you the choice of whether to use Avian or GraalVM native image as the runtime environment inside your enclave. Enclaves built with GraalVM native image have many benefits over Avian enclaves, including enhanced security, performance and capabilities. Therefore new projects should not use the Avian runtime. References to using Avian have been removed from the documentation for Conclave 1.1, and the next release of SDK will not include the capability to build enclaves that use the Avian runtime. Conclave 1.1 does still allow you to build Avian enclaves on Linux and macOS but you cannot build Avian enclaves on Windows systems. Conclave 1.1 has been tested on the latest 3rd Gen Intel Xeon Scalable processors, also known as Ice Lake Xeon CPUs. These CPUs bring a number of enhancements for Conclave applications, especially in the amount of memory available for use inside enclaves where the limit has been increased from typically around 95MB up to 512GB per CPU depending on the platform. You do not need to make any changes to your application to support these new CPUs except to ensure you are using DCAP attestation as Xeon Scalable processors do not support EPID. New feature! Mock mode has been extended so you can now specify 'mock' as an enclave mode and use your regular host rather than having to modify your code to use a special build of your host. A new mockEnclave property has been added to EnclaveHost that can be used in mock mode to allow access to the enclave instance for probing internal state during development and testing. Learn more about enclave configurations . See more information about how the API has changed New feature! When using mock mode you can now specify the configuration of the mock environment, allowing parameters such as the codeHash , codeSigningKeyHash and tcbLevel to be modified programatically in your unit tests. See Mock mode configuration for more details. New feature! We've updated the bundled CorDapp sample to show how to integrate Corda network identities with Conclave. The node can now log in to the enclave and identify itself by presenting its verified X.509 certificate. The enclave can use this to map the mail sender key to a meaningful X.500 name. New feature! To better showcase Conclave we've created a separate repository of enclave samples for you to look and try out. We plan to update this on a more regular basis. In particular we have a sample running the Tribuo machine learning library inside an enclave. The Conclave documentation has been improved, fixing a number of errors and updating the format of the Javadocs section of the documentation site. The Conclave SDK documentation is packaged along with the SDK so it is automatically displayed in IDEs that support this, including Eclipse and Visual Studio Code. See Writing hello world for details of how to configure your Gradle project to display documentation in the IDE. We've updated to version 21.0.0 of GraalVM which along with some performance improvements to the garbage collector, also adds Java serialisation support. We've updated Conclave to take advantage of this. Find out more about how to configure serialization within the enclave . The SGX SDK that Conclave is built upon has been updated to version 2.13.3. This provides bug fixes and an update to the Intel IPP cryptographic library. See the SGX SDK release notes for more details. We've improved the error messages in a number of places, including when there are problems signing the enclave and when there are issues in sending and receiving Mail messages. The container-gradle script has been updated to correctly handle configuration files that live outside the source tree. The output of the enclave gradle build has been tidied up, hiding the information that would only normally be present on verbose builds. If you want to see the verbose output in your build then just add --info to your gradle build command line. Security improvements and bug fixes: improved DCAP certificate validation, added additional bounds checks on some internal methods, fixes to allow validation of enclave-to-enclave attestations inside an enclave. 1.0 \u00b6 New feature! A new PostOffice API makes using mail easier and also automatically applies a reasonable minimum size to each mail to help defend against the host guessing message contents by looking at how big it is (a size side channel attack). The default size policy is a moving average. See MinSizePolicy for more information. Mail topic semantics have been improved by making them scoped to the sender public key rather than being global. This allows the enclave to enforce correct mail ordering with respect to the sequence numbers on a per-sender basis. This means EnclaveMail.authenticatedSender is no longer nullable and will always return an authenticated sender, i.e. if a sender private key is not specified then one is automatically created. New feature! An embedded, in-memory file system is provided that emulates POSIX semantics. This is intended to provide compatibility with libraries and programs that expect to load data or config files from disk. Learn more about the in-memory filesystem . New feature! A new script is provided to make it easier to run your application inside a Docker container on macOS. This helps you execute a simulation mode enclave without direct access to a Linux machine. Learn more about the container-gradle script. New feature! The enclave signing key hash is now printed during the build, ready for you to copy into a constraint. New feature! A tutorial for how to write CorDapps has been added. Corda can provide your enclave with a business oriented peer-to-peer network that has integrated identity. Learn more about writing CorDapps with Conclave . Multi-threaded enclaves are now opt-in. By default, the enclave object will be locked before data from the host is delivered. This ensures that a malicious host cannot multi-thread an enclave that's not expecting it. The Gradle tasks list has been cleaned up to hide internal tasks that aren't useful to invoke from the command line. GraalVM has been updated to version 20.3. An upgrade to 21.0 will come soon. Usability improvements: better error messages, more FAQs. Bug fixes: improve CPU compatibility checks, enclaves with non-public constructors are now loadable. Security improvements and fixes. Please read the list of known issues . Beta 4 \u00b6 New feature! Conclave now supports building GraalVM Native Image enclaves on macOS and Windows! GraalVM Native Image support was added in Beta 3 but required a Linux build system. Now, by installing Docker on Windows or macOS you can configure your enclaves to use the graalvm_native_image runtime and let Conclave simply manage the build process for you. Creating and managing the container is automated for you. New feature! Conclave now supports a new remote attestation protocol. That means it now works out of the box on Azure Confidential Compute VMs , without any need to get an approved signing key: you can self sign enclaves and go straight to 'release mode' on Azure. Follow our tutorial on how to deploy your app to Azure to learn more. New feature! Easily enable and use JavaScript . It is JIT compiled inside the enclave, warms up to be as fast as V8 and can interop with JVM bytecode. Full support for the latest ECMAScript standards. New feature! Mail is now integrated with the SGX data sealing and TCB recovery features. If a version of the CPU microcode, SGX architectural enclaves or the enclave itself is revoked, old mail will be readable by the newly upgraded system, but downgrade attacks are blocked (old versions cannot be exploited to read new mail). This support is fully automatic and especially useful when using the 'mail to self' pattern for storage. New feature! The new EnclaveHost.capabilitiesDiagnostics API prints a wealth of detailed technical information about the host platform, useful for diagnostics and debugging. System.currentTimeMillis now provides high performance, side-channel free access to the host's clock. The host copies the current time to a memory location the enclave can read, thus avoiding a call out of the enclave that could give away information about where in the program the enclave is. Remember however that as per usual, the host can change the time to whatever it wants, or even make it go backwards. Significantly improved multi-threading support. Learn more about threads inside the enclave . Write scalable, thread safe enclaves and use thread-pools of different sizes inside and outside the enclave. Conclave's internal dependencies are better isolated. As a consequence it's now loadable from inside an app designed for R3's Corda platform . Corda is one of the world's leading blockchain platforms and its privacy needs are what drove development of Conclave. We plan to release a sample app showing Corda/Conclave integration soon. API improvements! The API for receiving local calls into an enclave has been simplified, the mail API lets the host provide a routing hint when delivering, and the API for passing attestation parameters has been simplified due to the introduction of support for the new DCAP attestation protocol. Learn more about the API changes . Mail has been optimised to reduce the size overhead and do fewer memory copies. Bug fixes, usability and security improvements. Upgrade to ensure your enclave is secure. We've improved error messages for a variety of situations where Conclave isn't being used correctly. Beta 3 \u00b6 New feature! The Mail API makes it easy to deliver encrypted messages to the enclave that only it can read, with sequencing and separation of different mail streams by topic. Mail can also be used by an enclave to persist (sealed) data. Learn more New feature! You can now compile your entire enclave ahead of time using GraaalVM Native Image . This gives you access to a much better JVM than in prior releases, with faster enclaves that use less RAM. The performance improvement can be between 4x and 12x faster than in prior releases and memory usage can be up to 5x lower. New feature! New mock API for easy debugging between the host and enclave, fast unit testing and easy development of enclaves on machines that don't support the technology. Learn more . New feature! You can now produce enclaves on macOS! Just follow the instructions as you would on a Linux developer machine, and a JAR with an embedded Linux enclave .so file will be produced automatically. You can then take that JAR and upload it to a Linux host for execution, e.g. via a Docker or webapp container (e.g. Tomcat). Combined with the equivalent Windows support we added in beta 2 and the easy to use mock enclave API, this completes our developer platform support and allows mixed teams of people working on their preferred OS to build enclave-oriented apps together. Please note: at this time only the Avian runtime can be cross-compiled from Windows and macOS. New feature! You may now make concurrent calls into the enclave using multiple threads,. Remote attestations (serialized EnclaveInstanceInfo objects) now remain valid across enclave restarts. They may still be invalidated by changes to the SGX TCB, for example, microcode updates applied as part of an operating system upgrade. Enclave/host communication now handles exceptions thrown across the boundary properly. In order to prevent accidental leakage of information from inside enclaves, release builds of enclaves no longer propagate console output across the enclave boundary. Calls to System.out.println() and related methods will now only print to the console on simulation and debug builds of enclaves. Beta 2 \u00b6 New feature! Build enclaves on Windows without any special emulators, virtual machines or other setup. New feature! Specify an enclave's product ID and revocation level in the enclave build file. There's a new conclave block which lets you do this. These values are enforced in any relevant EnclaveConstraint object. New feature! A new EnclaveHost.checkPlatformSupportsEnclaves API allows you to probe the host operating system to check if enclaves are loadable, before you try to actually do so. Additionally, if SGX is disabled in the BIOS but can be enabled by software request, Conclave can now do this for you. If the host machine needs extra configuration a useful error message is now provided in the exception. New feature! Better support for enclave signing in the Gradle plugin. New documentation has been added showing how to sign with externally managed keys. You can now use the Conclave host API from Java 11. The version of Java inside the enclave remains at Java 8. We've upgraded to use the version 2.9.1 of the Intel SGX SDK, which brings security improvements and lays the groundwork for new features. Make sure your host system is also running version 2.9.1. We've also upgraded to the latest version of the Intel Attestation Service (IAS). The ID for the enclave plugin is now com.r3.conclave.enclave . You will need to change this in your enclave's build.gradle file. enclave.xml files are no longer needed. You can safely delete them, as they're now generated for you by Conclave. The enclave measurement is now stable when built using different versions of the JDK. The format of an EnclaveInstanceInfo has been optimised. Old EnclaveInstanceInfo objects won't work with the beta 2 client libraries and vice-versa. Java serialization is now formally blocked inside the enclave using a filter. Unfiltered deserialization has a history of leading to exploits in programs written in high level managed languages.","title":"Welcome"},{"location":"index.html#conclave","text":"Conclave is a toolkit for building enclaves , small pieces of software that are protected from attack by the owner of the computer on which they run. It is ideally suited to solving multi-party collaboration and privacy problems but can also be used to secure your infrastructure against attack. Visit the Conclave website Get Conclave Conclave 1.0 SHA2: c3430d7172b2b0ab15a19930558f8c18c64974bb113dfd2c0722d067cdf3fee5 Conclave 1.1 SHA2: xxx","title":"Conclave"},{"location":"index.html#why-conclave","text":"High level, simple API that is much easier to use than other enclave APIs. Write your host app in any language that can run on a Java Virtual Machine like Java, Kotlin or even JavaScript . Write your enclave using the GraalVM native image technology for incredibly tight memory usage, support for any GraalVM language and instant startup time. Eliminate all memory management errors that would undermine the security of your enclave, thanks to the built-in compacting generational garbage collector. Develop gracefully on all operating systems, not just Linux: Windows and macOS are fully supported as well. Full support for auditing enclaves over the internet, including remote attestation. A user can verify what the source code of the remotely running enclave is, to ensure it will behave as they expect. A message oriented communication and storage system that eliminates size-based side channel attacks and integrates with the Intel SGX secure upgrade mechanisms. Roll forward through security upgrades without clients being aware of it. A Gradle plugin to automate compiling, signing and calculating the code hash of your enclave. No need to use the Intel SDK - everything needed is included. API designs that guide you towards SGX best practices and avoidance of security pitfalls. Easily deploy to Microsoft Azure by just uploading your Java host app and running it as normal. There is no setup! A powerful unit testing framework to verify the operation of your enclave and remote attestation functionality, using just JUnit. Integrate and benefit from Corda , an open source peer-to-peer network for business uses with enterprise support. Tutorials , guides, design assistance and commercial support from the SGX experts at R3. Friendly devs on our Slack channel and mailing list, even if you don't have a proper support contract! Finally, Conclave is free for individuals and early-stage startups!","title":"Why Conclave?"},{"location":"index.html#documentation","text":"Click through the tabs above to see all our documentation. If you're not sure where to start, these pages are good: Concepts Enclaves. If you're totally new to enclave development start with our introduction to enclave-oriented design. This will explain the concepts referred to in the rest of the documentation. Architectural overview. This explains the core Conclave APIs and how it's structured. Writing and Running your First Conclave Application Tutorial. Once you understand the concepts go straight to writing your first enclave. Enclave Configuration. Now you've created your first enclave, take a deeper look at the configuration options available for creating enclaves. Deploying and Operating Conclave Applications Machine setup. Learn how to obtain SGX capable hardware, set it up, deploy to production and then keep your machine trusted by applying updates. Exploring more of Conclave's capabilities Using JavaScript. How to use JIT compiled JavaScript inside the enclave. Integrating Conclave with Blockchain Applications You'll need a way for your users to get data to and from your service that has integrated identity, workflow, firewall handling, database integration and more. Corda is an enterprise blockchain platform that offers many useful features when you progress beyond encrypting your business logic. Reference guide. We provide detailed JavaDocs for the API. Samples. The Conclave Developer Relations team maintains a library of samples here. Samples include machine learning within a Conclave enclave and an example of a lightweight host application.","title":"Documentation"},{"location":"index.html#get-in-touch","text":"R3 offers full ticket based commercial support . There's a public mailing list for discussion of using Conclave and we also welcome general SGX talk. A Slack channel is available where you can find the development team during UK office hours (GMT 0900-1700). Join conclave-discuss@groups.io Email us directly Slack us in #conclave","title":"Get in touch"},{"location":"index.html#release-notes","text":"","title":"Release notes"},{"location":"index.html#11","text":"Important There have been some breaking changes in this version of Conclave. Be sure to check out the API changes you might need to make to get your current project building with Conclave 1.1. Deprecation The Avian runtime is deprecated as of Conclave 1.1. Previously Conclave gave you the choice of whether to use Avian or GraalVM native image as the runtime environment inside your enclave. Enclaves built with GraalVM native image have many benefits over Avian enclaves, including enhanced security, performance and capabilities. Therefore new projects should not use the Avian runtime. References to using Avian have been removed from the documentation for Conclave 1.1, and the next release of SDK will not include the capability to build enclaves that use the Avian runtime. Conclave 1.1 does still allow you to build Avian enclaves on Linux and macOS but you cannot build Avian enclaves on Windows systems. Conclave 1.1 has been tested on the latest 3rd Gen Intel Xeon Scalable processors, also known as Ice Lake Xeon CPUs. These CPUs bring a number of enhancements for Conclave applications, especially in the amount of memory available for use inside enclaves where the limit has been increased from typically around 95MB up to 512GB per CPU depending on the platform. You do not need to make any changes to your application to support these new CPUs except to ensure you are using DCAP attestation as Xeon Scalable processors do not support EPID. New feature! Mock mode has been extended so you can now specify 'mock' as an enclave mode and use your regular host rather than having to modify your code to use a special build of your host. A new mockEnclave property has been added to EnclaveHost that can be used in mock mode to allow access to the enclave instance for probing internal state during development and testing. Learn more about enclave configurations . See more information about how the API has changed New feature! When using mock mode you can now specify the configuration of the mock environment, allowing parameters such as the codeHash , codeSigningKeyHash and tcbLevel to be modified programatically in your unit tests. See Mock mode configuration for more details. New feature! We've updated the bundled CorDapp sample to show how to integrate Corda network identities with Conclave. The node can now log in to the enclave and identify itself by presenting its verified X.509 certificate. The enclave can use this to map the mail sender key to a meaningful X.500 name. New feature! To better showcase Conclave we've created a separate repository of enclave samples for you to look and try out. We plan to update this on a more regular basis. In particular we have a sample running the Tribuo machine learning library inside an enclave. The Conclave documentation has been improved, fixing a number of errors and updating the format of the Javadocs section of the documentation site. The Conclave SDK documentation is packaged along with the SDK so it is automatically displayed in IDEs that support this, including Eclipse and Visual Studio Code. See Writing hello world for details of how to configure your Gradle project to display documentation in the IDE. We've updated to version 21.0.0 of GraalVM which along with some performance improvements to the garbage collector, also adds Java serialisation support. We've updated Conclave to take advantage of this. Find out more about how to configure serialization within the enclave . The SGX SDK that Conclave is built upon has been updated to version 2.13.3. This provides bug fixes and an update to the Intel IPP cryptographic library. See the SGX SDK release notes for more details. We've improved the error messages in a number of places, including when there are problems signing the enclave and when there are issues in sending and receiving Mail messages. The container-gradle script has been updated to correctly handle configuration files that live outside the source tree. The output of the enclave gradle build has been tidied up, hiding the information that would only normally be present on verbose builds. If you want to see the verbose output in your build then just add --info to your gradle build command line. Security improvements and bug fixes: improved DCAP certificate validation, added additional bounds checks on some internal methods, fixes to allow validation of enclave-to-enclave attestations inside an enclave.","title":"1.1"},{"location":"index.html#10","text":"New feature! A new PostOffice API makes using mail easier and also automatically applies a reasonable minimum size to each mail to help defend against the host guessing message contents by looking at how big it is (a size side channel attack). The default size policy is a moving average. See MinSizePolicy for more information. Mail topic semantics have been improved by making them scoped to the sender public key rather than being global. This allows the enclave to enforce correct mail ordering with respect to the sequence numbers on a per-sender basis. This means EnclaveMail.authenticatedSender is no longer nullable and will always return an authenticated sender, i.e. if a sender private key is not specified then one is automatically created. New feature! An embedded, in-memory file system is provided that emulates POSIX semantics. This is intended to provide compatibility with libraries and programs that expect to load data or config files from disk. Learn more about the in-memory filesystem . New feature! A new script is provided to make it easier to run your application inside a Docker container on macOS. This helps you execute a simulation mode enclave without direct access to a Linux machine. Learn more about the container-gradle script. New feature! The enclave signing key hash is now printed during the build, ready for you to copy into a constraint. New feature! A tutorial for how to write CorDapps has been added. Corda can provide your enclave with a business oriented peer-to-peer network that has integrated identity. Learn more about writing CorDapps with Conclave . Multi-threaded enclaves are now opt-in. By default, the enclave object will be locked before data from the host is delivered. This ensures that a malicious host cannot multi-thread an enclave that's not expecting it. The Gradle tasks list has been cleaned up to hide internal tasks that aren't useful to invoke from the command line. GraalVM has been updated to version 20.3. An upgrade to 21.0 will come soon. Usability improvements: better error messages, more FAQs. Bug fixes: improve CPU compatibility checks, enclaves with non-public constructors are now loadable. Security improvements and fixes. Please read the list of known issues .","title":"1.0"},{"location":"index.html#beta-4","text":"New feature! Conclave now supports building GraalVM Native Image enclaves on macOS and Windows! GraalVM Native Image support was added in Beta 3 but required a Linux build system. Now, by installing Docker on Windows or macOS you can configure your enclaves to use the graalvm_native_image runtime and let Conclave simply manage the build process for you. Creating and managing the container is automated for you. New feature! Conclave now supports a new remote attestation protocol. That means it now works out of the box on Azure Confidential Compute VMs , without any need to get an approved signing key: you can self sign enclaves and go straight to 'release mode' on Azure. Follow our tutorial on how to deploy your app to Azure to learn more. New feature! Easily enable and use JavaScript . It is JIT compiled inside the enclave, warms up to be as fast as V8 and can interop with JVM bytecode. Full support for the latest ECMAScript standards. New feature! Mail is now integrated with the SGX data sealing and TCB recovery features. If a version of the CPU microcode, SGX architectural enclaves or the enclave itself is revoked, old mail will be readable by the newly upgraded system, but downgrade attacks are blocked (old versions cannot be exploited to read new mail). This support is fully automatic and especially useful when using the 'mail to self' pattern for storage. New feature! The new EnclaveHost.capabilitiesDiagnostics API prints a wealth of detailed technical information about the host platform, useful for diagnostics and debugging. System.currentTimeMillis now provides high performance, side-channel free access to the host's clock. The host copies the current time to a memory location the enclave can read, thus avoiding a call out of the enclave that could give away information about where in the program the enclave is. Remember however that as per usual, the host can change the time to whatever it wants, or even make it go backwards. Significantly improved multi-threading support. Learn more about threads inside the enclave . Write scalable, thread safe enclaves and use thread-pools of different sizes inside and outside the enclave. Conclave's internal dependencies are better isolated. As a consequence it's now loadable from inside an app designed for R3's Corda platform . Corda is one of the world's leading blockchain platforms and its privacy needs are what drove development of Conclave. We plan to release a sample app showing Corda/Conclave integration soon. API improvements! The API for receiving local calls into an enclave has been simplified, the mail API lets the host provide a routing hint when delivering, and the API for passing attestation parameters has been simplified due to the introduction of support for the new DCAP attestation protocol. Learn more about the API changes . Mail has been optimised to reduce the size overhead and do fewer memory copies. Bug fixes, usability and security improvements. Upgrade to ensure your enclave is secure. We've improved error messages for a variety of situations where Conclave isn't being used correctly.","title":"Beta 4"},{"location":"index.html#beta-3","text":"New feature! The Mail API makes it easy to deliver encrypted messages to the enclave that only it can read, with sequencing and separation of different mail streams by topic. Mail can also be used by an enclave to persist (sealed) data. Learn more New feature! You can now compile your entire enclave ahead of time using GraaalVM Native Image . This gives you access to a much better JVM than in prior releases, with faster enclaves that use less RAM. The performance improvement can be between 4x and 12x faster than in prior releases and memory usage can be up to 5x lower. New feature! New mock API for easy debugging between the host and enclave, fast unit testing and easy development of enclaves on machines that don't support the technology. Learn more . New feature! You can now produce enclaves on macOS! Just follow the instructions as you would on a Linux developer machine, and a JAR with an embedded Linux enclave .so file will be produced automatically. You can then take that JAR and upload it to a Linux host for execution, e.g. via a Docker or webapp container (e.g. Tomcat). Combined with the equivalent Windows support we added in beta 2 and the easy to use mock enclave API, this completes our developer platform support and allows mixed teams of people working on their preferred OS to build enclave-oriented apps together. Please note: at this time only the Avian runtime can be cross-compiled from Windows and macOS. New feature! You may now make concurrent calls into the enclave using multiple threads,. Remote attestations (serialized EnclaveInstanceInfo objects) now remain valid across enclave restarts. They may still be invalidated by changes to the SGX TCB, for example, microcode updates applied as part of an operating system upgrade. Enclave/host communication now handles exceptions thrown across the boundary properly. In order to prevent accidental leakage of information from inside enclaves, release builds of enclaves no longer propagate console output across the enclave boundary. Calls to System.out.println() and related methods will now only print to the console on simulation and debug builds of enclaves.","title":"Beta 3"},{"location":"index.html#beta-2","text":"New feature! Build enclaves on Windows without any special emulators, virtual machines or other setup. New feature! Specify an enclave's product ID and revocation level in the enclave build file. There's a new conclave block which lets you do this. These values are enforced in any relevant EnclaveConstraint object. New feature! A new EnclaveHost.checkPlatformSupportsEnclaves API allows you to probe the host operating system to check if enclaves are loadable, before you try to actually do so. Additionally, if SGX is disabled in the BIOS but can be enabled by software request, Conclave can now do this for you. If the host machine needs extra configuration a useful error message is now provided in the exception. New feature! Better support for enclave signing in the Gradle plugin. New documentation has been added showing how to sign with externally managed keys. You can now use the Conclave host API from Java 11. The version of Java inside the enclave remains at Java 8. We've upgraded to use the version 2.9.1 of the Intel SGX SDK, which brings security improvements and lays the groundwork for new features. Make sure your host system is also running version 2.9.1. We've also upgraded to the latest version of the Intel Attestation Service (IAS). The ID for the enclave plugin is now com.r3.conclave.enclave . You will need to change this in your enclave's build.gradle file. enclave.xml files are no longer needed. You can safely delete them, as they're now generated for you by Conclave. The enclave measurement is now stable when built using different versions of the JDK. The format of an EnclaveInstanceInfo has been optimised. Old EnclaveInstanceInfo objects won't work with the beta 2 client libraries and vice-versa. Java serialization is now formally blocked inside the enclave using a filter. Unfiltered deserialization has a history of leading to exploits in programs written in high level managed languages.","title":"Beta 2"},{"location":"api-changes.html","text":"API changes \u00b6 1.0 to 1.1 \u00b6 There have been a number of changes in the way that you use mock mode in your Conclave projects. You will need to make some changes to your build files in order to build you earlier projects with Conclave 1.1. Firstly, the MockHost class for loading an enclave in mock mode has been removed. You will need to update your code to use EnclaveHost.load instead of MockHost.loadMock . So the pre-1.1 code below: 1 2 3 4 5 6 if ( mode == \"mock\" ) { enclave = MockHost . loadMock ( className ); } else { enclave = EnclaveHost . load ( className ); } Changes to: 1 enclave = EnclaveHost . load ( className ); Secondly, the conclave-testing package has been removed. This previously contained MockHost but this is no longer required. You need to remove any test dependency on conclave-testing from your build.gradle files and remove any import statements that refer to conclave-testing . Lastly, you must make sure that your host project (the one that loads the enclave) does not include the enclave class on its classpath in anything other than mock mode. You can ensure this is the case by setting a runtimeOnly dependency on the enclave project in your host build.gradle . 1 runtimeOnly project ( path: \":enclave\" , configuration: mode ) If you need to access the enclave class in your host project in mock mode via the the EnclaveHost.mockEnclave property then you will need to conditionally depend on the enclave project at compile or implementation time by including this in your host build.gradle : 1 2 3 4 5 if ( mode == \"mock\" ) { implementation project ( path: \":enclave\" , configuration: \"mock\" ) } else { runtimeOnly project ( path: \":enclave\" , configuration: mode ) } Learn more about the changes to mock mode . Beta 4 to 1.0 \u00b6 Between beta 4 and 1.0 the API for creating mail has changed. MutableMail has been replaced by PostOffice which is a factory for creating encrypted mail. There's no longer any need to manually increment the sequence number as that's done for you. Instead make sure to only have one instance per sender key and topic. This allows the enclave to check for dropped or reordered mail. Mail.decrypt and EnclaveInstanceInfo.decryptMail have been replaced by PostOffice.decryptMail . Decrypt any response mail using the same post office instance that created the request. Inside the enclave Enclave.createMail has been replaced by Enclave.postOffice which returns a cached post office for the destination and topic. This means you don't need to manage post office instances inside the enclave as you do in the client. The routing hint parameter in Enclave.receiveMail has been moved to the end to make the method signature consistent with EnclaveHost.deliverMail .","title":"Migration notes"},{"location":"api-changes.html#api-changes","text":"","title":"API changes"},{"location":"api-changes.html#10-to-11","text":"There have been a number of changes in the way that you use mock mode in your Conclave projects. You will need to make some changes to your build files in order to build you earlier projects with Conclave 1.1. Firstly, the MockHost class for loading an enclave in mock mode has been removed. You will need to update your code to use EnclaveHost.load instead of MockHost.loadMock . So the pre-1.1 code below: 1 2 3 4 5 6 if ( mode == \"mock\" ) { enclave = MockHost . loadMock ( className ); } else { enclave = EnclaveHost . load ( className ); } Changes to: 1 enclave = EnclaveHost . load ( className ); Secondly, the conclave-testing package has been removed. This previously contained MockHost but this is no longer required. You need to remove any test dependency on conclave-testing from your build.gradle files and remove any import statements that refer to conclave-testing . Lastly, you must make sure that your host project (the one that loads the enclave) does not include the enclave class on its classpath in anything other than mock mode. You can ensure this is the case by setting a runtimeOnly dependency on the enclave project in your host build.gradle . 1 runtimeOnly project ( path: \":enclave\" , configuration: mode ) If you need to access the enclave class in your host project in mock mode via the the EnclaveHost.mockEnclave property then you will need to conditionally depend on the enclave project at compile or implementation time by including this in your host build.gradle : 1 2 3 4 5 if ( mode == \"mock\" ) { implementation project ( path: \":enclave\" , configuration: \"mock\" ) } else { runtimeOnly project ( path: \":enclave\" , configuration: mode ) } Learn more about the changes to mock mode .","title":"1.0 to 1.1"},{"location":"api-changes.html#beta-4-to-10","text":"Between beta 4 and 1.0 the API for creating mail has changed. MutableMail has been replaced by PostOffice which is a factory for creating encrypted mail. There's no longer any need to manually increment the sequence number as that's done for you. Instead make sure to only have one instance per sender key and topic. This allows the enclave to check for dropped or reordered mail. Mail.decrypt and EnclaveInstanceInfo.decryptMail have been replaced by PostOffice.decryptMail . Decrypt any response mail using the same post office instance that created the request. Inside the enclave Enclave.createMail has been replaced by Enclave.postOffice which returns a cached post office for the destination and topic. This means you don't need to manage post office instances inside the enclave as you do in the client. The routing hint parameter in Enclave.receiveMail has been moved to the end to make the method signature consistent with EnclaveHost.deliverMail .","title":"Beta 4 to 1.0"},{"location":"architecture.html","text":"Architecture overview \u00b6 If you are new to the concept of Confidential Computing, you may also find the introduction to enclaves document helpful. Primary entities \u00b6 There are three entities in an application that uses Conclave: Clients Hosts Enclaves Clients send and receive encrypted messages to/from enclaves by interacting with the host over the network. Conclave doesn't mandate any particular network protocol for client<->host communication. It's up to you. However the content of the messages is defined, using the Mail API. Mail is described below. Host programs load enclaves. From a security perspective they are fully untrusted and assumed to be malicious at all times. Hosts are relied on to provide the enclave with resources but beyond that work only with encrypted data. In some kinds of app their function is primarily proxying communications from clients to enclaves, but sometimes they also assist with application logic. Hosts use a standard JVM like HotSpot. Enclaves are classes that are loaded into a dedicated sub-JVM with a protected memory space, running inside the same operating system process as the host JVM. Code running in an enclave cannot be tampered with by the host system or its owner, nor can the host system or its owner see the data that the enclave is processing. Enclaves communicate with clients via the host program. To understand Confidential Computing in general, and Conclave in particular, it is helpful to keep in mind at all times that the primary purpose of the system is to enable clients securely to share data with an enclave, which will faithfully execute a specified algorithm without revealing anything to the potentially malicious host on which it runs. In the above diagram orange shaded boxes are untrusted and could attack the enclave. Notice how this threat model is extensive: we assume both the host and the operating system could be malicious, and this includes the BIOS, drivers and peripherals. By contrast, blue shaded boxes are assumed reliable. We say they are part of the trusted computing base - the set of components that must be correct and non-malicious for the system to work. That includes the enclave and of course the CPU. The client communicates with the enclave via the untrusted host. The enclave has a complex interaction with both operating system and host. For example, the OS schedules the enclave onto the CPU and provides resources, but is otherwise locked out of the enclave's operation. For its part, the enclave cannot interact with the OS directly and runs in what is effectively a \"bare metal\" embedded style environment. It cannot load DLLs/.so files or do system calls, so there's no way for it to do things like load files directly. It must ask the host to do it and use cryptography to prevent the malicious host from tampering with the data as it's loaded or saved. The purpose of Conclave is to hide this complexity to the greatest extent possible. Notice Because the enclave runtime environment isn't the same as a normal HotSpot JVM, you will need to test your enclave code carefully and avoid advanced features that the embedded JVM doesn't support, such as Java Flight Recorder. Pulling it all together \u00b6 So much for the theory. How do all the pieces fit together? In what follows, we cover some of the key concepts. How does a client know it's really talking to an enclave? How does a client decide whether to trust any given enclave? What is the flow of communication in a typical application? How does data get from a client to an enclave without the host being able to spy on it? What deployment modes are available on the journey from unit testing to production? Can Conclave be deployed to the cloud? Remote attestation \u00b6 Clients need to be sure they really are communicating with a real enclave. They cannot rely on the host merely to assert that this is the case because the host could be malicious. Instead, a process of 'remote attestion' is employed. Here is how it works. First, clients need to obtain an EnclaveInstanceInfo object. This could be downloaded on demand from the host, or it could be published somewhere. This object encapsulates a remote attestation , which includes information such as the hash of the code inside the enclave, the hash of the key of any party who has signed that code, the security status of the machine on which the enclave is running, and a public key whose private counterpart is known only to the enclave. The remote attestation encapsulated within the EnclaveInstanceInfo object is a signed data structure, with the CPU manufacturer (Intel in the case of SGX) as the root of trust. In this way, the client can have confidence about the nature of the enclave with which they are interacting even though the party from whom they obtain the EnclaveInstanceInfo is the untrusted host. The client tests the EnclaveInstanceInfo against a set of constraints , depending on how flexible they want to be about software upgrades to the enclave. Constraints are represented by an EnclaveConstraint object, which can be read from/written to a small domain specific language suitable for embedding in config files, command line options and so on. A constraint may specify that a specific set of code hashes is required i.e. every version is whitelisted and no upgrade is possible until the constraint is adjusted. Or, it may specify a set of allowed signing keys, enabling enclave authors to release new versions whenever they want. In that scenario the enclave creator is trusted, but the entity hosting the enclave instance may not be. When they're happy, they create encrypted messages using the key in the EnclaveInstanceInfo . By sending and receiving such messages to the host (and from there to the enclave), communication is established. See the Mail section below for further discussion of this. Whilst the high level setup has just those three entities, real deployments have more: Intel Optionally, a cloud provider Optionally, an auditor Intel. Intel's involvement in a deployed architecture is limited to providing the CPU hardware and running some servers. These servers provision the host with certificates guaranteeing authenticity of the chip (once, on initial setup) and provide the client with an assessment of the security of the host given a remote attestation (whenever the client requests it). If Intel's servers become unreachable by the clients that's not a problem, it just means the security of the host machine may degrade without the clients realising. For instance if the host's SGX software stack is out of date and has known vulnerabilities, or if the BIOS configuration is not correct, this will be reported to the client by Intel's servers as part of verifying and processing the data inside the remote attestation provided by the host. Cloud provider. A cloud provider needs to support SGX for Conclave to be usable. They may operate their own provisioning servers that take over from Intel's. Instructions for using Conclave on Microsoft Azure are available. Auditor. In the pure enclave-oriented model, the user is responsible for understanding what the enclave does before using it by reading the enclave's source code. If the user doesn't do this then enclaves have no point. In practice the user may wish to outsource this auditing to someone else. Deciding whether to trust an enclave \u00b6 Conclave makes it easy to write clients that understand remote attestations and to impose constraints on those attestations to ensure users only communicate with enclaves that are trusted. But how do users decide what these constraints should actually be? There are multiple options, but three of the most common are as follows: In the first model, the application developer gives the source code of their app to the customer. The customer reviews the code to check it meets their needs and is non-malicious. If so, they compile it for themselves using the Conclave SDK to determine the hash of the enclave that should be running on the remote server. They can then use this hash as their enclave constraint. If the code they reviewed and compiled for themselves is running, their client will connect. Otherwise, the client will refuse to communicate with the enclave. In reality, very few end-users would have the ability or inclination to perform this level of review for themselves and so a trusted third party - an auditor - can be engaged. To simplify matters, they can also be asked to compile the enclave. They give the compiled enclave to the application developer to host, and the hash to the customer. In situations where the code of an enclave may change fairly rapidly, this approach may not be sufficiently agile. If so, a third approach can be employed. In this model, the auditor reviews the code associated with each new enclave update and signs the resulting enclave if they are satisfied. The customer uses a signature constraint that tells their client to trust any enclave that has been signed by that auditor. Protocol sequence diagram \u00b6 This is what a typical interaction looks like: The first time SGX is used on a machine there are interactions with either the cloud provider or Intel to retrieve machine certificates proving authenticity. The host then gets a remote attestation ( EnclaveInstanceInfo ) to the client somehow, the client verifies it and optionally asks Intel if the hardware setup of the machine is still considered to be secure, or if there are known vulnerabilities (see renewability ). This can be repeated as often as the client wants, e.g. every day. Once this is done the client can send messages to the enclave through the host. Mail \u00b6 Communicating with an enclave requires sending and receiving encrypted and authenticated messages. One possible approach is to embed a TLS stack into the enclave and use something like HTTPS, but this technique has some problems and limitations that are resolved via the Conclave Mail API . Mail makes communication between enclaves and clients easy, as well as solving common problems faced with doing application development. Testing and debugging \u00b6 Conclave provides full unit testing support for enclaves. Enclaves themselves can be compiled for one of four modes: Production/release : fully encrypted and protected memory. Debug : the same as production, but special instructions are provided that allow enclave memory to be read and modified. This mode provides no protection but is otherwise a faithful recreation of the standard environment. Simulation : SGX hardware isn't actually used at all. This is helpful during development when SGX capable hardware may not be available but does still require a Linux environment or a Linux Docker container to run. Mock : In mock mode the enclave class runs in the same JVM as the host, so interactions between the enclave and host are all just regular function calls. You can step through using a debugger and enjoy the regular Java development experience. See here for more information on using and configuring mock mode . The modes must match between how the enclave was compiled and how it's loaded. This is handled for you automatically. Inside the enclave System.out and System.err are wired up to the host console, but there's no filesystem access. In release mode any output to stdout and stderr is suppressed inside the enclave so you can log to stdout and stderr without worrying that it may leak information outside the enclave when in production. Notice Future versions of the platform may automatically set up encrypted logging. For now, if you want release mode logging you can log to the in-memory filesystem and export logs from time to time to a trusted client or another enclave. Alternatively you may decide that due to the sensitive nature of what your enclave does, nobody should receive its logs when in release mode: this is a perfectly normal and reasonable choice! Deployment \u00b6 You can get SGX capable virtual machines from cloud providers. Currently Microsoft Azure provides the easiest, up to date source of SGX VMs. A Conclave host app includes the enclave bundled into the same JAR and the native libraries required for working with the kernel driver and Intel infrastructure, so you can deploy a Conclave app by simply using regular Java deployment procedures. For example, use the Gradle assemble plugin to create a tarball/zip of your app, or create a fat JAR and copy it to the server.","title":"Conclave Architecture"},{"location":"architecture.html#architecture-overview","text":"If you are new to the concept of Confidential Computing, you may also find the introduction to enclaves document helpful.","title":"Architecture overview"},{"location":"architecture.html#primary-entities","text":"There are three entities in an application that uses Conclave: Clients Hosts Enclaves Clients send and receive encrypted messages to/from enclaves by interacting with the host over the network. Conclave doesn't mandate any particular network protocol for client<->host communication. It's up to you. However the content of the messages is defined, using the Mail API. Mail is described below. Host programs load enclaves. From a security perspective they are fully untrusted and assumed to be malicious at all times. Hosts are relied on to provide the enclave with resources but beyond that work only with encrypted data. In some kinds of app their function is primarily proxying communications from clients to enclaves, but sometimes they also assist with application logic. Hosts use a standard JVM like HotSpot. Enclaves are classes that are loaded into a dedicated sub-JVM with a protected memory space, running inside the same operating system process as the host JVM. Code running in an enclave cannot be tampered with by the host system or its owner, nor can the host system or its owner see the data that the enclave is processing. Enclaves communicate with clients via the host program. To understand Confidential Computing in general, and Conclave in particular, it is helpful to keep in mind at all times that the primary purpose of the system is to enable clients securely to share data with an enclave, which will faithfully execute a specified algorithm without revealing anything to the potentially malicious host on which it runs. In the above diagram orange shaded boxes are untrusted and could attack the enclave. Notice how this threat model is extensive: we assume both the host and the operating system could be malicious, and this includes the BIOS, drivers and peripherals. By contrast, blue shaded boxes are assumed reliable. We say they are part of the trusted computing base - the set of components that must be correct and non-malicious for the system to work. That includes the enclave and of course the CPU. The client communicates with the enclave via the untrusted host. The enclave has a complex interaction with both operating system and host. For example, the OS schedules the enclave onto the CPU and provides resources, but is otherwise locked out of the enclave's operation. For its part, the enclave cannot interact with the OS directly and runs in what is effectively a \"bare metal\" embedded style environment. It cannot load DLLs/.so files or do system calls, so there's no way for it to do things like load files directly. It must ask the host to do it and use cryptography to prevent the malicious host from tampering with the data as it's loaded or saved. The purpose of Conclave is to hide this complexity to the greatest extent possible. Notice Because the enclave runtime environment isn't the same as a normal HotSpot JVM, you will need to test your enclave code carefully and avoid advanced features that the embedded JVM doesn't support, such as Java Flight Recorder.","title":"Primary entities"},{"location":"architecture.html#pulling-it-all-together","text":"So much for the theory. How do all the pieces fit together? In what follows, we cover some of the key concepts. How does a client know it's really talking to an enclave? How does a client decide whether to trust any given enclave? What is the flow of communication in a typical application? How does data get from a client to an enclave without the host being able to spy on it? What deployment modes are available on the journey from unit testing to production? Can Conclave be deployed to the cloud?","title":"Pulling it all together"},{"location":"architecture.html#remote-attestation","text":"Clients need to be sure they really are communicating with a real enclave. They cannot rely on the host merely to assert that this is the case because the host could be malicious. Instead, a process of 'remote attestion' is employed. Here is how it works. First, clients need to obtain an EnclaveInstanceInfo object. This could be downloaded on demand from the host, or it could be published somewhere. This object encapsulates a remote attestation , which includes information such as the hash of the code inside the enclave, the hash of the key of any party who has signed that code, the security status of the machine on which the enclave is running, and a public key whose private counterpart is known only to the enclave. The remote attestation encapsulated within the EnclaveInstanceInfo object is a signed data structure, with the CPU manufacturer (Intel in the case of SGX) as the root of trust. In this way, the client can have confidence about the nature of the enclave with which they are interacting even though the party from whom they obtain the EnclaveInstanceInfo is the untrusted host. The client tests the EnclaveInstanceInfo against a set of constraints , depending on how flexible they want to be about software upgrades to the enclave. Constraints are represented by an EnclaveConstraint object, which can be read from/written to a small domain specific language suitable for embedding in config files, command line options and so on. A constraint may specify that a specific set of code hashes is required i.e. every version is whitelisted and no upgrade is possible until the constraint is adjusted. Or, it may specify a set of allowed signing keys, enabling enclave authors to release new versions whenever they want. In that scenario the enclave creator is trusted, but the entity hosting the enclave instance may not be. When they're happy, they create encrypted messages using the key in the EnclaveInstanceInfo . By sending and receiving such messages to the host (and from there to the enclave), communication is established. See the Mail section below for further discussion of this. Whilst the high level setup has just those three entities, real deployments have more: Intel Optionally, a cloud provider Optionally, an auditor Intel. Intel's involvement in a deployed architecture is limited to providing the CPU hardware and running some servers. These servers provision the host with certificates guaranteeing authenticity of the chip (once, on initial setup) and provide the client with an assessment of the security of the host given a remote attestation (whenever the client requests it). If Intel's servers become unreachable by the clients that's not a problem, it just means the security of the host machine may degrade without the clients realising. For instance if the host's SGX software stack is out of date and has known vulnerabilities, or if the BIOS configuration is not correct, this will be reported to the client by Intel's servers as part of verifying and processing the data inside the remote attestation provided by the host. Cloud provider. A cloud provider needs to support SGX for Conclave to be usable. They may operate their own provisioning servers that take over from Intel's. Instructions for using Conclave on Microsoft Azure are available. Auditor. In the pure enclave-oriented model, the user is responsible for understanding what the enclave does before using it by reading the enclave's source code. If the user doesn't do this then enclaves have no point. In practice the user may wish to outsource this auditing to someone else.","title":"Remote attestation"},{"location":"architecture.html#deciding-whether-to-trust-an-enclave","text":"Conclave makes it easy to write clients that understand remote attestations and to impose constraints on those attestations to ensure users only communicate with enclaves that are trusted. But how do users decide what these constraints should actually be? There are multiple options, but three of the most common are as follows: In the first model, the application developer gives the source code of their app to the customer. The customer reviews the code to check it meets their needs and is non-malicious. If so, they compile it for themselves using the Conclave SDK to determine the hash of the enclave that should be running on the remote server. They can then use this hash as their enclave constraint. If the code they reviewed and compiled for themselves is running, their client will connect. Otherwise, the client will refuse to communicate with the enclave. In reality, very few end-users would have the ability or inclination to perform this level of review for themselves and so a trusted third party - an auditor - can be engaged. To simplify matters, they can also be asked to compile the enclave. They give the compiled enclave to the application developer to host, and the hash to the customer. In situations where the code of an enclave may change fairly rapidly, this approach may not be sufficiently agile. If so, a third approach can be employed. In this model, the auditor reviews the code associated with each new enclave update and signs the resulting enclave if they are satisfied. The customer uses a signature constraint that tells their client to trust any enclave that has been signed by that auditor.","title":"Deciding whether to trust an enclave"},{"location":"architecture.html#protocol-sequence-diagram","text":"This is what a typical interaction looks like: The first time SGX is used on a machine there are interactions with either the cloud provider or Intel to retrieve machine certificates proving authenticity. The host then gets a remote attestation ( EnclaveInstanceInfo ) to the client somehow, the client verifies it and optionally asks Intel if the hardware setup of the machine is still considered to be secure, or if there are known vulnerabilities (see renewability ). This can be repeated as often as the client wants, e.g. every day. Once this is done the client can send messages to the enclave through the host.","title":"Protocol sequence diagram"},{"location":"architecture.html#mail","text":"Communicating with an enclave requires sending and receiving encrypted and authenticated messages. One possible approach is to embed a TLS stack into the enclave and use something like HTTPS, but this technique has some problems and limitations that are resolved via the Conclave Mail API . Mail makes communication between enclaves and clients easy, as well as solving common problems faced with doing application development.","title":"Mail"},{"location":"architecture.html#testing-and-debugging","text":"Conclave provides full unit testing support for enclaves. Enclaves themselves can be compiled for one of four modes: Production/release : fully encrypted and protected memory. Debug : the same as production, but special instructions are provided that allow enclave memory to be read and modified. This mode provides no protection but is otherwise a faithful recreation of the standard environment. Simulation : SGX hardware isn't actually used at all. This is helpful during development when SGX capable hardware may not be available but does still require a Linux environment or a Linux Docker container to run. Mock : In mock mode the enclave class runs in the same JVM as the host, so interactions between the enclave and host are all just regular function calls. You can step through using a debugger and enjoy the regular Java development experience. See here for more information on using and configuring mock mode . The modes must match between how the enclave was compiled and how it's loaded. This is handled for you automatically. Inside the enclave System.out and System.err are wired up to the host console, but there's no filesystem access. In release mode any output to stdout and stderr is suppressed inside the enclave so you can log to stdout and stderr without worrying that it may leak information outside the enclave when in production. Notice Future versions of the platform may automatically set up encrypted logging. For now, if you want release mode logging you can log to the in-memory filesystem and export logs from time to time to a trusted client or another enclave. Alternatively you may decide that due to the sensitive nature of what your enclave does, nobody should receive its logs when in release mode: this is a perfectly normal and reasonable choice!","title":"Testing and debugging"},{"location":"architecture.html#deployment","text":"You can get SGX capable virtual machines from cloud providers. Currently Microsoft Azure provides the easiest, up to date source of SGX VMs. A Conclave host app includes the enclave bundled into the same JAR and the native libraries required for working with the kernel driver and Intel infrastructure, so you can deploy a Conclave app by simply using regular Java deployment procedures. For example, use the Gradle assemble plugin to create a tarball/zip of your app, or create a fat JAR and copy it to the server.","title":"Deployment"},{"location":"azure.html","text":"Deploying to Azure \u00b6 Important Azure does not guarantee access to the same machine on reboot, secrets that are encrypted for a particular enclave may be lost. Consider using the Azure Key Vault to prevent this. At time of writing, access to Azure Key Vault is not a part of the Conclave SDK (v1.1). Attestation \u00b6 Microsoft Azure provides ready-made VMs that support the latest attestation protocols. This document explains the background and provides a walkthrough showing how to get such a VM. Background: The DCAP protocol \u00b6 Note If you just want to deploy to Azure as quickly as possible you can skip this section. There are two protocols for establishing what code is running in an enclave: EPID and DCAP. EPID is an older protocol designed for consumer applications, and as such includes some sophisticated privacy features. For servers where the IP address doesn't need to be hidden (because it's public in DNS to begin with), these features aren't helpful and thus there is DCAP ( datacenter attestation primitives ). DCAP requires more modern hardware but is otherwise simpler and more robust. You may also see DCAP referred to as \"ECDSA attestation\". Important Intel does not provide EPID attestation support on any Xeon Scalable processors. This includes Ice Lake Xeon CPUs and any future generations. Please ensure you are using DCAP attestation on these platforms. In DCAP repeating attestation requests aren't forwarded to Intel, but rather served from a cache. A newly installed machine obtains a machine certificate from Intel via the cache which may then be persisted to disk. All this is automated for you. Because caches are run by cloud providers DCAP supports vendor-specific plugins. Intel provides a default one which requires a subscription . Azure provides a DCAP plugin that does not require a subscription. Conclave bundles and uses that plugin by default. The Azure caches are open to the public internet and can actually be used from anywhere. Azure Confidential Computing instances (DC4s_v2) come pre-provisioned for DCAP and as Conclave comes with the necessary libraries bundled, you don't need to do any further setup. Machine setup \u00b6 You need to create an Ubuntu 18.04 LTS Gen2 VM from the confidential compute line (named like this: DC?s_v2) where the question mark is the size. Other distributions should work as long as they are on these VMs, but we haven't tested them. Azure CLI The VM must be created inside a resource group. You may use an existing resource group or create one with the following command: 1 az group create -l <LOCATION> -n <GROUP-NAME> Now create the VM. 1 2 3 4 5 az vm create \\ --size Standard_DC4s_v2 \\ --image Canonical:UbuntuServer:18_04-lts-gen2:latest \\ --name <VM-NAME> \\ --resource-group <GROUP-NAME> VM-NAME is the name you choose for the VM and GROUP-NAME is the name of the chosen resource group. Azure Portal Make sure you do the following when creating your Azure Confidential Computing VM: Use the Ubuntu Server 18.04 (Gen2) image Pick a size that's got plenty of RAM. For example, you might want to click \"Change size\" to find DC4s_v2 type Ensure that the public inbound ports are open for SSH access Just in case, once you have logged onto the VM: Check that the enclave device is present in the /dev/sgx/ directory Check driver version dmesg | grep sgx . Conclave requires driver version 1.33+ If either check fails: Download the driver Follow the install instructions You may need to add your user into sgx_prv group to give it access to SGX. 1 sudo usermod -aG sgx_prv $USER DCAP Plugin \u00b6 In order to perform attestation using DCAP Conclave needs a way to gather information about the platform the enclave is hosted on. This information provides proof from Intel that a system supports SGX and that it is patched and up to date. DCAP is designed to work on many different server topologies, therefore rather than directly connecting to Intel services to retrieve this information, the cloud vendor or owner of the SGX system must provide a DCAP client plugin that will provide the required information. Intel provide a generic DCAP client plugin as part of the DCAP runtime. In order to use this you also need to set up a Provisioning Certificate Caching Service (PCCS). Intel provide an example and some instructions here . If you would like to use Intel's reference implementation of their PCCS service then there may be additional work required to provide data in the correct format for Conclave. Please contact R3 support if you need help in getting this setup. Microsoft has written a DCAP client plugin that works with its Azure Confidential Compute virtual machines. In fact, it also works outside of Azure for single CPU systems but this may not always be the case. Our SDK comes bundled with the Azure client plugin . The bundled version will only be used if no other plugin has been found on the system. The runtime will use the first .so it encounters in the search order below: 1 2 3 4 /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so.1 /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so /usr/lib/libdcap_quoteprov.so.1 /usr/lib/libdcap_quoteprov.so Should you decide to use a bundled version (recommended), ensure the files listed above don't exist (delete or rename them if necessary). Important The bundled DCAP Azure client plugin works with all current generation Azure confidential VMs as well as existing CPUs. However, if Azure extends their offerings to include new platforms, or if you attempt to use a new generation system such as a multi-CPU Ice Lake platform then the bundled Azure client plugin may not work and you might see an error when attempting to load your enclave. In this case follow the instructions below to build/install an updated version of the Azure client plugin that supports the platform. You may want to set the Azure DCAP client logging level to FATAL as the default setting is fairly verbose: 1 export AZDCAP_DEBUG_LOG_LEVEL = FATAL If you would like to configure the DCAP plugin yourself, keep reading. If you are using bundled version, you can skip the rest of this section. Azure client plugin \u00b6 Identify the currently installed DCAP client plugin. It will always have one of the following names: libdcap_quoteprov.so.1 or libdcap_quoteprov.so . You might find other similarly named files, but they won't be used as a plugin. 1 2 ls /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so* ls /usr/lib/libdcap_quoteprov.so* If you already have the Azure plugin installed then it will contain the text 'AZDCAP'. 1 2 grep AZDCAP /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so* grep AZDCAP /usr/lib/libdcap_quoteprov.so* If the Azure plugin is not currently installed then: You can build it from source . Or extract from a pre-built package provided by Microsoft. E.g. for Ubuntu 18.04 via the command below (only libdcap_quoteprov.so is required). 1 wget https://packages.microsoft.com/ubuntu/18.04/prod/pool/main/a/az-dcap-client/az-dcap-client_1.8_amd64.deb && ar x az-dcap-client_1.8_amd64.deb data.tar.xz && tar xvJf data.tar.xz --transform = 's/.*\\///' ./usr/lib/libdcap_quoteprov.so && rm az-dcap-client_1.8_amd64.deb data.tar.xz The preferred name and location of the DCAP client plugin is /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so.1 . 1 2 cp $( Azure-DCAP-Client ) /libdcap_quoteprov.so /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so.azure ln -sf /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so.azure /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so.1 Set the Azure DCAP client logging level to FATAL as desired. 1 export AZDCAP_DEBUG_LOG_LEVEL = FATAL Intel DCAP plugin \u00b6 Please read the installation instructions in the \"Install the DCAP packages\" section of the installation guide . Note If you happen to have the Intel DCAP plugin installed alongside the Azure one, bear in mind that running apt update might reset the symlink above to point to Intel's plugin. Using Docker container(s) \u00b6 If you plan to use a Docker container with DCAP hardware, you must map two different device files like this: 1 docker run --device /dev/sgx/enclave --device /dev/sgx/provision ... Note Azure offers a \"Confidential Kubernetes\" service. At this time we haven't tested Conclave with that. If you try it, let us and the community know if it works (conclave-discuss@groups.io) Running a Conclave Application \u00b6 Once the machine is set up, you can follow the Compiling and running tutorial to run the hello-world sample. The sample is configured to use DCAP attestation with the following line in Host.java 1 enclave . start ( new AttestationParameters . DCAP (), ... ); DCAP doesn't require any specific API keys or parameters, so just creating the empty object is sufficient to choose it.","title":"Cloud Deployment"},{"location":"azure.html#deploying-to-azure","text":"Important Azure does not guarantee access to the same machine on reboot, secrets that are encrypted for a particular enclave may be lost. Consider using the Azure Key Vault to prevent this. At time of writing, access to Azure Key Vault is not a part of the Conclave SDK (v1.1).","title":"Deploying to Azure"},{"location":"azure.html#attestation","text":"Microsoft Azure provides ready-made VMs that support the latest attestation protocols. This document explains the background and provides a walkthrough showing how to get such a VM.","title":"Attestation"},{"location":"azure.html#background-the-dcap-protocol","text":"Note If you just want to deploy to Azure as quickly as possible you can skip this section. There are two protocols for establishing what code is running in an enclave: EPID and DCAP. EPID is an older protocol designed for consumer applications, and as such includes some sophisticated privacy features. For servers where the IP address doesn't need to be hidden (because it's public in DNS to begin with), these features aren't helpful and thus there is DCAP ( datacenter attestation primitives ). DCAP requires more modern hardware but is otherwise simpler and more robust. You may also see DCAP referred to as \"ECDSA attestation\". Important Intel does not provide EPID attestation support on any Xeon Scalable processors. This includes Ice Lake Xeon CPUs and any future generations. Please ensure you are using DCAP attestation on these platforms. In DCAP repeating attestation requests aren't forwarded to Intel, but rather served from a cache. A newly installed machine obtains a machine certificate from Intel via the cache which may then be persisted to disk. All this is automated for you. Because caches are run by cloud providers DCAP supports vendor-specific plugins. Intel provides a default one which requires a subscription . Azure provides a DCAP plugin that does not require a subscription. Conclave bundles and uses that plugin by default. The Azure caches are open to the public internet and can actually be used from anywhere. Azure Confidential Computing instances (DC4s_v2) come pre-provisioned for DCAP and as Conclave comes with the necessary libraries bundled, you don't need to do any further setup.","title":"Background: The DCAP protocol"},{"location":"azure.html#machine-setup","text":"You need to create an Ubuntu 18.04 LTS Gen2 VM from the confidential compute line (named like this: DC?s_v2) where the question mark is the size. Other distributions should work as long as they are on these VMs, but we haven't tested them. Azure CLI The VM must be created inside a resource group. You may use an existing resource group or create one with the following command: 1 az group create -l <LOCATION> -n <GROUP-NAME> Now create the VM. 1 2 3 4 5 az vm create \\ --size Standard_DC4s_v2 \\ --image Canonical:UbuntuServer:18_04-lts-gen2:latest \\ --name <VM-NAME> \\ --resource-group <GROUP-NAME> VM-NAME is the name you choose for the VM and GROUP-NAME is the name of the chosen resource group. Azure Portal Make sure you do the following when creating your Azure Confidential Computing VM: Use the Ubuntu Server 18.04 (Gen2) image Pick a size that's got plenty of RAM. For example, you might want to click \"Change size\" to find DC4s_v2 type Ensure that the public inbound ports are open for SSH access Just in case, once you have logged onto the VM: Check that the enclave device is present in the /dev/sgx/ directory Check driver version dmesg | grep sgx . Conclave requires driver version 1.33+ If either check fails: Download the driver Follow the install instructions You may need to add your user into sgx_prv group to give it access to SGX. 1 sudo usermod -aG sgx_prv $USER","title":"Machine setup"},{"location":"azure.html#dcap-plugin","text":"In order to perform attestation using DCAP Conclave needs a way to gather information about the platform the enclave is hosted on. This information provides proof from Intel that a system supports SGX and that it is patched and up to date. DCAP is designed to work on many different server topologies, therefore rather than directly connecting to Intel services to retrieve this information, the cloud vendor or owner of the SGX system must provide a DCAP client plugin that will provide the required information. Intel provide a generic DCAP client plugin as part of the DCAP runtime. In order to use this you also need to set up a Provisioning Certificate Caching Service (PCCS). Intel provide an example and some instructions here . If you would like to use Intel's reference implementation of their PCCS service then there may be additional work required to provide data in the correct format for Conclave. Please contact R3 support if you need help in getting this setup. Microsoft has written a DCAP client plugin that works with its Azure Confidential Compute virtual machines. In fact, it also works outside of Azure for single CPU systems but this may not always be the case. Our SDK comes bundled with the Azure client plugin . The bundled version will only be used if no other plugin has been found on the system. The runtime will use the first .so it encounters in the search order below: 1 2 3 4 /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so.1 /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so /usr/lib/libdcap_quoteprov.so.1 /usr/lib/libdcap_quoteprov.so Should you decide to use a bundled version (recommended), ensure the files listed above don't exist (delete or rename them if necessary). Important The bundled DCAP Azure client plugin works with all current generation Azure confidential VMs as well as existing CPUs. However, if Azure extends their offerings to include new platforms, or if you attempt to use a new generation system such as a multi-CPU Ice Lake platform then the bundled Azure client plugin may not work and you might see an error when attempting to load your enclave. In this case follow the instructions below to build/install an updated version of the Azure client plugin that supports the platform. You may want to set the Azure DCAP client logging level to FATAL as the default setting is fairly verbose: 1 export AZDCAP_DEBUG_LOG_LEVEL = FATAL If you would like to configure the DCAP plugin yourself, keep reading. If you are using bundled version, you can skip the rest of this section.","title":"DCAP Plugin"},{"location":"azure.html#azure-client-plugin","text":"Identify the currently installed DCAP client plugin. It will always have one of the following names: libdcap_quoteprov.so.1 or libdcap_quoteprov.so . You might find other similarly named files, but they won't be used as a plugin. 1 2 ls /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so* ls /usr/lib/libdcap_quoteprov.so* If you already have the Azure plugin installed then it will contain the text 'AZDCAP'. 1 2 grep AZDCAP /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so* grep AZDCAP /usr/lib/libdcap_quoteprov.so* If the Azure plugin is not currently installed then: You can build it from source . Or extract from a pre-built package provided by Microsoft. E.g. for Ubuntu 18.04 via the command below (only libdcap_quoteprov.so is required). 1 wget https://packages.microsoft.com/ubuntu/18.04/prod/pool/main/a/az-dcap-client/az-dcap-client_1.8_amd64.deb && ar x az-dcap-client_1.8_amd64.deb data.tar.xz && tar xvJf data.tar.xz --transform = 's/.*\\///' ./usr/lib/libdcap_quoteprov.so && rm az-dcap-client_1.8_amd64.deb data.tar.xz The preferred name and location of the DCAP client plugin is /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so.1 . 1 2 cp $( Azure-DCAP-Client ) /libdcap_quoteprov.so /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so.azure ln -sf /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so.azure /usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so.1 Set the Azure DCAP client logging level to FATAL as desired. 1 export AZDCAP_DEBUG_LOG_LEVEL = FATAL","title":"Azure client plugin"},{"location":"azure.html#intel-dcap-plugin","text":"Please read the installation instructions in the \"Install the DCAP packages\" section of the installation guide . Note If you happen to have the Intel DCAP plugin installed alongside the Azure one, bear in mind that running apt update might reset the symlink above to point to Intel's plugin.","title":"Intel DCAP plugin"},{"location":"azure.html#using-docker-containers","text":"If you plan to use a Docker container with DCAP hardware, you must map two different device files like this: 1 docker run --device /dev/sgx/enclave --device /dev/sgx/provision ... Note Azure offers a \"Confidential Kubernetes\" service. At this time we haven't tested Conclave with that. If you try it, let us and the community know if it works (conclave-discuss@groups.io)","title":"Using Docker container(s)"},{"location":"azure.html#running-a-conclave-application","text":"Once the machine is set up, you can follow the Compiling and running tutorial to run the hello-world sample. The sample is configured to use DCAP attestation with the following line in Host.java 1 enclave . start ( new AttestationParameters . DCAP (), ... ); DCAP doesn't require any specific API keys or parameters, so just creating the empty object is sufficient to choose it.","title":"Running a Conclave Application"},{"location":"container-gradle.html","text":"Testing on macOS \u00b6 The Container Gradle script (see scripts/container-gradle ) runs Gradle inside a Docker container configured to support enclaves in simulation mode. It can be useful for testing your enclave on macOS. Usage \u00b6 Just run the script with the same command line arguments you'd pass to Gradle normally, and in the same directory. To run your host use a Gradle task that does it e.g. with the Gradle application plugin . Example: 1 2 cd hello-world ../scripts/container-gradle host:run Warning Native Image requires a lot of memory to build. Ensure you configured Docker via its GUI to allocate at least 6 GB of RAM to the virtual machine and quite possibly more. You can adjust this by clicking the little whale icon in your menu bar, clicking Preferences, going to the Resources section and moving the slider. Configuration \u00b6 Multiple containers \u00b6 By default port 9999 is mapped from the container to the host. If you want to start multiple containers at once you'll need to map a different port. You can set the CONTAINER_PORT environment variable before running the script to do this. If you want to map multiple ports or have more precise control, please edit the script. Tip If you already tried to start a second container and received the error Bind for 0.0.0.0:9999 failed: port is already allocated. , find and remove the container which has an empty value in the PORTS column, and then try again with the CONTAINER_PORT variable. Alternative JDKs \u00b6 The container will use OpenJDK 11 by default. You can request the use of a different OpenJDK by downloading one for Linux and then running the script with the LINUX_JAVA_HOME environment variable set. This allows you to run your host with Java 8, for example. If you change LINUX_JAVA_HOME then any existing container will be unusable and you'll get an error. Delete the container and re-run the script. Please go to System Requirements for more information on supported JDKs. Copying files out of the container \u00b6 Changes made inside the container will not propagate to disk on macOS. This is deliberate and intended to avoid the extremely slow Docker Linux/Mac filesystem interop layer. Instead build results are redirected to a ramdisk layered on top of the Mac filesystem. This means if you delete the container or restart Docker you'll lose your build contents. Keep what you build and run inside the container small! Use mock mode the rest of the time except when testing the enclave. There are times when you need to copy files out of the container. Although this isn't needed for actually compiling the enclave JARs, because containers and copying are handled for you in that case, when using container-gradle to run other tasks it may be needed. You may wish for example to browse HTML reports from unit test runs. The docker cp command unfortunately won't work due to documented limitations in the implementation related to tmpfs , but you can use a regular Linux cp command instead. Inside the container the /project directory is mapped read/write to the Mac directory where you ran container-gradle from. Builds take place in /overlay and any files written under this directory are redirected to the RAMdisk. Thus by copying files out of /overlay into /project you can transfer them across the slow interop layer into macOS, like so: 1 2 3 4 $ pwd /Users/foobar/my-project $ docker exec my-project cp -rv /overlay/build/test /project/test-results Troubleshooting \u00b6 If you encounter issues, you may need to remove any conclave build containers and try again. Use this command to see a list of containers: 1 2 3 > docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 3a322e580c12 conclave-build \"bash\" 45 hours ago Up 45 hours 0.0.0.0:9999->9999/tcp conclave-hello-world Find the id of the container you want to delete and remove it. If you are unsure, try removing all containers that say conclave-build in the IMAGE column: 1 docker rm -f 3a322e580c12 Now try re-running the script.","title":"Testing on macOS"},{"location":"container-gradle.html#testing-on-macos","text":"The Container Gradle script (see scripts/container-gradle ) runs Gradle inside a Docker container configured to support enclaves in simulation mode. It can be useful for testing your enclave on macOS.","title":"Testing on macOS"},{"location":"container-gradle.html#usage","text":"Just run the script with the same command line arguments you'd pass to Gradle normally, and in the same directory. To run your host use a Gradle task that does it e.g. with the Gradle application plugin . Example: 1 2 cd hello-world ../scripts/container-gradle host:run Warning Native Image requires a lot of memory to build. Ensure you configured Docker via its GUI to allocate at least 6 GB of RAM to the virtual machine and quite possibly more. You can adjust this by clicking the little whale icon in your menu bar, clicking Preferences, going to the Resources section and moving the slider.","title":"Usage"},{"location":"container-gradle.html#configuration","text":"","title":"Configuration"},{"location":"container-gradle.html#multiple-containers","text":"By default port 9999 is mapped from the container to the host. If you want to start multiple containers at once you'll need to map a different port. You can set the CONTAINER_PORT environment variable before running the script to do this. If you want to map multiple ports or have more precise control, please edit the script. Tip If you already tried to start a second container and received the error Bind for 0.0.0.0:9999 failed: port is already allocated. , find and remove the container which has an empty value in the PORTS column, and then try again with the CONTAINER_PORT variable.","title":"Multiple containers"},{"location":"container-gradle.html#alternative-jdks","text":"The container will use OpenJDK 11 by default. You can request the use of a different OpenJDK by downloading one for Linux and then running the script with the LINUX_JAVA_HOME environment variable set. This allows you to run your host with Java 8, for example. If you change LINUX_JAVA_HOME then any existing container will be unusable and you'll get an error. Delete the container and re-run the script. Please go to System Requirements for more information on supported JDKs.","title":"Alternative JDKs"},{"location":"container-gradle.html#copying-files-out-of-the-container","text":"Changes made inside the container will not propagate to disk on macOS. This is deliberate and intended to avoid the extremely slow Docker Linux/Mac filesystem interop layer. Instead build results are redirected to a ramdisk layered on top of the Mac filesystem. This means if you delete the container or restart Docker you'll lose your build contents. Keep what you build and run inside the container small! Use mock mode the rest of the time except when testing the enclave. There are times when you need to copy files out of the container. Although this isn't needed for actually compiling the enclave JARs, because containers and copying are handled for you in that case, when using container-gradle to run other tasks it may be needed. You may wish for example to browse HTML reports from unit test runs. The docker cp command unfortunately won't work due to documented limitations in the implementation related to tmpfs , but you can use a regular Linux cp command instead. Inside the container the /project directory is mapped read/write to the Mac directory where you ran container-gradle from. Builds take place in /overlay and any files written under this directory are redirected to the RAMdisk. Thus by copying files out of /overlay into /project you can transfer them across the slow interop layer into macOS, like so: 1 2 3 4 $ pwd /Users/foobar/my-project $ docker exec my-project cp -rv /overlay/build/test /project/test-results","title":"Copying files out of the container"},{"location":"container-gradle.html#troubleshooting","text":"If you encounter issues, you may need to remove any conclave build containers and try again. Use this command to see a list of containers: 1 2 3 > docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 3a322e580c12 conclave-build \"bash\" 45 hours ago Up 45 hours 0.0.0.0:9999->9999/tcp conclave-hello-world Find the id of the container you want to delete and remove it. If you are unsure, try removing all containers that say conclave-build in the IMAGE column: 1 docker rm -f 3a322e580c12 Now try re-running the script.","title":"Troubleshooting"},{"location":"enclave-configuration.html","text":"Configuration options for building enclaves \u00b6 There are a number of different options that can be configured that affect the generation of your enclave when building with the Conclave Gradle plugin. The tutorial takes you through the configuration of an enclave project step-by-step. This page goes into each possible option in detail and can be used as a reference when configuring your enclave. Adding the Conclave Gradle plugin \u00b6 The first thing to do when creating an enclave project is to add the Conclave Gradle plugin to your build.gradle file: 1 2 3 plugins { id 'com.r3.conclave.enclave' } Then add a dependency on the Conclave enclave library. The Conclave version is configured for you automatically. Also, add a test dependency on the Conclave host library so you can use mock mode for testing. 1 2 3 4 5 dependencies { implementation \"com.r3.conclave:conclave-enclave\" testImplementation \"com.r3.conclave:conclave-host\" testImplementation \"org.junit.jupiter:junit-jupiter:5.6.0\" } Conclave configuration options \u00b6 The enclave's runtime environment is configured within the conclave section in the enclave build.gradle . The complete set of options with their default values is shown below. Items marked 'Mandatory' do not have a default value and must be specified in your configuration. Items that have default values can be omitted from your configuration. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 conclave { productID = 1 // Mandatory revocationLevel = 0 // Mandatory maxHeapSize = \"256m\" maxStackSize = \"2m\" maxThreads = 10 supportLanguages = \"\" reflectionConfigurationFiles . from ( \"config.json\" ) serializationConfigurationFiles . from ( \"serialization.json\" ) simulation { } debug { } release { } } Each option is described below: productID \u00b6 Default: None. You must provide a value The product ID is an arbitrary number that can be used to distinguish between different enclaves produced by the same organisation (which may for internal reasons wish to use a single signing key). This value should not change once you have picked it. revocationLevel \u00b6 Default: None. You must provide a value The revocation level should be incremented whenever a weakness or vulnerability in the enclave code is discovered and fixed. Doing this will enable clients to avoid connecting to old, compromised enclaves. The client can set an EnclaveConstraint that specifies the required minimum revocation level when loading an enclave. The revocation level in an enclave affects the keys that are generated for 'sealing' data in an enclave. Because enclaves can generate encryption keys private to themselves, encryption and authentication can be used to stop the host editing the data. Data encrypted in this way is called sealed data . Sealed data can be re-requested from the operating system and decrypted inside the enclave. Whenever the revocation level is raised for an enclave, the data that is sealed by the new version cannot be unsealed and read by enclaves with a lower revocation level. This is not true in the opposite direction though: enclaves can unseal data that was encrypted by an enclave with a lower revocation level. This directly affects enclaves that are using mail as storage . When a new enclave is deployed with a higher revocation level and the host contains persisted data sealed with a previous version of the enclave, the newer enclave is able to process the stored mail. If a malicious host decides to drop in an older version of the enclave, potentially to exploit a discovered vulnerability in the enclave, then this older enclave cannot read the data sealed using an enclave with a higher revocation level. This behaviour allows for uninterrupted communication with clients across upgrades of the enclave. The persisted data is automatically upgraded to the higher security level as it is consumed and resealed by the new enclave, incrementally phasing out the previous version of the enclave, thus recovering from a compromise. Tip The revocation level should not be incremented on every new release, but only when security improvements have been made. maxHeapSize \u00b6 Default: 256m This setting defines the maximum size the heap is allowed to grow to in the runtime environment inside the enclave. You might be familiar with the JVM option -Xmx which allows you to set the maximum heap size of a JVM based application. Most of the time in a normal JVM application you can just leave this setting alone and let the JVM decide the heap size. However the option is there in case you need to increase beyond the default maximum, or if you want to configure your application to use less memory to co-exist with other applications. The maxHeapSize setting provides the same control over heap memory as the JVM provides, but for the runtime environment in the enclave. Why is there a separate heap for enclaves? This requires a bit of explanation: In order to keep your data private, all data allocated inside an enclave is encrypted. This encryption is implemented using SGX hardware in a block of physical memory that Intel have named the \"Encrypted Page Cache\" or \"EPC\". Whenever you create an object or store some data in memory inside an enclave it is stored in this EPC memory. This is why the enclave runtime manages its own heap - to ensure all data stays with the EPC memory. So, what should the heap size be set to? This depends. In most cases you can leave this setting at its default value of 256Mb. For many enclaves this will be enough. However your enclave may want access to a very large set of data. In this case you want to increase the heap size. What happens if you want to specify a heap size that is greater than the EPC provided on your SGX system? Well, this is not a problem as SGX allows EPC memory to be 'paged'. This means that when you want some EPC memory but none is available, SGX will take an existing portion of memory, encrypt it inside the enclave then move it to conventional, non-EPC memory to make space for the new block. When the enclave needs to access the original memory, it juggles other pages to make space in EPC to move the block back from conventional memory and decrypt it. The downside to this 'paging' is that it has a performance impact. Therefore, if performance is important then it is recommended to keep your enclave memory usage as small as possible, preferably less than the size of the EPC on your SGX system to reduce the amount of paging that occurs. This is something to consider when looking at sizing your SGX capable system. For example, your enclave may run without any problems on a system with 128Mb of EPC but it may run much faster and with less CPU load on a system with 256Mb or more EPC. Tip The size is specified in bytes but you can put a k , m or g after the value to specify it in kilobytes, megabytes or gigabytes respectively. maxThreads \u00b6 Default: 10 This is an advanced setting that defines the maximum number of threads that can be active inside an enclave simultaneously. If you're interested, you can read this detailed technical description , otherwise you can safely leave this at the default value. Changing this value does not affect the maximum number of threads that you can simultaneously call into a Conclave enclave but affect the number of threads that you can create inside the enclave. The maxThreads option defines how many EPC slots are available for threads that are simultaneously active inside the enclave. Setting a higher number for this results in a larger SGX EPC memory requirement for the enclave even if not all the thread slots are currently in use inside the enclave. deadlockTimeout \u00b6 Default: 10 This is an advanced setting related to maxThreads that determines the time after which all enclave threads have been blocked that Conclave will assume the threads are deadlocked and abort the enclave. See this section on deadlocks in enclave threads for more information. Tip If you are having problems with deadlocks in your enclave threads then we recommend contacting R3 support for help in solving the problem. maxStackSize \u00b6 Default: 2m This is an advanced setting that specifies the stack size that will be allocated for each thread that runs inside the enclave. Normally you would not need to specify this setting in your configuration, the default of 2Mb being sufficient for most applications. Only change this setting if you are seeing errors related to the stack overflowing. The stack is used internally by the JVM to hold information about the current function; the chain of functions that called the current function (the 'call stack'); temporary variables and other contextual information. Stack can be consumed in different ways but the default value provided for maxStackSize ensures you will likely never see an exhausted stack unless you accidentally generate an infinite recursion via a function calling itself. When the host calls into the enclave and the context is switched from the host JVM into the enclave runtime, the host stack cannot be used as it could potentially leak secret information on return. Instead, an in-enclave stack is used. When a value is provided for maxStackSize the in-enclave stack is set to this size for each thread that runs inside the enclave. Tip As with maxHeapSize , the size is specified in bytes but you can put a k , m or g after the value to specify it in kilobytes, megabytes or gigabytes respectively. supportLanguages \u00b6 Default: \"\" A comma separated list of languages to support using the polyglot context capability provided by GraalVM. This allows for code in the supported languages to be parsed and invoked by the enclave giving the ability to deploy dynamic code, or to develop part of your enclave logic in a different language. The current version of conclave only supports JavaScript so the value for this setting can either be the default empty string or \"js\" indicating the enclave should provide support for JavaScript polyglot contexts. See this page on running JavaScript in your enclave for details on how to use this setting. simulation, debug and release \u00b6 These sections contain the settings for signing the enclave. See the page on signing for information on these settings. reflectionConfigurationFiles \u00b6 Default: empty list A list of reflection configuration files as specified in the Reflection section of Graal's reference manual. This allows for code which rely on reflection to specify which classes, methods, fields and their properties will be available at run time. serializationConfigurationFiles \u00b6 Default: empty list A list of serialization configuration files as specified in Graal's Serialization documentation file. This allows to specify classes which are expected to be serialized using Java serialization. Assisted Configuration of Native Image Builds \u00b6 One way of generating the reflection and serialization configuration files is by using native-image-agent . The agent will track usage of dynamic features and generate the configuration files when run against a regular Java VM. To ensure all of the necessary classes/resources are included in the configuration files you should ensure all enclave code paths are executed, for example by writing extensive tests and running them in mock mode. When placed under enclave/src/main/resources/META-INF/native-image the configuration files will be picked up by Gradle when building the enclave in simulation , debug or release modes. Running the host through Gradle and/or JUnit tests while the agent is enabled will likely cause Gradle, JUnit or host classes to be present in the configuration files. To avoid this you can configure filters to ensure host code is excluded or you can run the host as an executable JAR and trigger enclave logic by running it normally, like you would if you were to deploy it, for example, by sending requests from the host and/or client triggering as much of the enclave logic as possible. You can use the Shadow Gradle plugin to create an executable JAR which contains all the host's and enclave's dependencies. It is possible the generated configuration files aren't always correct, meaning you may need to adjust filters and/or edit and maintain them throughout the development process. We recommend keeping these files version controlled to make maintenance easier. Conclave ships with a Linux GraalVM containing the native-image-agent , which can also be used via container-gradle . As an alternative to container-gradle you can download GraalVM for your operating system. See both options below. Example using Conclave's GraalVM \u00b6 Configure the application plugin on the host 's build.gradle : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 plugins { id 'application' } def graalVMDir = tasks . getByPath ( \":enclave:untarGraalVM\" ). outputs . files . first () def configurationDir = project ( \":enclave\" ). projectDir . toPath (). resolve ( \"src/main/resources/META-INF/native-image\" ) def filterFile = configurationDir . resolve ( \"filter.json\" ) application { run . dependsOn ( \":enclave:untarGraalVM\" ) if ( project . hasProperty ( \"generateConfigFiles\" ) && properties . get ( \"enclaveMode\" ). toString (). toLowerCase () == \"mock\" != null ) { applicationDefaultJvmArgs = [ \"-agentpath:$graalVMDir/jre/lib/amd64/libnative-image-agent.so=config-output-dir=$configurationDir,\" + \"caller-filter-file=$filterFile\" ] } } Conclave's GraalVM path is obtained from the untarGraalVM task of the enclave project. The filter.json and the configuration files generated by native-image-agent will be placed on the enclave 's resource directory. The Gradle properties generateConfigFiles and enclaveMode are used to control when the files should be generated. Create the enclave/src/main/resources/META-INF/native-image/filter.json excluding classes expected to be captured by native-image-agent which are not part of the enclave code: 1 2 3 4 5 { \"rules\" : [ { \"excludeClasses\" : \"nonapi.**\" }, { \"excludeClasses\" : \"com.r3.conclave.host.**\" } ] } Run the host: Linux 1 ./gradlew -PgenerateConfigFiles -PenclaveMode = mock host:run macOS 1 ../scripts/container-gradle -PgenerateConfigFiles -PenclaveMode=mock host:run Tip This process works best when the JDK used to generate the configuration files is the same version that will subsequently be used to create the enclave's native image. Check Alternative JDKs for details on how to ensure this is the case. Trigger enclave logic by running client requests: 1 ./gradlew client:run Tip If using MacOS, configuration files will be stored in a docker container. See how to copy files out of the container . Example using the executable JAR \u00b6 To avoid container-gradle, download GraalVM for your operating system and install it. Once you setup your GraalVM, ensure native-image is installed: 1 $JAVA_HOME /bin/gu install native-image Also enable native-image-agent on the command line of the GraalVM java command: 1 $JAVA_HOME /bin/java -agentlib:native-image-agent = config-output-dir = /path/to/enclave/src/main/resources/META-INF/native-image/ ... Add the Shadow Gradle plugin to the plugins section of the host 's build.gradle : 1 2 3 plugins { id 'com.github.johnrengelman.shadow' version '6.1.0' } Generate the shadow jar: 1 ./gradlew -PenclaveMode = mock host:shadowJar Default location should be host/build/libs/host-all.jar . Run the host with the agent enabled to generate the configuration files: 1 $JAVA_HOME /bin/java -agentlib:native-image-agent = config-output-dir = /path/to/enclave/src/main/resources/META-INF/native-image/,caller-filter-file = /path/to/enclave/src/main/resources/META-INF/native-image/filter.json -jar /path/to/host/build/libs/host-all.jar Trigger enclave logic by sending client requests. 1 ./gradlew client:run","title":"Configuration options for enclaves"},{"location":"enclave-configuration.html#configuration-options-for-building-enclaves","text":"There are a number of different options that can be configured that affect the generation of your enclave when building with the Conclave Gradle plugin. The tutorial takes you through the configuration of an enclave project step-by-step. This page goes into each possible option in detail and can be used as a reference when configuring your enclave.","title":"Configuration options for building enclaves"},{"location":"enclave-configuration.html#adding-the-conclave-gradle-plugin","text":"The first thing to do when creating an enclave project is to add the Conclave Gradle plugin to your build.gradle file: 1 2 3 plugins { id 'com.r3.conclave.enclave' } Then add a dependency on the Conclave enclave library. The Conclave version is configured for you automatically. Also, add a test dependency on the Conclave host library so you can use mock mode for testing. 1 2 3 4 5 dependencies { implementation \"com.r3.conclave:conclave-enclave\" testImplementation \"com.r3.conclave:conclave-host\" testImplementation \"org.junit.jupiter:junit-jupiter:5.6.0\" }","title":"Adding the Conclave Gradle plugin"},{"location":"enclave-configuration.html#conclave-configuration-options","text":"The enclave's runtime environment is configured within the conclave section in the enclave build.gradle . The complete set of options with their default values is shown below. Items marked 'Mandatory' do not have a default value and must be specified in your configuration. Items that have default values can be omitted from your configuration. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 conclave { productID = 1 // Mandatory revocationLevel = 0 // Mandatory maxHeapSize = \"256m\" maxStackSize = \"2m\" maxThreads = 10 supportLanguages = \"\" reflectionConfigurationFiles . from ( \"config.json\" ) serializationConfigurationFiles . from ( \"serialization.json\" ) simulation { } debug { } release { } } Each option is described below:","title":"Conclave configuration options"},{"location":"enclave-configuration.html#productid","text":"Default: None. You must provide a value The product ID is an arbitrary number that can be used to distinguish between different enclaves produced by the same organisation (which may for internal reasons wish to use a single signing key). This value should not change once you have picked it.","title":"productID"},{"location":"enclave-configuration.html#revocationlevel","text":"Default: None. You must provide a value The revocation level should be incremented whenever a weakness or vulnerability in the enclave code is discovered and fixed. Doing this will enable clients to avoid connecting to old, compromised enclaves. The client can set an EnclaveConstraint that specifies the required minimum revocation level when loading an enclave. The revocation level in an enclave affects the keys that are generated for 'sealing' data in an enclave. Because enclaves can generate encryption keys private to themselves, encryption and authentication can be used to stop the host editing the data. Data encrypted in this way is called sealed data . Sealed data can be re-requested from the operating system and decrypted inside the enclave. Whenever the revocation level is raised for an enclave, the data that is sealed by the new version cannot be unsealed and read by enclaves with a lower revocation level. This is not true in the opposite direction though: enclaves can unseal data that was encrypted by an enclave with a lower revocation level. This directly affects enclaves that are using mail as storage . When a new enclave is deployed with a higher revocation level and the host contains persisted data sealed with a previous version of the enclave, the newer enclave is able to process the stored mail. If a malicious host decides to drop in an older version of the enclave, potentially to exploit a discovered vulnerability in the enclave, then this older enclave cannot read the data sealed using an enclave with a higher revocation level. This behaviour allows for uninterrupted communication with clients across upgrades of the enclave. The persisted data is automatically upgraded to the higher security level as it is consumed and resealed by the new enclave, incrementally phasing out the previous version of the enclave, thus recovering from a compromise. Tip The revocation level should not be incremented on every new release, but only when security improvements have been made.","title":"revocationLevel"},{"location":"enclave-configuration.html#maxheapsize","text":"Default: 256m This setting defines the maximum size the heap is allowed to grow to in the runtime environment inside the enclave. You might be familiar with the JVM option -Xmx which allows you to set the maximum heap size of a JVM based application. Most of the time in a normal JVM application you can just leave this setting alone and let the JVM decide the heap size. However the option is there in case you need to increase beyond the default maximum, or if you want to configure your application to use less memory to co-exist with other applications. The maxHeapSize setting provides the same control over heap memory as the JVM provides, but for the runtime environment in the enclave. Why is there a separate heap for enclaves? This requires a bit of explanation: In order to keep your data private, all data allocated inside an enclave is encrypted. This encryption is implemented using SGX hardware in a block of physical memory that Intel have named the \"Encrypted Page Cache\" or \"EPC\". Whenever you create an object or store some data in memory inside an enclave it is stored in this EPC memory. This is why the enclave runtime manages its own heap - to ensure all data stays with the EPC memory. So, what should the heap size be set to? This depends. In most cases you can leave this setting at its default value of 256Mb. For many enclaves this will be enough. However your enclave may want access to a very large set of data. In this case you want to increase the heap size. What happens if you want to specify a heap size that is greater than the EPC provided on your SGX system? Well, this is not a problem as SGX allows EPC memory to be 'paged'. This means that when you want some EPC memory but none is available, SGX will take an existing portion of memory, encrypt it inside the enclave then move it to conventional, non-EPC memory to make space for the new block. When the enclave needs to access the original memory, it juggles other pages to make space in EPC to move the block back from conventional memory and decrypt it. The downside to this 'paging' is that it has a performance impact. Therefore, if performance is important then it is recommended to keep your enclave memory usage as small as possible, preferably less than the size of the EPC on your SGX system to reduce the amount of paging that occurs. This is something to consider when looking at sizing your SGX capable system. For example, your enclave may run without any problems on a system with 128Mb of EPC but it may run much faster and with less CPU load on a system with 256Mb or more EPC. Tip The size is specified in bytes but you can put a k , m or g after the value to specify it in kilobytes, megabytes or gigabytes respectively.","title":"maxHeapSize"},{"location":"enclave-configuration.html#maxthreads","text":"Default: 10 This is an advanced setting that defines the maximum number of threads that can be active inside an enclave simultaneously. If you're interested, you can read this detailed technical description , otherwise you can safely leave this at the default value. Changing this value does not affect the maximum number of threads that you can simultaneously call into a Conclave enclave but affect the number of threads that you can create inside the enclave. The maxThreads option defines how many EPC slots are available for threads that are simultaneously active inside the enclave. Setting a higher number for this results in a larger SGX EPC memory requirement for the enclave even if not all the thread slots are currently in use inside the enclave.","title":"maxThreads"},{"location":"enclave-configuration.html#deadlocktimeout","text":"Default: 10 This is an advanced setting related to maxThreads that determines the time after which all enclave threads have been blocked that Conclave will assume the threads are deadlocked and abort the enclave. See this section on deadlocks in enclave threads for more information. Tip If you are having problems with deadlocks in your enclave threads then we recommend contacting R3 support for help in solving the problem.","title":"deadlockTimeout"},{"location":"enclave-configuration.html#maxstacksize","text":"Default: 2m This is an advanced setting that specifies the stack size that will be allocated for each thread that runs inside the enclave. Normally you would not need to specify this setting in your configuration, the default of 2Mb being sufficient for most applications. Only change this setting if you are seeing errors related to the stack overflowing. The stack is used internally by the JVM to hold information about the current function; the chain of functions that called the current function (the 'call stack'); temporary variables and other contextual information. Stack can be consumed in different ways but the default value provided for maxStackSize ensures you will likely never see an exhausted stack unless you accidentally generate an infinite recursion via a function calling itself. When the host calls into the enclave and the context is switched from the host JVM into the enclave runtime, the host stack cannot be used as it could potentially leak secret information on return. Instead, an in-enclave stack is used. When a value is provided for maxStackSize the in-enclave stack is set to this size for each thread that runs inside the enclave. Tip As with maxHeapSize , the size is specified in bytes but you can put a k , m or g after the value to specify it in kilobytes, megabytes or gigabytes respectively.","title":"maxStackSize"},{"location":"enclave-configuration.html#supportlanguages","text":"Default: \"\" A comma separated list of languages to support using the polyglot context capability provided by GraalVM. This allows for code in the supported languages to be parsed and invoked by the enclave giving the ability to deploy dynamic code, or to develop part of your enclave logic in a different language. The current version of conclave only supports JavaScript so the value for this setting can either be the default empty string or \"js\" indicating the enclave should provide support for JavaScript polyglot contexts. See this page on running JavaScript in your enclave for details on how to use this setting.","title":"supportLanguages"},{"location":"enclave-configuration.html#simulation-debug-and-release","text":"These sections contain the settings for signing the enclave. See the page on signing for information on these settings.","title":"simulation, debug and release"},{"location":"enclave-configuration.html#reflectionconfigurationfiles","text":"Default: empty list A list of reflection configuration files as specified in the Reflection section of Graal's reference manual. This allows for code which rely on reflection to specify which classes, methods, fields and their properties will be available at run time.","title":"reflectionConfigurationFiles"},{"location":"enclave-configuration.html#serializationconfigurationfiles","text":"Default: empty list A list of serialization configuration files as specified in Graal's Serialization documentation file. This allows to specify classes which are expected to be serialized using Java serialization.","title":"serializationConfigurationFiles"},{"location":"enclave-configuration.html#assisted-configuration-of-native-image-builds","text":"One way of generating the reflection and serialization configuration files is by using native-image-agent . The agent will track usage of dynamic features and generate the configuration files when run against a regular Java VM. To ensure all of the necessary classes/resources are included in the configuration files you should ensure all enclave code paths are executed, for example by writing extensive tests and running them in mock mode. When placed under enclave/src/main/resources/META-INF/native-image the configuration files will be picked up by Gradle when building the enclave in simulation , debug or release modes. Running the host through Gradle and/or JUnit tests while the agent is enabled will likely cause Gradle, JUnit or host classes to be present in the configuration files. To avoid this you can configure filters to ensure host code is excluded or you can run the host as an executable JAR and trigger enclave logic by running it normally, like you would if you were to deploy it, for example, by sending requests from the host and/or client triggering as much of the enclave logic as possible. You can use the Shadow Gradle plugin to create an executable JAR which contains all the host's and enclave's dependencies. It is possible the generated configuration files aren't always correct, meaning you may need to adjust filters and/or edit and maintain them throughout the development process. We recommend keeping these files version controlled to make maintenance easier. Conclave ships with a Linux GraalVM containing the native-image-agent , which can also be used via container-gradle . As an alternative to container-gradle you can download GraalVM for your operating system. See both options below.","title":"Assisted Configuration of Native Image Builds"},{"location":"enclave-configuration.html#example-using-conclaves-graalvm","text":"Configure the application plugin on the host 's build.gradle : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 plugins { id 'application' } def graalVMDir = tasks . getByPath ( \":enclave:untarGraalVM\" ). outputs . files . first () def configurationDir = project ( \":enclave\" ). projectDir . toPath (). resolve ( \"src/main/resources/META-INF/native-image\" ) def filterFile = configurationDir . resolve ( \"filter.json\" ) application { run . dependsOn ( \":enclave:untarGraalVM\" ) if ( project . hasProperty ( \"generateConfigFiles\" ) && properties . get ( \"enclaveMode\" ). toString (). toLowerCase () == \"mock\" != null ) { applicationDefaultJvmArgs = [ \"-agentpath:$graalVMDir/jre/lib/amd64/libnative-image-agent.so=config-output-dir=$configurationDir,\" + \"caller-filter-file=$filterFile\" ] } } Conclave's GraalVM path is obtained from the untarGraalVM task of the enclave project. The filter.json and the configuration files generated by native-image-agent will be placed on the enclave 's resource directory. The Gradle properties generateConfigFiles and enclaveMode are used to control when the files should be generated. Create the enclave/src/main/resources/META-INF/native-image/filter.json excluding classes expected to be captured by native-image-agent which are not part of the enclave code: 1 2 3 4 5 { \"rules\" : [ { \"excludeClasses\" : \"nonapi.**\" }, { \"excludeClasses\" : \"com.r3.conclave.host.**\" } ] } Run the host: Linux 1 ./gradlew -PgenerateConfigFiles -PenclaveMode = mock host:run macOS 1 ../scripts/container-gradle -PgenerateConfigFiles -PenclaveMode=mock host:run Tip This process works best when the JDK used to generate the configuration files is the same version that will subsequently be used to create the enclave's native image. Check Alternative JDKs for details on how to ensure this is the case. Trigger enclave logic by running client requests: 1 ./gradlew client:run Tip If using MacOS, configuration files will be stored in a docker container. See how to copy files out of the container .","title":"Example using Conclave's GraalVM"},{"location":"enclave-configuration.html#example-using-the-executable-jar","text":"To avoid container-gradle, download GraalVM for your operating system and install it. Once you setup your GraalVM, ensure native-image is installed: 1 $JAVA_HOME /bin/gu install native-image Also enable native-image-agent on the command line of the GraalVM java command: 1 $JAVA_HOME /bin/java -agentlib:native-image-agent = config-output-dir = /path/to/enclave/src/main/resources/META-INF/native-image/ ... Add the Shadow Gradle plugin to the plugins section of the host 's build.gradle : 1 2 3 plugins { id 'com.github.johnrengelman.shadow' version '6.1.0' } Generate the shadow jar: 1 ./gradlew -PenclaveMode = mock host:shadowJar Default location should be host/build/libs/host-all.jar . Run the host with the agent enabled to generate the configuration files: 1 $JAVA_HOME /bin/java -agentlib:native-image-agent = config-output-dir = /path/to/enclave/src/main/resources/META-INF/native-image/,caller-filter-file = /path/to/enclave/src/main/resources/META-INF/native-image/filter.json -jar /path/to/host/build/libs/host-all.jar Trigger enclave logic by sending client requests. 1 ./gradlew client:run","title":"Example using the executable JAR"},{"location":"enclaves.html","text":"Confidential Computing \u00b6 When you send data to somebody else's computer they can ordinarily do whatever they like with it. Confidential Computing describes a set of hardware techniques that fix this problem. Confidential Computing makes it possible to know what algorithm will process your information before you send it to a third party, and to be assured that the third party cannot subvert the integrity of the algorithm or observe it while it works. Conclave makes it easy to write applications that utilise these capabilities. Conclave makes it possible to isolate a small piece of code from the rest of the computer on which it runs (an enclave ). Remote users can be shown what code is running in the isolated world and then upload their secret data to it, where it can be processed without the owner of the computer in question getting access. Enclaves can be used to protect private data from the cloud, do multi-party computations on shared datasets and make networks more secure. Intel SGX is an implementation of enclave-oriented computing. Conclave builds on SGX by making it easier to develop enclaves in high level languages like Java, Kotlin or JavaScript. In this document we'll introduce the key concepts of Confidential Computing and map them to the equivalent concepts in Conclave. The architecture document then pulls these concepts together to describe the end-to-end architecture of Conclave itself. What is an enclave? \u00b6 An enclave is a region of memory which the CPU blocks access to, running inside an ordinary process which we call the host . The region contains both code and data, neither of which can be read or tampered with by anything else. Code executing inside this region has access to special CPU instructions that give it a variety of useful abilities. Enclave memory is protected both from the rest of the code in that process, privileged software like the kernel or BIOS, and because the RAM itself is encrypted even physical attackers. This means a remote computer can trust that an enclave will operate correctly even if the owner of the computer is malicious. In Conclave, an enclave is a subclass of the Enclave class, which is automatically combined by Conclave with an embedded JVM and compiled into a native shared library (ending in .so), and bundled into a JAR. The host program then uses the EnclaveHost class to load the enclave class from this JAR and automatically instantiate the enclave. Note Conclave compiles the enclave into a .so file because that's how the Intel SGX SDK expects the enclave to be built. Conclave hides this detail during the build phase by wrapping this file inside a Jar artifact, and during execution phase automatically loads the .so file from the classpath. Enclaves and Hosts \u00b6 As described above, an enclave is loaded into an ordinary operating system process, which is known as the 'host'. All of the enclave's communicates with the outside world is via the host. To facilitate this, once an enclave is loaded, the host and enclave can exchange byte buffers back and forth. This is an efficient operation: the buffers are copied from the host into the enclave using a direct memory copy. Conclave provides convenient APIs to facilitate this data passing between enclave and host. However, it is important to note that, unlike the enclave, neither this 'host' process nor the underlying operating system are trusted by the users of the enclave. Yet the enclave depends on them. The following sections explain how message encryption, remote attestation, and the Conclave-specific 'Mail' API combine to solve this problem. Note In many ways, enclaves turn pre-existing security assumptions on their heads. In traditional programming, it is generally assumed that the operating system is trusted and that the primary threat is applications attacking the operating system, or each other. However, when using enclaves, this presumption is reversed: the user of the application, who is remote, does not trust the operator or operating system of the computer. Instead, they only trust the code running inside the enclave. Therefore, it is useful to imagine the operating system and the process that hosts the enclave as potential adversaries. Unfortunately, most existing software is built on the assumption that the operating system is not a threat . For this reason, it is usually best to avoid relying inside the enclave on code that was not explicitly written with this deployment mode in mind. Encrypted messages \u00b6 Enclaves are only useful if some other computer is interacting with them over the network. An enclave by itself doesn't gain you anything, because enclaves are defending against the owner of a computer. If you just run an enclave locally then the owner of the computer is you, and it doesn't make sense for software to try and protect your own data from yourself. So these remote users need to be able to encrypt messages with a key that is known only to the enclave. Enclaves can generate random numbers and thus encryption keys available only to themselves, which nothing else on the host machine can access. Using these keys remote computers can encrypt messages to the enclave. These messages can be passed into the enclave via the host where they are decrypted and worked on. The owner of the host computer can't read them, despite that the data is being processed on their hardware. Conclave calls these encrypted messages mails , by way of analogy to encrypted e-mail, but enclaves can work with encryption in whatever way they want. The Mail API is just a utility and you don't have to use it. Remote attestation \u00b6 Encrypting a message requires a public key, which raises the question of where that key comes from. The clients of the enclave have to be convinced that the key really belongs to an enclave they want to work with and not, say, an unencrypted non-enclave program that's impersonating the intended destination. Enclave host programs can generate a small data structure called a remote attestation (RA). This structure, which is signed by a key controlled by the underlying hardware, states the following facts: A genuine, un-revoked Intel CPU is running ... ... an enclave into which a code module with a specific hash (measurement) was loaded ... ... and which has generated public key P ... ... and the computer is up to date with security patches, and configured in the recommended way. The host generates a remote attestation and sends it to clients in some way. Those clients can then send encrypted messages to the enclave using the public key P after checking what kind of enclave it really is. By recognising a list of known code hashes, or verifying that the enclave was signed by a party whom they trust, clients can effectively whitelist particular enclaves and treat them as trustworthy servers. In Conclave, a remote attestation is an instance of the EnclaveInstanceInfo class. Applications of Enclaves \u00b6 Enclaves are a very general capability and can be used in a variety of ways. You can: Process private data without being able to see it yourself, to enhance your user's privacy. Create a hardware-backed form of zero knowledge proofs: make trustworthy 'statements' that a particular computation was done on some data, without the data itself needing to be revealed. Outsource some kinds of computations to an untrusted cloud. Improve the security of a server by restricting access to a whitelist of client enclaves, blocking attempts to send malformed packets and messages that might come from hackers. Make your service auditable only by users who want high assurance - those who don't care can simply ignore the infrastructure entirely. Limitations of Enclaves \u00b6 It's important to understand the limitations of enclaves. They aren't meant to be a general protection for arbitrary programs. Although technically possible to just relay operating system calls in and out of an enclave, this approach suffers from various security pitfalls and more importantly is a mis-understanding of the benefits enclaves give you. Confidential computing is based on two key insights: The more code that processes attacker-supplied data the more likely the program is to be hackable. A large chunk of most programs is actually just moving data around and managing it in various ways, not processing it. The software and hardware that must be uncompromised for a system to work correctly is called the trusted computing base , or TCB. In Conclave the TCB includes the CPU itself, the patchable microcode of the CPU, and all software running inside the enclave - both your code and the Conclave runtime. A major goal in secure systems design is to minimise the size of the TCB. This is for two reasons. Security \u00b6 The software industry has decades of experience with building secure and tamperproof systems. A simple heuristic is that the more code there is inside the TCB that handles attacker-controlled data, the easier it will be for an adversary to find a mistake and break in. It's always been good design to minimise the amount of code that handles potentially malicious data and enclaves give you an even greater incentive to do so. That's because enclaves don't magically make the software inside them un-hackable. They protect the code and its memory from outside interference by the owner of the computer (and any hackers that gained access to the operating system) but if the code running inside the enclave has a bug that can be used to get in, those protections are of no use. Thus it's important for an enclave to be written securely. Conclave helps with this dramatically because it lets you write enclave logic in memory-safe, type-safe languages like Java or Kotlin. These languages eliminate by construction huge swathes of bugs. All buffer bounds are checked, no memory is freed before use and all casts are valid. This makes it much easier to process data from outside the enclave because you don't have to worry that you might accidentally let an attacker in. Sometimes people find this confusing: a JVM is quite large, so if the TCB needs to be small isn't that a problem? It's not for two reasons. One reason is because this heuristic only applies for code that an attacker can actually reach and influence via external input, but the input data to the JVM (bytecode) is itself a fixed part of the enclave. Attackers can't modify it without changing the measurement reported in the remote attestation and thus being detected by the client - the client's enclave constraint will be violated and an exception will be thrown. The second reason is that Conclave uses the GraalVM Native Image JVM, in which all bytecode is compiled to native code ahead of time. The actual JVM in use is therefore quite tiny; it consists mostly of the garbage collector. Warning Whilst garbage collected/type safe programs are much safer than programs written in C, they aren't immune to vulnerabilities. Watch out for very generic reflective code like object serialization frameworks, that could be tricked into deserializing malicious streams. Auditability \u00b6 Enclaves are meaningless unless the user verifies the enclave does what they think it does before sending it private data. As the enclave size goes up it gets harder to read and understand its code. In practice audit work will often be outsourced: we don't expect that every end user of an enclave reads all the code themselves. Ultimately though, someone the user trusts must read all the code inside the enclave. The less there is to read the better. A lot of code works with data without parsing or understanding it. For instance, network frameworks read packets from the wire and databases store data to disk in generic ways. Other parts of a program truly understand the data and work with it in app-specific ways; usually this is called business logic. In enclave-oriented design you draw a bright line between host code and business logic. Business logic runs inside an enclave on normal Java objects. Host code does everything else: Network handling Storage Routing Monitoring Providing administration interfaces and so on. Keeping as much code in the host as possible has two key advantages: The host code is untrusted and assumed to be compromised. Thus any bugs in it are much less serious. You can worry less about security vulnerabilities in the host code because it can't access your user's private data. Because the enclave is small it will change less frequently, meaning clients don't need to re-audit or whitelist new versions. The second point is intuitive to understand. Think of your enclave as a concrete version of your privacy policy. If you change your web server, core database engine or even entire operating system then this is of no concern to your users. You've only changed how data is processed. But if you change what you do with their data, they may have an opinion on this and want to know about it. Remote attestation lets them see that the core business logic has changed, and in what way. Summary \u00b6 In summary, an enclave is a small program which can run on an untrusted computer, where the operator of that computer cannot affect the integrity of the code nor observe the data that passes in or out. Through a process of 'remote attestation', remote clients can gain confidence that a specific program - or a program signed by a particular entity - is running, and that it is running in this secure mode on a fully patched machine. This makes it possible to deliver services that operate on third parties' data, where those third parties can be assured that their data cannot be used for any other purpose. Enclaves run inside untrusted host processes, and the combination of encryption, remote attestation and Conclave's purpose-designed APIs work together to make it as simple as possible for developers to write applications that work in this way. Additional Comments \u00b6 A note on measurements vs signers \u00b6 The code hash included in a remote attestation is called a measurement . It's not the hash of any particular file but rather a more complex hash that must be calculated with special tools. It covers the entire module and all of its dependencies loaded into an enclave (a fat JAR). A measurement hash is pretty unhelpful by itself. It's just a large number. To be meaningful you must reproduce the measurement from the source code of the enclave. When you compile your enclave the measurement hash is calculated and printed. By comparing it to what you find inside a remote attestation, you can know the source code of the remote enclave matches what you have locally. Whitelisting measurements is strong but brittle. Any upgrade to the enclave will cause your app to reject the new remote attestation and stop working until you re-read the enclave's source code, reproduce the build again and whitelist the new measurement. An alternative is to whitelist a signing key instead. Enclave files must be signed, and the SGX infrastructure understands and verifies these signatures. This is useful for two reasons: You can choose to accept any enclave signed by a particular organisation, rather than reviewing the source code and reproducing the enclave yourself. Some SGX capable computers have a root key that must whitelist enclaves to be executed. This can be used by the owners of SGX-capable machines to retain visibility and control into what programs are actually running on their hardware. Whilst this capability could therefore be leveraged by cloud vendors to restrict which SGX workloads their servers will allow to run, we are not aware of any that operate in this way in practice. The hash of the public part of the key that signed an enclave is included in remote attestations, so you can choose to communicate with any enclave signed by a given key. Enclaves vs alternative approaches \u00b6 The enclave architecture is the result of many years of evolution. Enclaves are good at minimising TCB size because that was their entire design goal: an enclave is intended to be the smallest piece of application logic that needs to be protected. Some other systems work by attempting to protect and attest an entire operating system stack, but this was tried in the past and found to work poorly. Let us now briefly trace the historical evolution that led to the SGX enclave design today. The first attempts at implementing trusted computing relied on a so-called trusted platform module chip (TPM). The TPM contained special registers called platform configuration registers (PCR). A PCR was sized to contain a hash, but could not be written directly. Instead writing to a PCR concatenated the new hash value with the prior, and stored the result of hashing that concatenation. PCRs therefore contained the final hash in a chain of hashes. The only way to get a PCR to a particular value is to feed it the right sequence of hashes, called the chain of trust . The firmware and electronics on the motherboard implemented a static root of trust . In this design, the initial boot ROM would load the BIOS and other firmware, hash it into a PCR and then pass control to it. The firmware would then in turn hash and load the next stage into the same PCR and so on. Thus by the time the system booted, all the software and firmware on the system had been hashed together. The contents of the PCR could then be remotely attested and the user could verify what software booted. This then let them reason about how the remote computer would behave. Given the explanations above the problem with this approach is hopefully now obvious - this approach defined the TCB as everything in the entire boot sequence, including the whole operating system kernel. Any bug at any point in this code would allow someone to create a forged chain of trust and undermine the system. But system firmware is already very large and likely to contain bugs, let alone a kernel. And even if the entire boot was secure the operating system or application server would likely contain bugs allowing in remote attackers anyway. On the open PC platform this system turned out to be too easy to defeat, and became abandoned outside of a few use cases involving disk encryption (with no remote attestation). Despite its failure in PCs, static roots of trust worked well enough for games consoles where the entire boot sequence could be encrypted, locked down, attested to multi-player game networks and very carefully audited by a vertically integrated systems manufacturer. The next attempt introduced a dynamic chain of trust via Intel TXT and AMD SVM. TXT/SVM provided so-called \"late launch\" in which a hypervisor can be started up and measured whilst the system is running. The hypervisor can then measure and boot an operating system, which may be a small and special purpose operating system. This approach also failed to gain much traction, as at the time building a small special purpose OS was too difficult (whereas nowadays open source unikernel operating systems are more easily available), and booting a regular Linux faced many of the same problems as with the static root of trust: too many places to hide back doors, too many bugs for the system to be truly trustworthy. This is how we arrived at SGX. An enclave runs in user-space and does not require a large piece of code like a hypervisor, kernel and system firmware to become a part of the remote attestation. Instead, only a small statically linked binary is loaded and protected. The code in the enclave can communicate with the host process by reading and writing from host memory. The TCB size is finally minimised to only what is strictly necessary - as long as your app is designed correctly.","title":"Confidential Computing"},{"location":"enclaves.html#confidential-computing","text":"When you send data to somebody else's computer they can ordinarily do whatever they like with it. Confidential Computing describes a set of hardware techniques that fix this problem. Confidential Computing makes it possible to know what algorithm will process your information before you send it to a third party, and to be assured that the third party cannot subvert the integrity of the algorithm or observe it while it works. Conclave makes it easy to write applications that utilise these capabilities. Conclave makes it possible to isolate a small piece of code from the rest of the computer on which it runs (an enclave ). Remote users can be shown what code is running in the isolated world and then upload their secret data to it, where it can be processed without the owner of the computer in question getting access. Enclaves can be used to protect private data from the cloud, do multi-party computations on shared datasets and make networks more secure. Intel SGX is an implementation of enclave-oriented computing. Conclave builds on SGX by making it easier to develop enclaves in high level languages like Java, Kotlin or JavaScript. In this document we'll introduce the key concepts of Confidential Computing and map them to the equivalent concepts in Conclave. The architecture document then pulls these concepts together to describe the end-to-end architecture of Conclave itself.","title":"Confidential Computing"},{"location":"enclaves.html#what-is-an-enclave","text":"An enclave is a region of memory which the CPU blocks access to, running inside an ordinary process which we call the host . The region contains both code and data, neither of which can be read or tampered with by anything else. Code executing inside this region has access to special CPU instructions that give it a variety of useful abilities. Enclave memory is protected both from the rest of the code in that process, privileged software like the kernel or BIOS, and because the RAM itself is encrypted even physical attackers. This means a remote computer can trust that an enclave will operate correctly even if the owner of the computer is malicious. In Conclave, an enclave is a subclass of the Enclave class, which is automatically combined by Conclave with an embedded JVM and compiled into a native shared library (ending in .so), and bundled into a JAR. The host program then uses the EnclaveHost class to load the enclave class from this JAR and automatically instantiate the enclave. Note Conclave compiles the enclave into a .so file because that's how the Intel SGX SDK expects the enclave to be built. Conclave hides this detail during the build phase by wrapping this file inside a Jar artifact, and during execution phase automatically loads the .so file from the classpath.","title":"What is an enclave?"},{"location":"enclaves.html#enclaves-and-hosts","text":"As described above, an enclave is loaded into an ordinary operating system process, which is known as the 'host'. All of the enclave's communicates with the outside world is via the host. To facilitate this, once an enclave is loaded, the host and enclave can exchange byte buffers back and forth. This is an efficient operation: the buffers are copied from the host into the enclave using a direct memory copy. Conclave provides convenient APIs to facilitate this data passing between enclave and host. However, it is important to note that, unlike the enclave, neither this 'host' process nor the underlying operating system are trusted by the users of the enclave. Yet the enclave depends on them. The following sections explain how message encryption, remote attestation, and the Conclave-specific 'Mail' API combine to solve this problem. Note In many ways, enclaves turn pre-existing security assumptions on their heads. In traditional programming, it is generally assumed that the operating system is trusted and that the primary threat is applications attacking the operating system, or each other. However, when using enclaves, this presumption is reversed: the user of the application, who is remote, does not trust the operator or operating system of the computer. Instead, they only trust the code running inside the enclave. Therefore, it is useful to imagine the operating system and the process that hosts the enclave as potential adversaries. Unfortunately, most existing software is built on the assumption that the operating system is not a threat . For this reason, it is usually best to avoid relying inside the enclave on code that was not explicitly written with this deployment mode in mind.","title":"Enclaves and Hosts"},{"location":"enclaves.html#encrypted-messages","text":"Enclaves are only useful if some other computer is interacting with them over the network. An enclave by itself doesn't gain you anything, because enclaves are defending against the owner of a computer. If you just run an enclave locally then the owner of the computer is you, and it doesn't make sense for software to try and protect your own data from yourself. So these remote users need to be able to encrypt messages with a key that is known only to the enclave. Enclaves can generate random numbers and thus encryption keys available only to themselves, which nothing else on the host machine can access. Using these keys remote computers can encrypt messages to the enclave. These messages can be passed into the enclave via the host where they are decrypted and worked on. The owner of the host computer can't read them, despite that the data is being processed on their hardware. Conclave calls these encrypted messages mails , by way of analogy to encrypted e-mail, but enclaves can work with encryption in whatever way they want. The Mail API is just a utility and you don't have to use it.","title":"Encrypted messages"},{"location":"enclaves.html#remote-attestation","text":"Encrypting a message requires a public key, which raises the question of where that key comes from. The clients of the enclave have to be convinced that the key really belongs to an enclave they want to work with and not, say, an unencrypted non-enclave program that's impersonating the intended destination. Enclave host programs can generate a small data structure called a remote attestation (RA). This structure, which is signed by a key controlled by the underlying hardware, states the following facts: A genuine, un-revoked Intel CPU is running ... ... an enclave into which a code module with a specific hash (measurement) was loaded ... ... and which has generated public key P ... ... and the computer is up to date with security patches, and configured in the recommended way. The host generates a remote attestation and sends it to clients in some way. Those clients can then send encrypted messages to the enclave using the public key P after checking what kind of enclave it really is. By recognising a list of known code hashes, or verifying that the enclave was signed by a party whom they trust, clients can effectively whitelist particular enclaves and treat them as trustworthy servers. In Conclave, a remote attestation is an instance of the EnclaveInstanceInfo class.","title":"Remote attestation"},{"location":"enclaves.html#applications-of-enclaves","text":"Enclaves are a very general capability and can be used in a variety of ways. You can: Process private data without being able to see it yourself, to enhance your user's privacy. Create a hardware-backed form of zero knowledge proofs: make trustworthy 'statements' that a particular computation was done on some data, without the data itself needing to be revealed. Outsource some kinds of computations to an untrusted cloud. Improve the security of a server by restricting access to a whitelist of client enclaves, blocking attempts to send malformed packets and messages that might come from hackers. Make your service auditable only by users who want high assurance - those who don't care can simply ignore the infrastructure entirely.","title":"Applications of Enclaves"},{"location":"enclaves.html#limitations-of-enclaves","text":"It's important to understand the limitations of enclaves. They aren't meant to be a general protection for arbitrary programs. Although technically possible to just relay operating system calls in and out of an enclave, this approach suffers from various security pitfalls and more importantly is a mis-understanding of the benefits enclaves give you. Confidential computing is based on two key insights: The more code that processes attacker-supplied data the more likely the program is to be hackable. A large chunk of most programs is actually just moving data around and managing it in various ways, not processing it. The software and hardware that must be uncompromised for a system to work correctly is called the trusted computing base , or TCB. In Conclave the TCB includes the CPU itself, the patchable microcode of the CPU, and all software running inside the enclave - both your code and the Conclave runtime. A major goal in secure systems design is to minimise the size of the TCB. This is for two reasons.","title":"Limitations of Enclaves"},{"location":"enclaves.html#security","text":"The software industry has decades of experience with building secure and tamperproof systems. A simple heuristic is that the more code there is inside the TCB that handles attacker-controlled data, the easier it will be for an adversary to find a mistake and break in. It's always been good design to minimise the amount of code that handles potentially malicious data and enclaves give you an even greater incentive to do so. That's because enclaves don't magically make the software inside them un-hackable. They protect the code and its memory from outside interference by the owner of the computer (and any hackers that gained access to the operating system) but if the code running inside the enclave has a bug that can be used to get in, those protections are of no use. Thus it's important for an enclave to be written securely. Conclave helps with this dramatically because it lets you write enclave logic in memory-safe, type-safe languages like Java or Kotlin. These languages eliminate by construction huge swathes of bugs. All buffer bounds are checked, no memory is freed before use and all casts are valid. This makes it much easier to process data from outside the enclave because you don't have to worry that you might accidentally let an attacker in. Sometimes people find this confusing: a JVM is quite large, so if the TCB needs to be small isn't that a problem? It's not for two reasons. One reason is because this heuristic only applies for code that an attacker can actually reach and influence via external input, but the input data to the JVM (bytecode) is itself a fixed part of the enclave. Attackers can't modify it without changing the measurement reported in the remote attestation and thus being detected by the client - the client's enclave constraint will be violated and an exception will be thrown. The second reason is that Conclave uses the GraalVM Native Image JVM, in which all bytecode is compiled to native code ahead of time. The actual JVM in use is therefore quite tiny; it consists mostly of the garbage collector. Warning Whilst garbage collected/type safe programs are much safer than programs written in C, they aren't immune to vulnerabilities. Watch out for very generic reflective code like object serialization frameworks, that could be tricked into deserializing malicious streams.","title":"Security"},{"location":"enclaves.html#auditability","text":"Enclaves are meaningless unless the user verifies the enclave does what they think it does before sending it private data. As the enclave size goes up it gets harder to read and understand its code. In practice audit work will often be outsourced: we don't expect that every end user of an enclave reads all the code themselves. Ultimately though, someone the user trusts must read all the code inside the enclave. The less there is to read the better. A lot of code works with data without parsing or understanding it. For instance, network frameworks read packets from the wire and databases store data to disk in generic ways. Other parts of a program truly understand the data and work with it in app-specific ways; usually this is called business logic. In enclave-oriented design you draw a bright line between host code and business logic. Business logic runs inside an enclave on normal Java objects. Host code does everything else: Network handling Storage Routing Monitoring Providing administration interfaces and so on. Keeping as much code in the host as possible has two key advantages: The host code is untrusted and assumed to be compromised. Thus any bugs in it are much less serious. You can worry less about security vulnerabilities in the host code because it can't access your user's private data. Because the enclave is small it will change less frequently, meaning clients don't need to re-audit or whitelist new versions. The second point is intuitive to understand. Think of your enclave as a concrete version of your privacy policy. If you change your web server, core database engine or even entire operating system then this is of no concern to your users. You've only changed how data is processed. But if you change what you do with their data, they may have an opinion on this and want to know about it. Remote attestation lets them see that the core business logic has changed, and in what way.","title":"Auditability"},{"location":"enclaves.html#summary","text":"In summary, an enclave is a small program which can run on an untrusted computer, where the operator of that computer cannot affect the integrity of the code nor observe the data that passes in or out. Through a process of 'remote attestation', remote clients can gain confidence that a specific program - or a program signed by a particular entity - is running, and that it is running in this secure mode on a fully patched machine. This makes it possible to deliver services that operate on third parties' data, where those third parties can be assured that their data cannot be used for any other purpose. Enclaves run inside untrusted host processes, and the combination of encryption, remote attestation and Conclave's purpose-designed APIs work together to make it as simple as possible for developers to write applications that work in this way.","title":"Summary"},{"location":"enclaves.html#additional-comments","text":"","title":"Additional Comments"},{"location":"enclaves.html#a-note-on-measurements-vs-signers","text":"The code hash included in a remote attestation is called a measurement . It's not the hash of any particular file but rather a more complex hash that must be calculated with special tools. It covers the entire module and all of its dependencies loaded into an enclave (a fat JAR). A measurement hash is pretty unhelpful by itself. It's just a large number. To be meaningful you must reproduce the measurement from the source code of the enclave. When you compile your enclave the measurement hash is calculated and printed. By comparing it to what you find inside a remote attestation, you can know the source code of the remote enclave matches what you have locally. Whitelisting measurements is strong but brittle. Any upgrade to the enclave will cause your app to reject the new remote attestation and stop working until you re-read the enclave's source code, reproduce the build again and whitelist the new measurement. An alternative is to whitelist a signing key instead. Enclave files must be signed, and the SGX infrastructure understands and verifies these signatures. This is useful for two reasons: You can choose to accept any enclave signed by a particular organisation, rather than reviewing the source code and reproducing the enclave yourself. Some SGX capable computers have a root key that must whitelist enclaves to be executed. This can be used by the owners of SGX-capable machines to retain visibility and control into what programs are actually running on their hardware. Whilst this capability could therefore be leveraged by cloud vendors to restrict which SGX workloads their servers will allow to run, we are not aware of any that operate in this way in practice. The hash of the public part of the key that signed an enclave is included in remote attestations, so you can choose to communicate with any enclave signed by a given key.","title":"A note on measurements vs signers"},{"location":"enclaves.html#enclaves-vs-alternative-approaches","text":"The enclave architecture is the result of many years of evolution. Enclaves are good at minimising TCB size because that was their entire design goal: an enclave is intended to be the smallest piece of application logic that needs to be protected. Some other systems work by attempting to protect and attest an entire operating system stack, but this was tried in the past and found to work poorly. Let us now briefly trace the historical evolution that led to the SGX enclave design today. The first attempts at implementing trusted computing relied on a so-called trusted platform module chip (TPM). The TPM contained special registers called platform configuration registers (PCR). A PCR was sized to contain a hash, but could not be written directly. Instead writing to a PCR concatenated the new hash value with the prior, and stored the result of hashing that concatenation. PCRs therefore contained the final hash in a chain of hashes. The only way to get a PCR to a particular value is to feed it the right sequence of hashes, called the chain of trust . The firmware and electronics on the motherboard implemented a static root of trust . In this design, the initial boot ROM would load the BIOS and other firmware, hash it into a PCR and then pass control to it. The firmware would then in turn hash and load the next stage into the same PCR and so on. Thus by the time the system booted, all the software and firmware on the system had been hashed together. The contents of the PCR could then be remotely attested and the user could verify what software booted. This then let them reason about how the remote computer would behave. Given the explanations above the problem with this approach is hopefully now obvious - this approach defined the TCB as everything in the entire boot sequence, including the whole operating system kernel. Any bug at any point in this code would allow someone to create a forged chain of trust and undermine the system. But system firmware is already very large and likely to contain bugs, let alone a kernel. And even if the entire boot was secure the operating system or application server would likely contain bugs allowing in remote attackers anyway. On the open PC platform this system turned out to be too easy to defeat, and became abandoned outside of a few use cases involving disk encryption (with no remote attestation). Despite its failure in PCs, static roots of trust worked well enough for games consoles where the entire boot sequence could be encrypted, locked down, attested to multi-player game networks and very carefully audited by a vertically integrated systems manufacturer. The next attempt introduced a dynamic chain of trust via Intel TXT and AMD SVM. TXT/SVM provided so-called \"late launch\" in which a hypervisor can be started up and measured whilst the system is running. The hypervisor can then measure and boot an operating system, which may be a small and special purpose operating system. This approach also failed to gain much traction, as at the time building a small special purpose OS was too difficult (whereas nowadays open source unikernel operating systems are more easily available), and booting a regular Linux faced many of the same problems as with the static root of trust: too many places to hide back doors, too many bugs for the system to be truly trustworthy. This is how we arrived at SGX. An enclave runs in user-space and does not require a large piece of code like a hypervisor, kernel and system firmware to become a part of the remote attestation. Instead, only a small statically linked binary is loaded and protected. The code in the enclave can communicate with the host process by reading and writing from host memory. The TCB size is finally minimised to only what is strictly necessary - as long as your app is designed correctly.","title":"Enclaves vs alternative approaches"},{"location":"faq.html","text":"Frequently asked questions \u00b6 Design/architecture questions \u00b6 What app architecture issues should we consider? \u00b6 We plan to offer more guidance on this in future. Until then consider: Dataset size. It must fit in memory in a single CPU machine. Slightly lower performance than usual. The extra security checks used by SGX reduce execution performance and the embedded JVM inside the enclave isn't as sophisticated as HotSpot, so peak performance will be lower than normal for Java. Client-side tooling. Enclaves are useless unless the end user of the service they provide is checking a remote attestation. Because web browsers know nothing about remote attestation you will have to provide an independent tool that verifies this as part of interacting with the service (note: trying to implement this in JavaScript to run in a browser won't work given the enclave security model, as the JavaScript would come from the same host you're trying to audit). You can read more about this below. What cryptographic algorithm(s) does Conclave support? \u00b6 The elliptic curve used is Curve25519 for encryption and Ed25519 for signing. The symmetric cipher is AES256/GCM. The hash function is SHA256. The Noise protocol is used to perform Diffie-Hellman key agreement and set up the ciphering keys. As these algorithms represent the state of the art and are widely deployed on the web, there are no plans to support other algorithms or curves at this time. Which communication channels exist to/from the enclave? \u00b6 The host can exchange local messages with the enclave, and an encryption key is included in the remote attestation. Clients can use this key transparently via Conclave Mail to communicate with the enclave in an encrypted manner. It's up to the host to route messages to and from the network. Conclave doesn't define any particular network protocol to use. Mails and serialized EnclaveInstanceInfo objects are just byte arrays, so you can send them using REST, gRPC, Corda flows, raw sockets, embed them inside some other protocol, use files etc. What is a confidential service? \u00b6 A confidential service is a service built using the principles of enclave-oriented design. Such services can keep their data secure and give end users hard guarantees about how their data will be used, guarantees that do not require the service provider to be trusted. In any confidential service there must be at least three parties: the service provider, the service consumer/end user, and an auditor. The auditor provides the link between a natural language specification of what the service is meant to do in a form understandable by the users and the actually executing code. Service providers and auditors are just roles and can be allocated amongst different people or groups in different ways. For example, in the simplest case the service's users are their own auditors. This requires the users to be comfortable reading source code, and to have the time and energy to audit new versions as they're released. Because that will rarely be the case it's more conventional to have third party auditors who perform this service for a fee. The output of the auditor can be one of: An enclave constraint (see the tutorial ) that specifies which enclaves are acceptable for use, and a description of what they do. Those constraints are then incorporated into clients or integrations by the users directly. A full download of a client app that has the constraint hard-coded into it. The advantage of the latter is that the client app is also audited, providing extra guarantees of security. If the client isn't checked or written by the service users themselves, then they have no real guarantee an enclave is even being used at all. It's also got better usability because users can simply download the client directly from the website of the auditors, thus establishing them as the root of trust. Obviously having the service provider be their own auditor doesn't make sense, although unfortunately we have seen a few enclave deployments in the wild that try to work this way! Such setups give the appearance of security without actually providing any. How should my confidential service UI be implemented and distributed? \u00b6 The primary constraint is that the provider of the client (the UI) and the provider of the hosting should be different. It must be so because the purpose of the enclave is protect secrets, and if the host also provides you with the user interface or client app then you don't even know the client is talking to the enclave in the first place. It may take the data when it's unencrypted (e.g. on your screen or disk) and simply send it elsewhere, encrypt it with a back door or break the protection of the system in many other ways. Fixing this depends on how you're using enclaves. If you're using it to defend against malicious datacenter operators/clouds then the client app must be distributed outside of those clouds. For example, providing the client app for download from the same server that hosts the enclave wouldn't make sense: a malicious host could just tamper with the client instead of the enclave. This constraint poses special difficulties when trying to implement a classical web or mobile-app based service with enclaves. On the web the client UI logic always comes from the same server it interacts with, and the user has no way to control what version of the HTML and JavaScript is downloaded. As web browsers don't understand enclave attestations you can't host a web server inside an enclave either (and it would be highly inefficient to do so). One way to solve this is to take the approach outlined in the previous question: make the user interface and client logic a totally separate artifact that can be downloaded directly from the auditors. The client then communicates with the host and through it the enclave using whatever protocol you like. Another way is to have the users download the client from the service provider but require it to be signed by the auditor. In practical terms this means you should be designing your client UI as a downloadable desktop or mobile app, not a web app. You should also consider who will play the role of auditor in your design early on. Can I write clients in languages other than Java? \u00b6 Yes, in three ways: You can use JNI to load a JVM and invoke the client library that way. You can run your client program on top of the JVM directly. Modern JVMs are capable of running many languages these days and giving them transparent Java interop, including languages you might not think of like C++, Rust, Ruby, Python, JavaScript, and so on. You can compile the client library to a standalone C library that exports a regular C API by using GraalVM native-image. This library can then be used directly (if writing in C/C++) or via your languages foreign function interface. The latter approach may be provided out of the box by Conclave in future. If your project needs such support please email us directly to ask about it. The amount of work involved isn't large. Will using Conclave require any agreements with Intel? \u00b6 Not if you use the latest generation of hardware. Modern chips support a feature called flexible launch control that allows the owner of the hardware to decide which enclaves can be loaded. For example, if you deploy to Microsoft Azure no agreement or interaction with Intel is needed: Azure allows any self-signed enclave. On older hardware that uses the EPID attestation protocol, to go live you'll need: A \"service provider ID\" that grants access to the Intel attestation servers . This is free. To sign a (very simple, one page) agreement that you won't sign malware. Intel will whitelist your signing key and Release Mode then becomes available. This is also free. Note Due to Conclave's design enclave clients don't need to interact with Intel at any point. The host does it and then publishes to clients a serialised EnclaveInstanceInfo object. The Conclave client libraries embed the necessary certificates to verify Intel's signature over this data, and the integrity of the object is checked automatically when it's deserialized. The developer doesn't have to do anything: it's all fully automated. How are upgrades performed when patches are released? \u00b6 There are several components which might need an upgrade when a vulnerability is found. It might involve updates to the Intel platform services software (a daemon and some libraries on the host Linux machine), the BIOS or UEFI versions and configuration, Conclave, or even the application code itself. Some of these updates might involve rebooting the system, which can cause downtime depending on the security requirements of each application. Conclave Mail is designed to be an asynchronous messaging system, so restarts to upgrade to new versions would be seen by clients as a latency spike rather than downtime. It might be possible to perform a rolling update, permitting applications to continue working on a potentially compromised system while the rollout is being performed. Stateless enclaves are easier to interchange, since no state needs to be transferred to other enclave instances. In the case of stateful enclaves, the possibility for doing state transfers depend on the application requirements, since data sealed on a system cannot be unsealed on a different system. Who and what will we be trusting exactly? \u00b6 You must trust the CPU vendor. However, you have to trust your CPU vendor to use computers in the first place, regardless of whether you're using SGX or not, thus this requirement doesn't actually change anything. It's well within the capabilities of CPU microcode to detect code patterns and create back doors or rewrite programs on the fly. A few minutes reflection will demonstrate that you would usually have no way to detect this , unless you can recruit some other CPU that isn't back doored to assist. You don't need to trust the hardware manufacturers other than the CPU vendor. RAM, disk, firmware, the operating system, PCI devices etc are all untrusted in the SGX threat model. Only the CPU itself needs to be correct for secrets to be protected. You don't need to trust the owner of the hardware on which your enclave is running. Verifying the remote attestation lets you check the remote system is fully up to date, and that the enclave is not running in debug mode i.e. that the memory really is encrypted. You don't have to trust R3 if you have a commercial relationship with us. We will allow audits of Conclave's source code to paying customers, so the full code inside the enclave can be verified directly. You must 'trust but verify' the source code of the enclave. Users of an enclave-backed service must either audit the source code of the enclave themselves to ensure it\u2019s \"behaving properly\" (i.e. not sending secrets to the host or other users), or they must outsource this task to a third party they trust to accurately summarise the enclave's behaviour for them. See the discussion of this in the questions above. Verifying the remote attestation ensures the source code matches the actual code running in the enclave. Your enclave may need a trusted authentication system if the business logic requires a notion of identified users. See below for more discussion. How should I authenticate users of my enclave? \u00b6 The service provider that runs the enclave cannot also be the account provider, as if they were they could just force a password reset operation - which your service presumably has to support if it's used by humans - and then the host could impersonate any user including all users. The protections offered by enclaves are of no use if the host can simply walk in through the front door. This can be fixed in several ways: Identify users by long term public keys and hard code lists of them. This is very simple but may have poor usability. Use cryptographic identity tied to an independent ID provider, like a certificate authority. This works particularly well if your users are institutions, as then you can use the Corda Network identity system . Talk to R3 for more details if you're interested in this. Use OAuth/OpenID and allow users to sign in via their Google, Office 365, LinkedIn, or corporate SAML accounts. This is the most sophisticated approach but also the hardest to implement. Conclave may offer pre-canned APIs for this in future. How long should we trust an attestation verification report? \u00b6 When a flaw in the system is found Intel performs a \"trusted computing base recovery\" operation. This involves releasing security updates and adjusting their servers to start reporting that old versions are known to be compromised. Thus you shouldn't accept a remote attestation for too long. Intel provides official guidance with some recommendations: For organizations with low risk tolerance (for example, banking), the attestation frequency policy might be once per day or once per week. Organizations with higher risk tolerance may define a frequency policy of once every 180 days. A typical frequency policy is once every 30 days. At the moment the developer is responsible for writing code that restarts the enclave from time to time. Restarting the enclave will force a re-attestation and thus make the EnclaveInstanceInfo fresh again. How often this happens should be synchronised between the host and client side tool (but remember to make the host server refresh more frequently than the client requires, to avoid synchronisation errors). Isn't putting a whole JVM into an enclave a bit fat? \u00b6 The so-called native images produced by Conclave don't include a traditional full JVM like HotSpot. All code is compiled ahead of time and dynamic classloading isn't possible, which gives a model more similar to that of Rust. The runtime aspects of the enclave are the garbage collector (which is certainly worth its weight in gold when lack of memory safety bugs is considered), and some small pieces of code for miscellaneous runtime tasks like the generation of stack traces. Keeping an enclave small is a good idea to reduce the chance of security critical bugs, but this logic mostly applies when writing code in unsafe languages like C, C++ or when using unsafe blocks in Rust. The runtime in Conclave enclaves exists mostly to prevent security bugs in the rest of the code, additionally, the runtime is itself written in Java meaning the same bounds checking and memory safety technologies that protect your code also protect the runtime. The lack of dynamic code loading (when using normal JVM bytecode) means even the runtime functions aren't exposed to attackers, so on balance we feel this is a clear security win. What about side-channel attacks? \u00b6 Please see the discussion of side channel attacks in the security documentation. Development and deployment \u00b6 What Java versions are usable? \u00b6 Please see System Requirements for documentation on supported JDKs. At which points in time is a connection with Intel needed? \u00b6 When using DCAP attestation (which requires the latest hardware), e.g. on Microsoft Azure, no direct connection to Intel is required. The cloud provider runs caching proxies in-cloud and Conclave uses them automatically. When using the older EPID attestation protocol a connection to Intel's servers will be made by the aesmd daemon and the host program when an enclave is loaded, as part of the startup sequence. See the information about machine setup to learn about firewall and proxy configuration. Can I print debug output to the console from my enclave? \u00b6 Conclave enclaves built for debug and simulation support output to the console from inside the enclave through the use of System.out.println() . Release builds of enclaves do not support printing to the console. Calling System.out.println() in release builds of enclaves is allowed but the output is discarded inside the enclave. This is to prevent accidental leakage of enclave state through the use of debug logging. Can I load more than one enclave at once? \u00b6 Yes, but each enclave must be a separate (Gradle) module. One module can only have one enclave entrypoint, but the same host can load multiple enclaves. On current hardware you may need to keep the enclaves small in order to avoid running out of fast EPC RAM, in which case the enclave memory will be 'swapped' in and out of EPC, at a considerable performance penalty. You can consider an alternative approach. Because of how Conclave Mail is designed, enclaves can message each other when offline. Therefore, it's possible to load one enclave, have it send a message to another enclave, unload it, load the second enclave and have it process the message from the first. Splitting up app logic in this way can be useful for allowing modules to be upgraded and audited independently. Why does my enclave build fail? \u00b6 We use the GraalVM native image technology. Builds can fail if you are trying to dynamically load bytecode (this doesn't work yet), if you use a feature not supported by our version of Native Image, or if you're on Windows/macOS and you don't allocate enough RAM to Docker. The build is memory intensive, so please allocate at least 6GB of RAM to Docker and possibly more. However you don't need to do builds all the time when working on an enclave. You always have the option of using mock mode to directly load the enclave code into the host JVM, which gives a regular Java development experience. Can you use Java object serialisation with Conclave? \u00b6 Yes, check our documentation on serialization configuration files on how to do so. How do I control the Native Image parameters? \u00b6 You can add flags to the native-image command line when building to optimise your enclave binary and control the details of how it's compiled. Create a file called src/main/resources/META-INF/native-image/native-image.properties in your enclave module and set it to contain: 1 Args = -H:Whatever Note This doesn't let you alter or override the flags we already specify in order to create a working enclave. How do I add resource files to Native Image enclaves? \u00b6 You can add resource files to the Native Image enclaves by setting the flag IncludeResources in the file src/main/resources/META-INF/native-image/native-image.properties . As an example, to add a file called trustedroot.cer to the enclave resources, one should add the following line to the file native-image.properties : 1 Args = -H:IncludeResources=trustedroot.cer Note To add multiple resource files please use a Java regular expression pattern that matches the resource files name to be included in the image. More information can be found in the GraalVM documentation . Competing technologies \u00b6 Do you have plans to support AMD SEV? \u00b6 Not at this time. We will re-evaluate future versions of SEV. The main problems are: AMD SEV is very strongly oriented around the protection of VMs in the cloud. Every protected domain has an owner that has full access to it. This makes it useless for multi-party computations where nobody should have access to the full state of the calculation. It has no equivalent of SGX TCB recovery, meaning flaws permanently break the system. Prior versions of SEV have been rendered useless by the discovery of numerous fatal bugs in AMD's firmware. Although patches were made available there was no way to remotely detect if they are actually applied, which made patching meaningless. Additionally, in SEV remote attestation is randomized which means you can\u2019t ask a remote host \"what are you running\". You are expected to know this already (because you set up the remote VM to begin with). This doesn't fit well with most obvious enclave APIs. AMD and Intel are in increasingly strong competition, and so we expect AMD to catch up with the SGX feature set in future. Intel are also working on an SEV-equivalent feature for protecting entire (Linux) virtual machines from the host hardware. Conclave may add support for this at some point in the future as well. Do you have plans to support ARM TrustZone? \u00b6 Not at this time. ARM TrustZone doesn't have any form of remote attestation support. It's meant for hardening mobile phone operating systems and supported use cases don't really go beyond that. ARM will likely enhance their CPUs to support remote attestation in future, and we will re-evaluate when such support ships. Do you have plans to support AWS/Nitro? \u00b6 Nitro is the name Amazon uses to refer to in-house security technology on their custom servers that restricts access by AWS employees. It's not an enclave and Amazon must still be assumed to have access to all your data, institutionally, because they design and implement Nitro, thus you have only their assurance that there are no back doors or internally known weaknesses and of course you must assume sufficiently privileged administrators can override Nitro if they need to. As it's not an enclave we currently have no plans to support Nitro. Do you have plans to support cloud providers as the root of trust? \u00b6 Although Nitro is not an enclave, some cloud providers do allow you to generate an attestation-like structure that asserts what disk image was used to boot a virtual machine. For cases where you're willing to trust a cloud provider but still want an auditable code module as part of your app, we may consider adding support for this in future. Why are you using Intel SGX versus mathematical techniques? \u00b6 Mathematically based secure multi-party computation and zero knowledge proofs are closely related and have similar tradeoffs/problems such as high complexity, low performance, difficult to use without intense dedicated training and not stable (i.e. the best known algorithms change frequently). SGX is relatively simple, high performance, much easier to use, and stable over time. However, we acknowledge the limits of relying on hardware based solutions and are interested in bringing easy to use circuit-based cryptographic algorithms to market one day.","title":"FAQ"},{"location":"faq.html#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"faq.html#designarchitecture-questions","text":"","title":"Design/architecture questions"},{"location":"faq.html#what-app-architecture-issues-should-we-consider","text":"We plan to offer more guidance on this in future. Until then consider: Dataset size. It must fit in memory in a single CPU machine. Slightly lower performance than usual. The extra security checks used by SGX reduce execution performance and the embedded JVM inside the enclave isn't as sophisticated as HotSpot, so peak performance will be lower than normal for Java. Client-side tooling. Enclaves are useless unless the end user of the service they provide is checking a remote attestation. Because web browsers know nothing about remote attestation you will have to provide an independent tool that verifies this as part of interacting with the service (note: trying to implement this in JavaScript to run in a browser won't work given the enclave security model, as the JavaScript would come from the same host you're trying to audit). You can read more about this below.","title":"What app architecture issues should we consider?"},{"location":"faq.html#what-cryptographic-algorithms-does-conclave-support","text":"The elliptic curve used is Curve25519 for encryption and Ed25519 for signing. The symmetric cipher is AES256/GCM. The hash function is SHA256. The Noise protocol is used to perform Diffie-Hellman key agreement and set up the ciphering keys. As these algorithms represent the state of the art and are widely deployed on the web, there are no plans to support other algorithms or curves at this time.","title":"What cryptographic algorithm(s) does Conclave support?"},{"location":"faq.html#which-communication-channels-exist-tofrom-the-enclave","text":"The host can exchange local messages with the enclave, and an encryption key is included in the remote attestation. Clients can use this key transparently via Conclave Mail to communicate with the enclave in an encrypted manner. It's up to the host to route messages to and from the network. Conclave doesn't define any particular network protocol to use. Mails and serialized EnclaveInstanceInfo objects are just byte arrays, so you can send them using REST, gRPC, Corda flows, raw sockets, embed them inside some other protocol, use files etc.","title":"Which communication channels exist to/from the enclave?"},{"location":"faq.html#what-is-a-confidential-service","text":"A confidential service is a service built using the principles of enclave-oriented design. Such services can keep their data secure and give end users hard guarantees about how their data will be used, guarantees that do not require the service provider to be trusted. In any confidential service there must be at least three parties: the service provider, the service consumer/end user, and an auditor. The auditor provides the link between a natural language specification of what the service is meant to do in a form understandable by the users and the actually executing code. Service providers and auditors are just roles and can be allocated amongst different people or groups in different ways. For example, in the simplest case the service's users are their own auditors. This requires the users to be comfortable reading source code, and to have the time and energy to audit new versions as they're released. Because that will rarely be the case it's more conventional to have third party auditors who perform this service for a fee. The output of the auditor can be one of: An enclave constraint (see the tutorial ) that specifies which enclaves are acceptable for use, and a description of what they do. Those constraints are then incorporated into clients or integrations by the users directly. A full download of a client app that has the constraint hard-coded into it. The advantage of the latter is that the client app is also audited, providing extra guarantees of security. If the client isn't checked or written by the service users themselves, then they have no real guarantee an enclave is even being used at all. It's also got better usability because users can simply download the client directly from the website of the auditors, thus establishing them as the root of trust. Obviously having the service provider be their own auditor doesn't make sense, although unfortunately we have seen a few enclave deployments in the wild that try to work this way! Such setups give the appearance of security without actually providing any.","title":"What is a confidential service?"},{"location":"faq.html#how-should-my-confidential-service-ui-be-implemented-and-distributed","text":"The primary constraint is that the provider of the client (the UI) and the provider of the hosting should be different. It must be so because the purpose of the enclave is protect secrets, and if the host also provides you with the user interface or client app then you don't even know the client is talking to the enclave in the first place. It may take the data when it's unencrypted (e.g. on your screen or disk) and simply send it elsewhere, encrypt it with a back door or break the protection of the system in many other ways. Fixing this depends on how you're using enclaves. If you're using it to defend against malicious datacenter operators/clouds then the client app must be distributed outside of those clouds. For example, providing the client app for download from the same server that hosts the enclave wouldn't make sense: a malicious host could just tamper with the client instead of the enclave. This constraint poses special difficulties when trying to implement a classical web or mobile-app based service with enclaves. On the web the client UI logic always comes from the same server it interacts with, and the user has no way to control what version of the HTML and JavaScript is downloaded. As web browsers don't understand enclave attestations you can't host a web server inside an enclave either (and it would be highly inefficient to do so). One way to solve this is to take the approach outlined in the previous question: make the user interface and client logic a totally separate artifact that can be downloaded directly from the auditors. The client then communicates with the host and through it the enclave using whatever protocol you like. Another way is to have the users download the client from the service provider but require it to be signed by the auditor. In practical terms this means you should be designing your client UI as a downloadable desktop or mobile app, not a web app. You should also consider who will play the role of auditor in your design early on.","title":"How should my confidential service UI be implemented and distributed?"},{"location":"faq.html#can-i-write-clients-in-languages-other-than-java","text":"Yes, in three ways: You can use JNI to load a JVM and invoke the client library that way. You can run your client program on top of the JVM directly. Modern JVMs are capable of running many languages these days and giving them transparent Java interop, including languages you might not think of like C++, Rust, Ruby, Python, JavaScript, and so on. You can compile the client library to a standalone C library that exports a regular C API by using GraalVM native-image. This library can then be used directly (if writing in C/C++) or via your languages foreign function interface. The latter approach may be provided out of the box by Conclave in future. If your project needs such support please email us directly to ask about it. The amount of work involved isn't large.","title":"Can I write clients in languages other than Java?"},{"location":"faq.html#will-using-conclave-require-any-agreements-with-intel","text":"Not if you use the latest generation of hardware. Modern chips support a feature called flexible launch control that allows the owner of the hardware to decide which enclaves can be loaded. For example, if you deploy to Microsoft Azure no agreement or interaction with Intel is needed: Azure allows any self-signed enclave. On older hardware that uses the EPID attestation protocol, to go live you'll need: A \"service provider ID\" that grants access to the Intel attestation servers . This is free. To sign a (very simple, one page) agreement that you won't sign malware. Intel will whitelist your signing key and Release Mode then becomes available. This is also free. Note Due to Conclave's design enclave clients don't need to interact with Intel at any point. The host does it and then publishes to clients a serialised EnclaveInstanceInfo object. The Conclave client libraries embed the necessary certificates to verify Intel's signature over this data, and the integrity of the object is checked automatically when it's deserialized. The developer doesn't have to do anything: it's all fully automated.","title":"Will using Conclave require any agreements with Intel?"},{"location":"faq.html#how-are-upgrades-performed-when-patches-are-released","text":"There are several components which might need an upgrade when a vulnerability is found. It might involve updates to the Intel platform services software (a daemon and some libraries on the host Linux machine), the BIOS or UEFI versions and configuration, Conclave, or even the application code itself. Some of these updates might involve rebooting the system, which can cause downtime depending on the security requirements of each application. Conclave Mail is designed to be an asynchronous messaging system, so restarts to upgrade to new versions would be seen by clients as a latency spike rather than downtime. It might be possible to perform a rolling update, permitting applications to continue working on a potentially compromised system while the rollout is being performed. Stateless enclaves are easier to interchange, since no state needs to be transferred to other enclave instances. In the case of stateful enclaves, the possibility for doing state transfers depend on the application requirements, since data sealed on a system cannot be unsealed on a different system.","title":"How are upgrades performed when patches are released?"},{"location":"faq.html#who-and-what-will-we-be-trusting-exactly","text":"You must trust the CPU vendor. However, you have to trust your CPU vendor to use computers in the first place, regardless of whether you're using SGX or not, thus this requirement doesn't actually change anything. It's well within the capabilities of CPU microcode to detect code patterns and create back doors or rewrite programs on the fly. A few minutes reflection will demonstrate that you would usually have no way to detect this , unless you can recruit some other CPU that isn't back doored to assist. You don't need to trust the hardware manufacturers other than the CPU vendor. RAM, disk, firmware, the operating system, PCI devices etc are all untrusted in the SGX threat model. Only the CPU itself needs to be correct for secrets to be protected. You don't need to trust the owner of the hardware on which your enclave is running. Verifying the remote attestation lets you check the remote system is fully up to date, and that the enclave is not running in debug mode i.e. that the memory really is encrypted. You don't have to trust R3 if you have a commercial relationship with us. We will allow audits of Conclave's source code to paying customers, so the full code inside the enclave can be verified directly. You must 'trust but verify' the source code of the enclave. Users of an enclave-backed service must either audit the source code of the enclave themselves to ensure it\u2019s \"behaving properly\" (i.e. not sending secrets to the host or other users), or they must outsource this task to a third party they trust to accurately summarise the enclave's behaviour for them. See the discussion of this in the questions above. Verifying the remote attestation ensures the source code matches the actual code running in the enclave. Your enclave may need a trusted authentication system if the business logic requires a notion of identified users. See below for more discussion.","title":"Who and what will we be trusting exactly?"},{"location":"faq.html#how-should-i-authenticate-users-of-my-enclave","text":"The service provider that runs the enclave cannot also be the account provider, as if they were they could just force a password reset operation - which your service presumably has to support if it's used by humans - and then the host could impersonate any user including all users. The protections offered by enclaves are of no use if the host can simply walk in through the front door. This can be fixed in several ways: Identify users by long term public keys and hard code lists of them. This is very simple but may have poor usability. Use cryptographic identity tied to an independent ID provider, like a certificate authority. This works particularly well if your users are institutions, as then you can use the Corda Network identity system . Talk to R3 for more details if you're interested in this. Use OAuth/OpenID and allow users to sign in via their Google, Office 365, LinkedIn, or corporate SAML accounts. This is the most sophisticated approach but also the hardest to implement. Conclave may offer pre-canned APIs for this in future.","title":"How should I authenticate users of my enclave?"},{"location":"faq.html#how-long-should-we-trust-an-attestation-verification-report","text":"When a flaw in the system is found Intel performs a \"trusted computing base recovery\" operation. This involves releasing security updates and adjusting their servers to start reporting that old versions are known to be compromised. Thus you shouldn't accept a remote attestation for too long. Intel provides official guidance with some recommendations: For organizations with low risk tolerance (for example, banking), the attestation frequency policy might be once per day or once per week. Organizations with higher risk tolerance may define a frequency policy of once every 180 days. A typical frequency policy is once every 30 days. At the moment the developer is responsible for writing code that restarts the enclave from time to time. Restarting the enclave will force a re-attestation and thus make the EnclaveInstanceInfo fresh again. How often this happens should be synchronised between the host and client side tool (but remember to make the host server refresh more frequently than the client requires, to avoid synchronisation errors).","title":"How long should we trust an attestation verification report?"},{"location":"faq.html#isnt-putting-a-whole-jvm-into-an-enclave-a-bit-fat","text":"The so-called native images produced by Conclave don't include a traditional full JVM like HotSpot. All code is compiled ahead of time and dynamic classloading isn't possible, which gives a model more similar to that of Rust. The runtime aspects of the enclave are the garbage collector (which is certainly worth its weight in gold when lack of memory safety bugs is considered), and some small pieces of code for miscellaneous runtime tasks like the generation of stack traces. Keeping an enclave small is a good idea to reduce the chance of security critical bugs, but this logic mostly applies when writing code in unsafe languages like C, C++ or when using unsafe blocks in Rust. The runtime in Conclave enclaves exists mostly to prevent security bugs in the rest of the code, additionally, the runtime is itself written in Java meaning the same bounds checking and memory safety technologies that protect your code also protect the runtime. The lack of dynamic code loading (when using normal JVM bytecode) means even the runtime functions aren't exposed to attackers, so on balance we feel this is a clear security win.","title":"Isn't putting a whole JVM into an enclave a bit fat?"},{"location":"faq.html#what-about-side-channel-attacks","text":"Please see the discussion of side channel attacks in the security documentation.","title":"What about side-channel attacks?"},{"location":"faq.html#development-and-deployment","text":"","title":"Development and deployment"},{"location":"faq.html#what-java-versions-are-usable","text":"Please see System Requirements for documentation on supported JDKs.","title":"What Java versions are usable?"},{"location":"faq.html#at-which-points-in-time-is-a-connection-with-intel-needed","text":"When using DCAP attestation (which requires the latest hardware), e.g. on Microsoft Azure, no direct connection to Intel is required. The cloud provider runs caching proxies in-cloud and Conclave uses them automatically. When using the older EPID attestation protocol a connection to Intel's servers will be made by the aesmd daemon and the host program when an enclave is loaded, as part of the startup sequence. See the information about machine setup to learn about firewall and proxy configuration.","title":"At which points in time is a connection with Intel needed?"},{"location":"faq.html#can-i-print-debug-output-to-the-console-from-my-enclave","text":"Conclave enclaves built for debug and simulation support output to the console from inside the enclave through the use of System.out.println() . Release builds of enclaves do not support printing to the console. Calling System.out.println() in release builds of enclaves is allowed but the output is discarded inside the enclave. This is to prevent accidental leakage of enclave state through the use of debug logging.","title":"Can I print debug output to the console from my enclave?"},{"location":"faq.html#can-i-load-more-than-one-enclave-at-once","text":"Yes, but each enclave must be a separate (Gradle) module. One module can only have one enclave entrypoint, but the same host can load multiple enclaves. On current hardware you may need to keep the enclaves small in order to avoid running out of fast EPC RAM, in which case the enclave memory will be 'swapped' in and out of EPC, at a considerable performance penalty. You can consider an alternative approach. Because of how Conclave Mail is designed, enclaves can message each other when offline. Therefore, it's possible to load one enclave, have it send a message to another enclave, unload it, load the second enclave and have it process the message from the first. Splitting up app logic in this way can be useful for allowing modules to be upgraded and audited independently.","title":"Can I load more than one enclave at once?"},{"location":"faq.html#why-does-my-enclave-build-fail","text":"We use the GraalVM native image technology. Builds can fail if you are trying to dynamically load bytecode (this doesn't work yet), if you use a feature not supported by our version of Native Image, or if you're on Windows/macOS and you don't allocate enough RAM to Docker. The build is memory intensive, so please allocate at least 6GB of RAM to Docker and possibly more. However you don't need to do builds all the time when working on an enclave. You always have the option of using mock mode to directly load the enclave code into the host JVM, which gives a regular Java development experience.","title":"Why does my enclave build fail?"},{"location":"faq.html#can-you-use-java-object-serialisation-with-conclave","text":"Yes, check our documentation on serialization configuration files on how to do so.","title":"Can you use Java object serialisation with Conclave?"},{"location":"faq.html#how-do-i-control-the-native-image-parameters","text":"You can add flags to the native-image command line when building to optimise your enclave binary and control the details of how it's compiled. Create a file called src/main/resources/META-INF/native-image/native-image.properties in your enclave module and set it to contain: 1 Args = -H:Whatever Note This doesn't let you alter or override the flags we already specify in order to create a working enclave.","title":"How do I control the Native Image parameters?"},{"location":"faq.html#how-do-i-add-resource-files-to-native-image-enclaves","text":"You can add resource files to the Native Image enclaves by setting the flag IncludeResources in the file src/main/resources/META-INF/native-image/native-image.properties . As an example, to add a file called trustedroot.cer to the enclave resources, one should add the following line to the file native-image.properties : 1 Args = -H:IncludeResources=trustedroot.cer Note To add multiple resource files please use a Java regular expression pattern that matches the resource files name to be included in the image. More information can be found in the GraalVM documentation .","title":"How do I add resource files to Native Image enclaves?"},{"location":"faq.html#competing-technologies","text":"","title":"Competing technologies"},{"location":"faq.html#do-you-have-plans-to-support-amd-sev","text":"Not at this time. We will re-evaluate future versions of SEV. The main problems are: AMD SEV is very strongly oriented around the protection of VMs in the cloud. Every protected domain has an owner that has full access to it. This makes it useless for multi-party computations where nobody should have access to the full state of the calculation. It has no equivalent of SGX TCB recovery, meaning flaws permanently break the system. Prior versions of SEV have been rendered useless by the discovery of numerous fatal bugs in AMD's firmware. Although patches were made available there was no way to remotely detect if they are actually applied, which made patching meaningless. Additionally, in SEV remote attestation is randomized which means you can\u2019t ask a remote host \"what are you running\". You are expected to know this already (because you set up the remote VM to begin with). This doesn't fit well with most obvious enclave APIs. AMD and Intel are in increasingly strong competition, and so we expect AMD to catch up with the SGX feature set in future. Intel are also working on an SEV-equivalent feature for protecting entire (Linux) virtual machines from the host hardware. Conclave may add support for this at some point in the future as well.","title":"Do you have plans to support AMD SEV?"},{"location":"faq.html#do-you-have-plans-to-support-arm-trustzone","text":"Not at this time. ARM TrustZone doesn't have any form of remote attestation support. It's meant for hardening mobile phone operating systems and supported use cases don't really go beyond that. ARM will likely enhance their CPUs to support remote attestation in future, and we will re-evaluate when such support ships.","title":"Do you have plans to support ARM TrustZone?"},{"location":"faq.html#do-you-have-plans-to-support-awsnitro","text":"Nitro is the name Amazon uses to refer to in-house security technology on their custom servers that restricts access by AWS employees. It's not an enclave and Amazon must still be assumed to have access to all your data, institutionally, because they design and implement Nitro, thus you have only their assurance that there are no back doors or internally known weaknesses and of course you must assume sufficiently privileged administrators can override Nitro if they need to. As it's not an enclave we currently have no plans to support Nitro.","title":"Do you have plans to support AWS/Nitro?"},{"location":"faq.html#do-you-have-plans-to-support-cloud-providers-as-the-root-of-trust","text":"Although Nitro is not an enclave, some cloud providers do allow you to generate an attestation-like structure that asserts what disk image was used to boot a virtual machine. For cases where you're willing to trust a cloud provider but still want an auditable code module as part of your app, we may consider adding support for this in future.","title":"Do you have plans to support cloud providers as the root of trust?"},{"location":"faq.html#why-are-you-using-intel-sgx-versus-mathematical-techniques","text":"Mathematically based secure multi-party computation and zero knowledge proofs are closely related and have similar tradeoffs/problems such as high complexity, low performance, difficult to use without intense dedicated training and not stable (i.e. the best known algorithms change frequently). SGX is relatively simple, high performance, much easier to use, and stable over time. However, we acknowledge the limits of relying on hardware based solutions and are interested in bringing easy to use circuit-based cryptographic algorithms to market one day.","title":"Why are you using Intel SGX versus mathematical techniques?"},{"location":"filesystem.html","text":"Files and storage \u00b6 Conclave enclaves can do file I/O but it's not mapped to the host filesystem. Instead, all filesystem activity is mapped to an in-memory file system. The goal of this support is to enable usage of libraries and applications that need to load data files from disk, to provide a simple 'scratch space' for files if you find them easier to work with, and to enable you to use file APIs to prepare data before it's encrypted for storage. How to store a file on the real disk \u00b6 If you have a byte stream you'd like to persist on the host, you must do this explicitly by using the mail-to-self pattern. Create a mail using the regular APIs as covered in the tutorial and send it with a routing hint like self or any other string that your host code will recognise as meaning \"this should be stored\". At startup the host can read the mails it saved on behalf of the enclave and deliver them. Your enclave can then deserialize and save the contents to an in-memory hashmap, or if you'd rather do the decoding later just stash the bytes in the in-memory file system. If the enclave acknowledges a mail, that tells the host to delete it. It's up to the host how to organise the actual files on disk. By keeping this logic outside the enclave the host/developers can change how storage works later, for instance, switching from local disk to S3 compatible blob storage, or using a database, or splitting files over multiple types of disk, doing replication etc. The attested logic won't change and no extra audit work will be generated. Why not direct mapping to the host? \u00b6 Some enclave platforms map file IO directly to the host file system. Conclave doesn't do this for these reasons: Data given to the host must be protected in various ways. It must be encrypted, authenticated and made robust against security patches that rotate keys . The enclave may want to verify it's been given the most recent stored data by the host, to block rewind attacks. Data may need to be padded to stop the host guessing what's inside it by looking at the message size. In more advanced scenarios you may want to store data in such a way that any enclave in a cluster can read it. All these features are provided already by the mail API, so it makes sense to re-use it. Sophisticated side channel attacks exist when the host can observe the pattern of accesses to a data store. With regular file IO, software outside your control (e.g. from libraries) may do reads, writes and seeks in patterns that leak important parts of the data. By receiving mails at startup and decrypting them into the in-memory file system you avoid exposing your file IO patterns to the host by exploiting the platform's built in protections for hiding memory access patterns. A common need for files is simply libraries that require them for configuration. In this case it makes sense to ship a pre-baked unencrypted filesystem as part of the enclave source code itself, where it can be audited and incorporated into the remote attestation. Log files are a common output of enclaves, but it doesn't make sense to seal them to the enclave itself. That would just slow things down for no reason. It makes more sense to buffer logs in memory and then from time to time either emit them straight to the host unencrypted, or send them somewhere else like the client that triggered the action that generated the logs, to a trusted administrator client, or even another enclave. Conclave's local calls and mail functionality make this easy. How to use \u00b6 A good way to use the file system is via the java.nio.file API. Here are some common tasks this API allows for: Getting InputStream and OutputStream objects for reading and writing as streams. Creating files, directories, moving files, renaming them etc. Getting a FileChannel that supports random access via the Files.newByteChannel API. Watching the filesystem for changes. Easily reading/writing text files from/to arrays of lines. Symbolic links are supported. Walking file trees are supported. Copying file trees in and out of zip files. The JavaDocs provide detailed explanations of how to do all these things, but if you're not sure where to start take a look at the Files class which has many convenient utility methods. It'll usually be easier to store structured data using conventional data structures, but if you want to you can also store data in these files. Because it's all in-memory, it'll be fast. Important Currently the old java.io.File API isn't fully wired up. In future releases all Java file APIs will be connected to the in-memory file system, along with native C-level stubs for POSIX APIs so native code can also benefit.","title":"File system"},{"location":"filesystem.html#files-and-storage","text":"Conclave enclaves can do file I/O but it's not mapped to the host filesystem. Instead, all filesystem activity is mapped to an in-memory file system. The goal of this support is to enable usage of libraries and applications that need to load data files from disk, to provide a simple 'scratch space' for files if you find them easier to work with, and to enable you to use file APIs to prepare data before it's encrypted for storage.","title":"Files and storage"},{"location":"filesystem.html#how-to-store-a-file-on-the-real-disk","text":"If you have a byte stream you'd like to persist on the host, you must do this explicitly by using the mail-to-self pattern. Create a mail using the regular APIs as covered in the tutorial and send it with a routing hint like self or any other string that your host code will recognise as meaning \"this should be stored\". At startup the host can read the mails it saved on behalf of the enclave and deliver them. Your enclave can then deserialize and save the contents to an in-memory hashmap, or if you'd rather do the decoding later just stash the bytes in the in-memory file system. If the enclave acknowledges a mail, that tells the host to delete it. It's up to the host how to organise the actual files on disk. By keeping this logic outside the enclave the host/developers can change how storage works later, for instance, switching from local disk to S3 compatible blob storage, or using a database, or splitting files over multiple types of disk, doing replication etc. The attested logic won't change and no extra audit work will be generated.","title":"How to store a file on the real disk"},{"location":"filesystem.html#why-not-direct-mapping-to-the-host","text":"Some enclave platforms map file IO directly to the host file system. Conclave doesn't do this for these reasons: Data given to the host must be protected in various ways. It must be encrypted, authenticated and made robust against security patches that rotate keys . The enclave may want to verify it's been given the most recent stored data by the host, to block rewind attacks. Data may need to be padded to stop the host guessing what's inside it by looking at the message size. In more advanced scenarios you may want to store data in such a way that any enclave in a cluster can read it. All these features are provided already by the mail API, so it makes sense to re-use it. Sophisticated side channel attacks exist when the host can observe the pattern of accesses to a data store. With regular file IO, software outside your control (e.g. from libraries) may do reads, writes and seeks in patterns that leak important parts of the data. By receiving mails at startup and decrypting them into the in-memory file system you avoid exposing your file IO patterns to the host by exploiting the platform's built in protections for hiding memory access patterns. A common need for files is simply libraries that require them for configuration. In this case it makes sense to ship a pre-baked unencrypted filesystem as part of the enclave source code itself, where it can be audited and incorporated into the remote attestation. Log files are a common output of enclaves, but it doesn't make sense to seal them to the enclave itself. That would just slow things down for no reason. It makes more sense to buffer logs in memory and then from time to time either emit them straight to the host unencrypted, or send them somewhere else like the client that triggered the action that generated the logs, to a trusted administrator client, or even another enclave. Conclave's local calls and mail functionality make this easy.","title":"Why not direct mapping to the host?"},{"location":"filesystem.html#how-to-use","text":"A good way to use the file system is via the java.nio.file API. Here are some common tasks this API allows for: Getting InputStream and OutputStream objects for reading and writing as streams. Creating files, directories, moving files, renaming them etc. Getting a FileChannel that supports random access via the Files.newByteChannel API. Watching the filesystem for changes. Easily reading/writing text files from/to arrays of lines. Symbolic links are supported. Walking file trees are supported. Copying file trees in and out of zip files. The JavaDocs provide detailed explanations of how to do all these things, but if you're not sure where to start take a look at the Files class which has many convenient utility methods. It'll usually be easier to store structured data using conventional data structures, but if you want to you can also store data in these files. Because it's all in-memory, it'll be fast. Important Currently the old java.io.File API isn't fully wired up. In future releases all Java file APIs will be connected to the in-memory file system, along with native C-level stubs for POSIX APIs so native code can also benefit.","title":"How to use"},{"location":"ias.html","text":"Intel Attestation Service \u00b6 Important You don't need to read and perform these steps to deploy a Conclave app, unless you wish to use older hardware that isn't capable of using the DCAP protocol. Azure Gen 2 Virtual Machines in particular do not need any of these steps. How do you know a remote computer is fully up to date with the latest security patches and isn't physically compromised? This is the question Intel's Attestation Service (IAS) exists to answer. IAS is an online service that evaluates evidence from an enclave and returns: The time at which the assessment was made Whether the system is considered secure or whether it needs: Software upgrades Operating system / microcode upgrades BIOS configuration changes The CVE IDs of any active security advisories against the remote system ... along with various other pieces of data. The response is signed by Intel. Because it's signed it can be hosted and passed around by anyone, thus when an enclave is started in debug or production mode IAS is contacted and an attestation calculated. It's a part of a serialized EnclaveInstanceInfo object and can be passed to clients from the server. This means clients don't need to contact Intel's servers themselves and thus don't need authorisation to use IAS. Getting access \u00b6 IAS requires an authorised key to access it. This is distinct from the enclave signing key. To obtain an IAS access key: Sign the commercial use agreement as part of getting a whitelisted enclave signing key . You can run your application in simulation or debug mode without this, but try to do it well in advance of when you will need to run in release mode, as the application process can be lengthy. Get an Intel developer zone account and sign in on the IAS API site . Subscribe to development and production access for \"EPID Name Base Mode (Linkable Quotes)\". Tip You should give Intel a group email address rather than an individual address, as these will be used to send you notification of security advisories affecting your system, so you know to upgrade and the timelines for TCB recovery . Once you have access, you should be able to see an SPID and Primary Key associated with your subscription. You can supply these to the enclave when it is started: 1 2 3 4 5 enclave . start ( new AttestationParameters . EPID ( OpaqueBytes . parse ( SPID ), PRIMARY_KEY ), ( commands ) -> { ... }); Important Ensure you have installed the kernel driver and system software on your machine before trying to use EPID attestation in debug or release mode.","title":"Self-Hosting"},{"location":"ias.html#intel-attestation-service","text":"Important You don't need to read and perform these steps to deploy a Conclave app, unless you wish to use older hardware that isn't capable of using the DCAP protocol. Azure Gen 2 Virtual Machines in particular do not need any of these steps. How do you know a remote computer is fully up to date with the latest security patches and isn't physically compromised? This is the question Intel's Attestation Service (IAS) exists to answer. IAS is an online service that evaluates evidence from an enclave and returns: The time at which the assessment was made Whether the system is considered secure or whether it needs: Software upgrades Operating system / microcode upgrades BIOS configuration changes The CVE IDs of any active security advisories against the remote system ... along with various other pieces of data. The response is signed by Intel. Because it's signed it can be hosted and passed around by anyone, thus when an enclave is started in debug or production mode IAS is contacted and an attestation calculated. It's a part of a serialized EnclaveInstanceInfo object and can be passed to clients from the server. This means clients don't need to contact Intel's servers themselves and thus don't need authorisation to use IAS.","title":"Intel Attestation Service"},{"location":"ias.html#getting-access","text":"IAS requires an authorised key to access it. This is distinct from the enclave signing key. To obtain an IAS access key: Sign the commercial use agreement as part of getting a whitelisted enclave signing key . You can run your application in simulation or debug mode without this, but try to do it well in advance of when you will need to run in release mode, as the application process can be lengthy. Get an Intel developer zone account and sign in on the IAS API site . Subscribe to development and production access for \"EPID Name Base Mode (Linkable Quotes)\". Tip You should give Intel a group email address rather than an individual address, as these will be used to send you notification of security advisories affecting your system, so you know to upgrade and the timelines for TCB recovery . Once you have access, you should be able to see an SPID and Primary Key associated with your subscription. You can supply these to the enclave when it is started: 1 2 3 4 5 enclave . start ( new AttestationParameters . EPID ( OpaqueBytes . parse ( SPID ), PRIMARY_KEY ), ( commands ) -> { ... }); Important Ensure you have installed the kernel driver and system software on your machine before trying to use EPID attestation in debug or release mode.","title":"Getting access"},{"location":"javascript.html","text":"Running JavaScript code inside an enclave \u00b6 When you use the graalvm-native-image runtime you have the option to enable JavaScript language support. When enabled you can create a context in which you can load and execute a JavaScript source module. This module can either run to completion and terminate or it can define a set of functions and variables that can subsequently be called and accessed from your Java enclave code. Modifying the sample enclave to use JavaScript \u00b6 The sample \"hello world\" enclave took us through a tutorial on how to write an enclave that takes a string, reverses it and returns it via the host to the client. In this section we will take the code from the sample and modify it to reverse the string using JavaScript to replace the existing Java reverse() function. Make sure you've already run through the tutorial and have a working sample application as a starting point. Enable JavaScript in the conclave configuration \u00b6 Enabling JavaScript support in an enclave requires pulling in a number of dependencies that result in a larger enclave size. Therefore, JavaScript is not enabled by default. In order to enable support add the following line to your enclave build.gradle . 1 2 3 4 5 conclave { productID = 1 revocationLevel = 0 supportLanguages = \"js\" } See here more details on enclave configuration . Import the GraalVM SDK classes \u00b6 We need to use the GraalVM SDK to build a context in which to run the JavaScript code. The dependency to the SDK is automatically added when you specify supportLanguages = \"js\" so you just need to add the following import statements to ReverseEnclave.java : 1 2 3 4 import com.r3.conclave.enclave.Enclave ; import com.r3.conclave.mail.EnclaveMail ; import org.graalvm.polyglot.Context ; import org.graalvm.polyglot.Value ; Parse the JavaScript code and set up bindings to Java \u00b6 The next step is to define and parse our JavaScript code. Once we have done this we can setup the bindings to Java which allow us to access the functions and variables that are defined within the JavaScript code. Add a constructor that prepares the JavaScript context: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // We store the previous result to showcase that the enclave internals can be examined in a mock test. byte [] previousResult ; private final Value bindings ; private static final String jsCode = \"function reverse(input) {\" + \" var split = input.split('');\" + \" var reverse = split.reverse();\" + \" return reverse.join('');\" + \"}\" ; public ReverseEnclave () { Context context = Context . create ( \"js\" ); bindings = context . getBindings ( \"js\" ); context . eval ( \"js\" , jsCode ); } @Override protected void receiveMail ( long id , EnclaveMail mail , String routingHint ) { Replace the Java function with a call to the JavaScript function \u00b6 Remove the Java code that reverses the string and replace it with the following function. Note that static has been removed from the function declaration because it now accesses the bindings member variable. 1 2 3 4 5 6 7 8 9 10 return result ; } private String reverse ( String input ) { Value result = bindings . getMember ( \"reverse\" ). execute ( input ); return result . asString (); } @Override protected void receiveMail ( long id , EnclaveMail mail , String routingHint ) { Finally, run the sample code as described in the tutorial. The result should be the same: the string passed as an argument to the client is reversed and returned to the client. More information \u00b6 Conclave support for JavaScript is provided by the polyglot capabilities in GraalVM. Refer to the GraalVM documentation on embedding languages for detailed instructions on how to use this capability.","title":"JavaScript"},{"location":"javascript.html#running-javascript-code-inside-an-enclave","text":"When you use the graalvm-native-image runtime you have the option to enable JavaScript language support. When enabled you can create a context in which you can load and execute a JavaScript source module. This module can either run to completion and terminate or it can define a set of functions and variables that can subsequently be called and accessed from your Java enclave code.","title":"Running JavaScript code inside an enclave"},{"location":"javascript.html#modifying-the-sample-enclave-to-use-javascript","text":"The sample \"hello world\" enclave took us through a tutorial on how to write an enclave that takes a string, reverses it and returns it via the host to the client. In this section we will take the code from the sample and modify it to reverse the string using JavaScript to replace the existing Java reverse() function. Make sure you've already run through the tutorial and have a working sample application as a starting point.","title":"Modifying the sample enclave to use JavaScript"},{"location":"javascript.html#enable-javascript-in-the-conclave-configuration","text":"Enabling JavaScript support in an enclave requires pulling in a number of dependencies that result in a larger enclave size. Therefore, JavaScript is not enabled by default. In order to enable support add the following line to your enclave build.gradle . 1 2 3 4 5 conclave { productID = 1 revocationLevel = 0 supportLanguages = \"js\" } See here more details on enclave configuration .","title":"Enable JavaScript in the conclave configuration"},{"location":"javascript.html#import-the-graalvm-sdk-classes","text":"We need to use the GraalVM SDK to build a context in which to run the JavaScript code. The dependency to the SDK is automatically added when you specify supportLanguages = \"js\" so you just need to add the following import statements to ReverseEnclave.java : 1 2 3 4 import com.r3.conclave.enclave.Enclave ; import com.r3.conclave.mail.EnclaveMail ; import org.graalvm.polyglot.Context ; import org.graalvm.polyglot.Value ;","title":"Import the GraalVM SDK classes"},{"location":"javascript.html#parse-the-javascript-code-and-set-up-bindings-to-java","text":"The next step is to define and parse our JavaScript code. Once we have done this we can setup the bindings to Java which allow us to access the functions and variables that are defined within the JavaScript code. Add a constructor that prepares the JavaScript context: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // We store the previous result to showcase that the enclave internals can be examined in a mock test. byte [] previousResult ; private final Value bindings ; private static final String jsCode = \"function reverse(input) {\" + \" var split = input.split('');\" + \" var reverse = split.reverse();\" + \" return reverse.join('');\" + \"}\" ; public ReverseEnclave () { Context context = Context . create ( \"js\" ); bindings = context . getBindings ( \"js\" ); context . eval ( \"js\" , jsCode ); } @Override protected void receiveMail ( long id , EnclaveMail mail , String routingHint ) {","title":"Parse the JavaScript code and set up bindings to Java"},{"location":"javascript.html#replace-the-java-function-with-a-call-to-the-javascript-function","text":"Remove the Java code that reverses the string and replace it with the following function. Note that static has been removed from the function declaration because it now accesses the bindings member variable. 1 2 3 4 5 6 7 8 9 10 return result ; } private String reverse ( String input ) { Value result = bindings . getMember ( \"reverse\" ). execute ( input ); return result . asString (); } @Override protected void receiveMail ( long id , EnclaveMail mail , String routingHint ) { Finally, run the sample code as described in the tutorial. The result should be the same: the string passed as an argument to the client is reversed and returned to the client.","title":"Replace the Java function with a call to the JavaScript function"},{"location":"javascript.html#more-information","text":"Conclave support for JavaScript is provided by the polyglot capabilities in GraalVM. Refer to the GraalVM documentation on embedding languages for detailed instructions on how to use this capability.","title":"More information"},{"location":"known-issues.html","text":"Known issues \u00b6 The Conclave API is by now mostly stable, but small changes may still occur. In particular we may adjust mail to support streaming access. You should expect to spend a few minutes updating your code between releases, but not more. This release ships with the following known issues that we plan to address in future versions: Some system level exceptions like divide by zero or using null reference may crash the enclave/host process. Opening network sockets doesn't work. We plan to support opening outbound sockets in future, but running socket based servers inside an enclave is probably not the best way to use enclave technology. Please read about mail to learn how to send messages to and from an enclave. Mail is limited in size by the size of the enclave heap, and the size of a Java array (2 gigabytes). Enclaves built using Conclave currently do not have a stable measurement, meaning that each time you build your enclave you will end up with a different MRSIGNER value. JavaDocs don't integrate with IntelliJ properly. This is due to a bug in IntelliJ when loading modules from on disk repositories.","title":"Known issues"},{"location":"known-issues.html#known-issues","text":"The Conclave API is by now mostly stable, but small changes may still occur. In particular we may adjust mail to support streaming access. You should expect to spend a few minutes updating your code between releases, but not more. This release ships with the following known issues that we plan to address in future versions: Some system level exceptions like divide by zero or using null reference may crash the enclave/host process. Opening network sockets doesn't work. We plan to support opening outbound sockets in future, but running socket based servers inside an enclave is probably not the best way to use enclave technology. Please read about mail to learn how to send messages to and from an enclave. Mail is limited in size by the size of the enclave heap, and the size of a Java array (2 gigabytes). Enclaves built using Conclave currently do not have a stable measurement, meaning that each time you build your enclave you will end up with a different MRSIGNER value. JavaDocs don't integrate with IntelliJ properly. This is due to a bug in IntelliJ when loading modules from on disk repositories.","title":"Known issues"},{"location":"machine-setup.html","text":"Machine setup \u00b6 So. There's an easy way to do this, and a hard way. The easy way \u00b6 Requisition a Microsoft Azure Gen 2 VM . Upload your Java app to it and run it, as if it were any other Java app. There is no step 3! When using Azure everything is fully automatic. The harder way \u00b6 To deploy an enclave using real SGX hardware you need to configure the host system, and if your hardware does not support DCAP attestation also get access to the Intel Attestation Service (IAS) . At this time the host must be Linux and requires the following steps: Installing the SGX kernel driver, which isn't yet included in upstream kernels. Installing the Intel platform services software. Follow the instructions at the IAS website to get access to the IAS servers using a whitelisted SSL key. Note To just develop enclaves it's sufficient to have any Linux or Windows host, as the simulation mode requires no special machine setup. However, Intel requires that the CPU must at least support SSE4.1 . Hardware support \u00b6 The machine needs support from both the CPU and firmware. At this time multi-socket boards don't support SGX. Your hardware manufacturer can tell you if your machine supports SGX, but most new computers do (one exception is anything made by Apple). There is a community maintained list of tested/compatible hardware available on GitHub . For some machines SGX must be explicitly enabled in the BIOS/UEFI firmware screens. For others it can be activated by any root user: the Conclave host API will try to activate it for you, if possible and if run with sufficient permissions. Hosting providers \u00b6 Microsoft Azure offers virtual machines with SGX hardware OVH offers rentable SGX hardware Distribution support \u00b6 The following Linux distros are formally supported by Intel: Ubuntu 16.04 LTS Desktop 64bits Ubuntu 16.04 LTS Server 64bits Ubuntu 18.04 LTS Desktop 64bits Ubuntu 18.04 LTS Server 64bits Ubuntu 20.04 LTS Desktop 64bits Ubuntu 20.04 LTS Server 64bits Red Hat Enterprise Linux Server release 7.6 64bits Red Hat Enterprise Linux Server release 8.2 64bits CentOS 8.2 64bits Fedora 31 Server 64bits However, others will probably still work. Install the kernel driver and system software \u00b6 Installers for the system software can be obtained from Intel . We recommend reading the installation user guide . The installation process is simple. Intel provides: APT repositories for Ubuntu Cross-distro installer binaries for other platforms, which set up the system software and compile/install the kernel driver. Important The installer will need to be re-run when the kernel is upgraded. Alternatively, you can compile the system software yourself. The kernel driver is also available on GitHub . For SGX remote attestation to operate and machine provisioning to succeed, a small daemon called aesmd is used. This comes as part of the SGX platform services software and will be set up during the install process. The quick summary looks like this: Download and run the driver installer binary (all distros) For Ubuntu users, as root run: For Ubuntu 16 LTS: echo 'deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu xenial main' > /etc/apt/sources.list.d/intelsgx.list For Ubuntu 18 LTS: echo 'deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu bionic main' > /etc/apt/sources.list.d/intelsgx.list For Ubuntu 20 LTS: echo 'deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu focal main' > /etc/apt/sources.list.d/intelsgx.list Add the Intel package signing key: wget -qO - https://download.01.org/intel-sgx/sgx_repo/ubuntu/intel-sgx-deb.key | apt-key add - Then run apt-get update And finally apt-get install libssl-dev libcurl4-openssl-dev libprotobuf-dev libsgx-urts libsgx-launch libsgx-epid libsgx-quote-ex For other users, use the SDK installer (which installs the platform services software as well) These steps will start the aesm_service . Limited network connectivity \u00b6 The enclave host machine needs to contact Intel's attestation servers, as part of proving to third parties that it's a genuine unrevoked CPU running in the latest known secure configuration. Therefore if the machine has limited connectivity you must use an outbound HTTP[S] proxy server. The aesmd service has a configuration file in /etc/aesmd.conf . You may need to put your proxy settings there. The program that uses Conclave will also need to make web requests to https://api.trustedservices.intel.com so you may need to provide Java with HTTP proxy settings as well. Using containers \u00b6 To configure Docker for use with SGX, you must pass at least these flags when creating the container: --device=/dev/isgx -v /var/run/aesmd/aesm.socket:/var/run/aesmd/aesm.socket Failure to do this may result in an SGX_ERROR_NO_DEVICE error when creating an enclave. Renewing machine security \u00b6 After following the above instructions, you may discover your EnclaveInstanceInfo objects report the enclave as STALE . This means the machine requires software updates. Applying all available updates and rebooting should make the security evaluation of STALE go away. See \"Renewability\" to learn more about this topic and what exactly is involved.","title":"Overview"},{"location":"machine-setup.html#machine-setup","text":"So. There's an easy way to do this, and a hard way.","title":"Machine setup"},{"location":"machine-setup.html#the-easy-way","text":"Requisition a Microsoft Azure Gen 2 VM . Upload your Java app to it and run it, as if it were any other Java app. There is no step 3! When using Azure everything is fully automatic.","title":"The easy way"},{"location":"machine-setup.html#the-harder-way","text":"To deploy an enclave using real SGX hardware you need to configure the host system, and if your hardware does not support DCAP attestation also get access to the Intel Attestation Service (IAS) . At this time the host must be Linux and requires the following steps: Installing the SGX kernel driver, which isn't yet included in upstream kernels. Installing the Intel platform services software. Follow the instructions at the IAS website to get access to the IAS servers using a whitelisted SSL key. Note To just develop enclaves it's sufficient to have any Linux or Windows host, as the simulation mode requires no special machine setup. However, Intel requires that the CPU must at least support SSE4.1 .","title":"The harder way"},{"location":"machine-setup.html#hardware-support","text":"The machine needs support from both the CPU and firmware. At this time multi-socket boards don't support SGX. Your hardware manufacturer can tell you if your machine supports SGX, but most new computers do (one exception is anything made by Apple). There is a community maintained list of tested/compatible hardware available on GitHub . For some machines SGX must be explicitly enabled in the BIOS/UEFI firmware screens. For others it can be activated by any root user: the Conclave host API will try to activate it for you, if possible and if run with sufficient permissions.","title":"Hardware support"},{"location":"machine-setup.html#hosting-providers","text":"Microsoft Azure offers virtual machines with SGX hardware OVH offers rentable SGX hardware","title":"Hosting providers"},{"location":"machine-setup.html#distribution-support","text":"The following Linux distros are formally supported by Intel: Ubuntu 16.04 LTS Desktop 64bits Ubuntu 16.04 LTS Server 64bits Ubuntu 18.04 LTS Desktop 64bits Ubuntu 18.04 LTS Server 64bits Ubuntu 20.04 LTS Desktop 64bits Ubuntu 20.04 LTS Server 64bits Red Hat Enterprise Linux Server release 7.6 64bits Red Hat Enterprise Linux Server release 8.2 64bits CentOS 8.2 64bits Fedora 31 Server 64bits However, others will probably still work.","title":"Distribution support"},{"location":"machine-setup.html#install-the-kernel-driver-and-system-software","text":"Installers for the system software can be obtained from Intel . We recommend reading the installation user guide . The installation process is simple. Intel provides: APT repositories for Ubuntu Cross-distro installer binaries for other platforms, which set up the system software and compile/install the kernel driver. Important The installer will need to be re-run when the kernel is upgraded. Alternatively, you can compile the system software yourself. The kernel driver is also available on GitHub . For SGX remote attestation to operate and machine provisioning to succeed, a small daemon called aesmd is used. This comes as part of the SGX platform services software and will be set up during the install process. The quick summary looks like this: Download and run the driver installer binary (all distros) For Ubuntu users, as root run: For Ubuntu 16 LTS: echo 'deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu xenial main' > /etc/apt/sources.list.d/intelsgx.list For Ubuntu 18 LTS: echo 'deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu bionic main' > /etc/apt/sources.list.d/intelsgx.list For Ubuntu 20 LTS: echo 'deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu focal main' > /etc/apt/sources.list.d/intelsgx.list Add the Intel package signing key: wget -qO - https://download.01.org/intel-sgx/sgx_repo/ubuntu/intel-sgx-deb.key | apt-key add - Then run apt-get update And finally apt-get install libssl-dev libcurl4-openssl-dev libprotobuf-dev libsgx-urts libsgx-launch libsgx-epid libsgx-quote-ex For other users, use the SDK installer (which installs the platform services software as well) These steps will start the aesm_service .","title":"Install the kernel driver and system software"},{"location":"machine-setup.html#limited-network-connectivity","text":"The enclave host machine needs to contact Intel's attestation servers, as part of proving to third parties that it's a genuine unrevoked CPU running in the latest known secure configuration. Therefore if the machine has limited connectivity you must use an outbound HTTP[S] proxy server. The aesmd service has a configuration file in /etc/aesmd.conf . You may need to put your proxy settings there. The program that uses Conclave will also need to make web requests to https://api.trustedservices.intel.com so you may need to provide Java with HTTP proxy settings as well.","title":"Limited network connectivity"},{"location":"machine-setup.html#using-containers","text":"To configure Docker for use with SGX, you must pass at least these flags when creating the container: --device=/dev/isgx -v /var/run/aesmd/aesm.socket:/var/run/aesmd/aesm.socket Failure to do this may result in an SGX_ERROR_NO_DEVICE error when creating an enclave.","title":"Using containers"},{"location":"machine-setup.html#renewing-machine-security","text":"After following the above instructions, you may discover your EnclaveInstanceInfo objects report the enclave as STALE . This means the machine requires software updates. Applying all available updates and rebooting should make the security evaluation of STALE go away. See \"Renewability\" to learn more about this topic and what exactly is involved.","title":"Renewing machine security"},{"location":"mail.html","text":"Mail \u00b6 A mail is an authenticated byte array with an encrypted body and a cleartext envelope. The mail can be up to two gigabytes in size, however, it must at this time fit into memory when loaded all at once. In practice mails will usually be much smaller than that. Conclave Mail unifies messaging and data storage. It provides a variety of features that are useful when building applications: Encryption. The encryption key used by the enclave is private to that enclave but stable across restarts and enclave upgrades. This means messages encrypted and delivered by older clients can still be decrypted. The format uses the respected Noise protocol framework (with AES/GCM and SHA-256), which is the same cryptographic framework used by WhatsApp, the Linux kernel WireGuard protocol and I2P. Authentication. Mail allows a message to prove it came from the owner of a particular key, as well as being encrypted to a destination public key. Because of this it's easy to encrypt a reply to the sender, although how a public key is mapped to a physical computer is up to the app developer. This capability is useful for another reason: if an enclave has a notion of a user identifiable by public key, mail can be cryptographically authenticated as having come from that user. This avoids the need for complex user login processes: the login process can be handled outside of the enclave, without compromising security. The envelope is protected this way along with the encrypted body. Headers. Mail has unencrypted but authenticated (tamperproof) headers that can be used to link messages together. This allows clients to structure a conversation as if they were using a socket, but also hold multiple conversations simultaneously. This can be used to implement usage tracking, prioritisation, or other tasks not directly relevant to data processing that the host can assist with (despite its untrusted nature). Headers provide strong sequence numbers that are set by the sender and prevent the host re-ordering messages, a \"topic\" string field that is more useful than a port number (e.g. can identify what it's about, be mapped to message queue names), and applications can put their own data in the envelope part of the headers thus enabling hosts to see part of the messages. This can frequently be a useful design pattern. The headers are described in more detail in the tutorial . Framing. A typical need with any socket or stream based transport is to add framing on top, because the application really needs to work with messages. In textual protocols framing can be remarkably tricky to get right, as user or attacker controlled data may be placed inside a message, meaning any characters that mark the end of a message need to be escaped. This can go wrong in a variety of interesting ways . Mail by its nature delimits messages such that you can always tell where they begin and end, without needing to impose your own framing on top. Future features \u00b6 We plan to add additional features to the mail API in upcoming releases: Storage. Mail will be stored by the host process. Often an enclave is implementing a form of batch job. By allowing the host to handle storage of messages, mail allows it to delay starting the enclave until enough data has arrived. This in turn allows the host to best utilise the limited pool of encrypted RAM available for enclaves. Atomicity. Mail should be delivered by the host to an enclave on each startup, until the mail is acknowledged. Acknowledgement and posting mail will become transactional, thus can be performed atomically with other acknowledgements and sending other replies. In this way enclaves can ensure that restarting an enclave doesn't produce duplicate messages, perform the same actions twice or cause service interruptions to users. Notice More sophisticated database solutions may be added in future releases. Using mail for storage \u00b6 Mail is not only intended for messaging. It subsumes the \"sealing\" functionality that appears in most trusted computing platforms. By sending mail to itself an enclave can store chunks of data that will be fed back to it at startup. It can then delete these chunks by acknowledging the mails. Utilising mail this way has a variety of advantages: The same encryption, authentication and trusted computing base (TCB) management features are available for stored data as well as messaging. The API is simple and used the same way for both use cases. Mail acknowledgement can be used to control data lifetime, by having enclaves signal to the host that it's safe to delete data which is no longer needed. Stored data typically comes from input data (i.e. messages) and may be stored incrementally. Sequence numbers and topics provide a way to organise stored data that can be integrated with the client's view of time, thus allowing rollback attacks on storage to be detected and blocked in some cases. This isn't a replacement for a full database. However, in many cases it may be more appropriate, as accessing a database from an enclave can leak a lot of data via access patterns and of course the database itself may need access to the unencrypted data to index or search it. The mail-to-self pattern avoids this by storing the dataset in memory and always reading all stored data at startup. Note Currently storage management is delegated to the application. The enclave may signal acknowledgement requests to the host but by default nothing is done with them. Attacks on messaging \u00b6 Mail is designed to block a variety of attacks the host can mount on the enclave. Observation. The body of the mail is encrypted with industry standard AES/GCM. The host can't see what the client is sending to the enclave. Tampering. All the encrypted body, the plaintext headers and the user-specifiable envelope header are authenticated such that the enclave can detect if they were tampered with. See below for more information on this. Reordering. The enclave can't directly access any hardware other than the CPU and RAM. That means it can't know that messages came from the network card or hard disk in the right order, or that no messages were dropped. Mails include a sequence number and topic in the headers, meaning it is visible to the host but can't be tampered with. This enlists the client as an ally in the enclave's war against the host: the client wants its messages to be delivered in the right order and without being dropped. The Conclave runtime checks the sequence numbers in the headers always increment, on a per-topic basis, before passing the mail to your code. Note The host may arbitrarily delay or even refuse to deliver mail, but it can only end the stream of mails early, it can't re-order messages relative to each other. This is a feature not a bug, as if the enclave could force the host to deliver mail that would imply it had actually taken over the computer somehow and was forcing it to provide services to the enclave. SGX isn't a form of remote control and nobody can force a host to run enclaves against its will. Size side channels. Simply knowing how big a message is can be surprisingly powerful . Mail is automatically padded by Conclave to give messages a uniform size. This blocks attempts to infer the contents of the message based on the precise size. By default Mail uses a moving average but the policy is configurable and so if you know a reasonable upper limit on the size of your messages, you can pad every message to be that size. The host will be blinded and have to try and infer what's going on just from message timing. You can fix that by sending empty mails even when you have nothing to say. For example, if an enclave is running some sort of auction or competition between users and you wish to hide who won, the enclave can simply send a \"you won\" or \"you lost\" message to every client. Even if the winner needs additional data the padding will ensure the host can't tell which client won. How does Mail work \u00b6 When viewed as a structured array of bytes, a mail consists of five parts: The protocol ID. The unencrypted headers, which have fields simply laid out in order. The unencrypted envelope, which is empty by default and exists for you to add whatever data you like (i.e. additional headers). The handshake. The encrypted body. Let's call the protocol ID, unencrypted headers and envelope the prologue . At the core of Mail's security is the handshake. It consists of the data needed to do an elliptic curve Diffie-Hellman calculation and derive a unique (per mail) AES/GCM key, using the Noise protocol specification . AES/GCM is an authenticated encryption mechanism. That means the key is used not only to encrypt data, but also calculate a special hash called a \"tag\" that allows detection of modifications to the encrypted data. This matters because 'raw' encryption merely stops someone reading a message: if they already know what some parts of the message say (e.g. because it's a well known data structure) then by flipping bits in the encrypted data, corruption can be created in the decrypted message. In some situations these corruptions could change the way the message is parsed leading to an exploit, for example, by changing a zero to a one and gaining administrator access . Like all symmetric ciphers, for AES/GCM to work both sides must know the same key. But we want to be able to send messages to a target for which we only know a public key, and have never had a chance to securely generate a joint AES key with. This is the problem solved by the Elliptic Curve Diffie-Hellman algorithm . To use it we first select a large random number (256 bits) and then convert that to a coordinate on an elliptic curve - in our case, we use Curve25519, which is a modern and highly robust elliptic curve. The point on the elliptic curve is our public key and can be encoded in another 256 bits (32 bytes). We write this public key after the unencrypted envelope. This key is an ephemeral key - we picked it just for the purposes of creating this mail. We know the target's public key either because the enclave puts it public key into the remote attestation, represented by an EnclaveInstanceInfo object, or because the enclave is replying and obtained the key to reply to from an earlier mail. Two public keys is all that's needed for both parties to compute the same AES key, without any man-in-the-middle being able to calculate the same value. The sender may also have a long term \"static\" public key that the target will recognise. We append an encryption of this public key and repeat the calculation between the enclave's public key and the static key, generating a new AES/GCM key as a result. Note Even if the sender doesn't have a static key a random one is generated and used. This is so that every mail has a valid sender value which allows the enclave to ensure mail is ordered per sender (and topic), as discussed previously . As each step in the handshake progresses, a running hash is maintained that mixes in the hash of the prologue and the various intermediate stages. This allows the unencrypted headers to be tamper-proofed against the host as well, because the host will not be able to recalculate the authentication tag emitted to the end of the handshake. Thus the handshake consists of a random public key, an authenticated encryption of the sender's public key, and an authentication hash. Once this is done the mail's AES key has been computed. The initialization vector for each AES encryption is a counter (an exception will be thrown if the mail is so large the counter would wrap around, as that would potentially reveal information for cryptanalysis, however this cannot happen given the maximum mail size). The encrypted body consists of a set of 64kb packets. Each packet has its own authentication tag, thus data is read from a mail in 64kb chunks. Packets may also contain a true length as distinct from the length of the plaintext. This allows the sender to artificially inflate the size of the encrypted message by simply padding it with zeros, which enables hiding of the true message size. Message sizes can be a giveaway to what exact content it contains. Comparison to a classical architecture using REST and SSL \u00b6 Let's look at why Conclave provides Mail, instead of having clients connect into an enclave using HTTPS. Note The following explanation applies when connecting to the enclave . When connecting to the host you may use whatever transport mechanism you like to pass mail around. Conclave doesn't currently privilege any particular transport over any other. We provide the mail paradigm for these reasons: HTTPS requires a relatively large and complex infrastructure, increasing the size of the TCB. It can go wrong in ways that aren't intuitive. Mail attempts to solve some common security problems before they start. SSL/TLS is not well adapted to enclaves, for example certificates don't make sense, but the protocol requires them. Web servers require the backing of a database to ensure session persistence and atomicity, but this interacts badly with the way enclaves handle time and state. Mail allows for a very simple approach to restarting and upgrading enclaves. The primary reason to use HTTPS+REST is familiarity and installed base of tools. However, none of these tools or libraries understand SGX remote attestation so cannot be used in their regular modes and must be modified or adjusted in complex ways, thus invalidating most of the benefits. We'll now explore these issues in more depth. TCB size \u00b6 The code that handles encrypted messaging is directly exposed to attackers. It is important to minimise the amount of code exposed in this way. For more discussion of how enclaves are designed to minimise code size, please see \"Small is beautiful\" . TLS complexity \u00b6 Mail is based on the Noise protocol framework . Noise is designed by professional cryptographers and is used in WhatsApp, WireGuard and other modern network protocols. Noise was created because TLS is weighed down with complicated historical baggage and web-specific features. A Noise protocol delivers most of the same functionality but in a more modular, cleaner and simpler way. Therefore, outside of the web the primary reason to use TLS is compatibility, not technical excellence. Now there is Noise there isn't much reason to use TLS anymore when designing a new protocol from scratch, unless you really need its features or support. TLS 1.3 recognises this problem and simplifies the protocol, but it's still far more complex than a Noise protocol, and because the purpose of using TLS is compatibility and TLS 1.3 is very new, realistically you will support TLS 1.2 as well. So now you have even more complexity in your enclave because you need both 1.2 and 1.3 support simultaneously. A big source of complexity in TLS is X.509 certificates. Certificates do not make sense for an enclave but TLS absolutely requires them, so some systems try to jam fake pseudo-certificates into TLS, which aren't real but contain the remote attestation in an extension field. Fake certificates can create problems because a lot of organisations have decades of procedures and best practices around all aspects of certificates and X.509, so fake pseudo-certificates can end up harder to deploy and work with than a purely technical analysis would suggest. Noise is more modular - you can provide any arbitrary byte array as part of the handshake, which can thus include a certificate (of any format) if you want that, but it isn't necessary. In Conclave the \"certificate\" is the remote attestation data represented as an EnclaveInstanceInfo object. It will usually make sense to expose this to the client via some app-specific mechanism, for example, returning it in some other API, publishing it on a web server, a network drive, a message queue, even putting it into a distributed hash table. Noise and by extension Conclave doesn't care how you get this data, only that you have it. Certificates don't make sense for enclaves because TLS is all about verifiable names as a form of identity, but enclaves are all about measurements and remote attestations . Thus, any client tool that communicates with an enclave will need to extract a remote attestation from a pseudo-certificate and throw out the rest. Given that you would need complex custom client-side code anyway, TLS buys you little beyond brand recognition. Notice This logic applies when connecting to an enclave . When connecting to a host the domain name identity of the server owner may well matter, and in that case TLS can be useful. TLS stacks have a history of being extremely buggy. The security TLS supposedly adds has a track record of being undermined by bugs in the implementations e.g. Heartbleed. Putting a TLS stack into an enclave makes it much bigger and harder to audit. In Conclave, we could use the JSSE Java SSL implementation and thus avoid memory management errors, but there are other kinds of issues that can be experienced with TLS too, that Java cannot protect us from. We use a pure Java implementation of Noise which ensures there are no buffer overflows in our crypto stack, and it's small enough that we have read every line. By licensing Conclave you can get the code, and then you can read every line too. This is impractical for a TLS stack. Finally, TLS mandates complex session persistence. This is a subtle point that deserves deeper discussion. Sessions and forward secrecy \u00b6 One of the upgrades Noise gives us is the ability to encrypt in both interactive and one-way modes e.g. for encrypting a file. TLS and HTTPS are fundamentally interactive protocols and cannot do this. TLS is interactive because the modern way to use it (and the only way in TLS 1.3) is with forward secrecy . In a scheme with forward secrecy two sides calculate an ephemeral session symmetric key during the handshake, that is used only for a short period and then deleted - usually this means the ephemeral key is stored only in RAM. In theory this is good, because it means if someone hacks the server/enclave they can't decrypt all the old messages they might have recorded. The private key is used only to establish identity, not actually encrypt any messages. With a purely one-way handshake you don't get this. Forward secrecy is a rather slippery feature. The problem is simple - what does \"short period\" mean? This is surprisingly hard to answer. TLS was designed for the web so at first this meant a TCP connection that carried a few web requests. So, usually a few seconds or perhaps hours if doing a big download. These days it gets used in many other kinds of apps and thus might mean much longer sessions, but fundamentally a TLS session was tied to the lifetime of a socket and therefore it couldn't last very long. Handshaking to set up a new session key is slow, so various optimisations were introduced. Connections were kept alive longer, and TLS added \"session resume\" that allowed session keys to be saved to disk and continued in later connections. For this to actually add any security it has to be harder to steal the cached session keys than the identity keys, but why would this be so when they're both stored in ordinary files ? But there's actually an even deeper conceptual problem. TLS encrypts sockets. It has nothing to say about the wider design of your app - that's out of scope for the people designing TLS. As a consequence TLS sessions don't bear any resemblance to actual user sessions. The intuition behind forward secrecy is a sort of controlled forgetting ... when the session ends the keys that could decrypt it are destroyed, so even if a passive observer stops being passive and hacks someone's private key they can't get the \"forgotten\" data. If web apps forgot everything you uploaded for no better reason than you changed from 4G to Wi-Fi people would get pretty upset. So HTTP has the idea of cookies, but even that is too transient for most users, which is why web apps normally require you to log in to an account. The actual data an attacker cares about is tied to the lifetime of an account, not a TCP connection. To make this work servers must store user session data into a database. This is so obvious and natural we hardly think about it, but it largely obliterates the supposed benefits of forward secrecy - the private key is held on the server, so if you can steal it you can probably steal the database credentials that are also stored on the server. And then you can just steal the valuable user data out of the database, you don't need to decrypt TLS sessions anymore. The biggest risk to an enclave is that the host can read its memory and thus steal its keys. Forward secrecy doesn't help you with this because users (we think) won't tolerate an app that forgets stuff if a TCP connection resets, and operations teams won't tolerate software that can't be safely restarted. So in practice an enclave will immediately re-encrypt data received from a client under a static sealing key, and if you can steal a TLS private key out of an enclave you can also steal a sealing key. So it buys you nothing. Moreover, it's insufficient to simply seal a byte array. You will probably need some sort of minimal database infrastructure, to keep data separated by user and so on. So now you have the complexity of a data management layer in the enclave as well. The result of all this is we don't lose much by using a more asynchronous design in which there isn't an interactive handshake. Benefits of Noise \u00b6 By losing TLS we can: Eliminate huge complexity from in-enclave code. Avoid pseudo-certificates and other hacks that will open up exploits and hit corporate X.509 bureaucracy. Enable enclaves to talk to each other even if they can't be loaded simultaneously (e.g. on same machine) Move session management and expiry out of the enclave, where it can't be done properly anyway because there's no secure access to the clock. Get various other benefits, like being able to reuse MQ brokers, integrate with Corda flows, store messages to databases, support M-to-1 inbound message collection before processing and so on. Messages vs streams \u00b6 There are three main ways for networked programs to communicate: streams, messages and RPCs. The popular REST paradigm is a form of RPC for the purposes of this discussion. Multi-party computations all involve the transmission of relatively small messages, often without needing any immediate reply. For instance, over the course of a day parties may submit a small data structure when a human gets around to it, and get the results back hours later when a deadline or threshold is reached. In other cases submission of data to an enclave may be asynchronous and should not block a business process in case of outage. These requirements are not a good fit for stream-oriented connections that when on top of TCP require app developers to do their own framing (a frequent source of security vulnerabilities), can break due to NAT boxes timing them out, IP address changes, passing through one-way firewalls, require high-availability servers with load balancing, require databases for stored state and so on. With a stream or RPC oriented approach the enclave would be expected to respond to bytes from a client more or less immediately, meaning it has to be always running and would have to persist uploaded data itself. Unfortunately persistence in enclaves is tricky due to the existence of Memento attacks . RPCs (including REST) can be hard to integrate with fully reliable systems that can tolerate restarts at any moment. Because server restarts break connections, in a loosely coupled multi-party system connection-oriented protocols require expensive HA load balancing to ensure users aren't often exposed to errors caused by planned restarts. Even then it isn't possible to eliminate such errors entirely, just reduce their impact. Load balancing in an enclave environment requires special support because the client is intimately aware of the exact CPU the enclave is running on - thus switching a client between servers isn't transparent. Note Future versions of Conclave are planned to add support for enclave clustering. All this suggests the primary paradigm exposed to enclaves should be messages. The host will take care of delivering messages and providing atomic, transactional semantics over them so many kinds of enclaves won't need an encrypted database at all. The untrusted host can also take on the significant burden of moving data around, storing it to disk, sorting it, applying backpressure, exposing to the admin if there are backlogs etc.","title":"Communicating with an enclave using Mail"},{"location":"mail.html#mail","text":"A mail is an authenticated byte array with an encrypted body and a cleartext envelope. The mail can be up to two gigabytes in size, however, it must at this time fit into memory when loaded all at once. In practice mails will usually be much smaller than that. Conclave Mail unifies messaging and data storage. It provides a variety of features that are useful when building applications: Encryption. The encryption key used by the enclave is private to that enclave but stable across restarts and enclave upgrades. This means messages encrypted and delivered by older clients can still be decrypted. The format uses the respected Noise protocol framework (with AES/GCM and SHA-256), which is the same cryptographic framework used by WhatsApp, the Linux kernel WireGuard protocol and I2P. Authentication. Mail allows a message to prove it came from the owner of a particular key, as well as being encrypted to a destination public key. Because of this it's easy to encrypt a reply to the sender, although how a public key is mapped to a physical computer is up to the app developer. This capability is useful for another reason: if an enclave has a notion of a user identifiable by public key, mail can be cryptographically authenticated as having come from that user. This avoids the need for complex user login processes: the login process can be handled outside of the enclave, without compromising security. The envelope is protected this way along with the encrypted body. Headers. Mail has unencrypted but authenticated (tamperproof) headers that can be used to link messages together. This allows clients to structure a conversation as if they were using a socket, but also hold multiple conversations simultaneously. This can be used to implement usage tracking, prioritisation, or other tasks not directly relevant to data processing that the host can assist with (despite its untrusted nature). Headers provide strong sequence numbers that are set by the sender and prevent the host re-ordering messages, a \"topic\" string field that is more useful than a port number (e.g. can identify what it's about, be mapped to message queue names), and applications can put their own data in the envelope part of the headers thus enabling hosts to see part of the messages. This can frequently be a useful design pattern. The headers are described in more detail in the tutorial . Framing. A typical need with any socket or stream based transport is to add framing on top, because the application really needs to work with messages. In textual protocols framing can be remarkably tricky to get right, as user or attacker controlled data may be placed inside a message, meaning any characters that mark the end of a message need to be escaped. This can go wrong in a variety of interesting ways . Mail by its nature delimits messages such that you can always tell where they begin and end, without needing to impose your own framing on top.","title":"Mail"},{"location":"mail.html#future-features","text":"We plan to add additional features to the mail API in upcoming releases: Storage. Mail will be stored by the host process. Often an enclave is implementing a form of batch job. By allowing the host to handle storage of messages, mail allows it to delay starting the enclave until enough data has arrived. This in turn allows the host to best utilise the limited pool of encrypted RAM available for enclaves. Atomicity. Mail should be delivered by the host to an enclave on each startup, until the mail is acknowledged. Acknowledgement and posting mail will become transactional, thus can be performed atomically with other acknowledgements and sending other replies. In this way enclaves can ensure that restarting an enclave doesn't produce duplicate messages, perform the same actions twice or cause service interruptions to users. Notice More sophisticated database solutions may be added in future releases.","title":"Future features"},{"location":"mail.html#using-mail-for-storage","text":"Mail is not only intended for messaging. It subsumes the \"sealing\" functionality that appears in most trusted computing platforms. By sending mail to itself an enclave can store chunks of data that will be fed back to it at startup. It can then delete these chunks by acknowledging the mails. Utilising mail this way has a variety of advantages: The same encryption, authentication and trusted computing base (TCB) management features are available for stored data as well as messaging. The API is simple and used the same way for both use cases. Mail acknowledgement can be used to control data lifetime, by having enclaves signal to the host that it's safe to delete data which is no longer needed. Stored data typically comes from input data (i.e. messages) and may be stored incrementally. Sequence numbers and topics provide a way to organise stored data that can be integrated with the client's view of time, thus allowing rollback attacks on storage to be detected and blocked in some cases. This isn't a replacement for a full database. However, in many cases it may be more appropriate, as accessing a database from an enclave can leak a lot of data via access patterns and of course the database itself may need access to the unencrypted data to index or search it. The mail-to-self pattern avoids this by storing the dataset in memory and always reading all stored data at startup. Note Currently storage management is delegated to the application. The enclave may signal acknowledgement requests to the host but by default nothing is done with them.","title":"Using mail for storage"},{"location":"mail.html#attacks-on-messaging","text":"Mail is designed to block a variety of attacks the host can mount on the enclave. Observation. The body of the mail is encrypted with industry standard AES/GCM. The host can't see what the client is sending to the enclave. Tampering. All the encrypted body, the plaintext headers and the user-specifiable envelope header are authenticated such that the enclave can detect if they were tampered with. See below for more information on this. Reordering. The enclave can't directly access any hardware other than the CPU and RAM. That means it can't know that messages came from the network card or hard disk in the right order, or that no messages were dropped. Mails include a sequence number and topic in the headers, meaning it is visible to the host but can't be tampered with. This enlists the client as an ally in the enclave's war against the host: the client wants its messages to be delivered in the right order and without being dropped. The Conclave runtime checks the sequence numbers in the headers always increment, on a per-topic basis, before passing the mail to your code. Note The host may arbitrarily delay or even refuse to deliver mail, but it can only end the stream of mails early, it can't re-order messages relative to each other. This is a feature not a bug, as if the enclave could force the host to deliver mail that would imply it had actually taken over the computer somehow and was forcing it to provide services to the enclave. SGX isn't a form of remote control and nobody can force a host to run enclaves against its will. Size side channels. Simply knowing how big a message is can be surprisingly powerful . Mail is automatically padded by Conclave to give messages a uniform size. This blocks attempts to infer the contents of the message based on the precise size. By default Mail uses a moving average but the policy is configurable and so if you know a reasonable upper limit on the size of your messages, you can pad every message to be that size. The host will be blinded and have to try and infer what's going on just from message timing. You can fix that by sending empty mails even when you have nothing to say. For example, if an enclave is running some sort of auction or competition between users and you wish to hide who won, the enclave can simply send a \"you won\" or \"you lost\" message to every client. Even if the winner needs additional data the padding will ensure the host can't tell which client won.","title":"Attacks on messaging"},{"location":"mail.html#how-does-mail-work","text":"When viewed as a structured array of bytes, a mail consists of five parts: The protocol ID. The unencrypted headers, which have fields simply laid out in order. The unencrypted envelope, which is empty by default and exists for you to add whatever data you like (i.e. additional headers). The handshake. The encrypted body. Let's call the protocol ID, unencrypted headers and envelope the prologue . At the core of Mail's security is the handshake. It consists of the data needed to do an elliptic curve Diffie-Hellman calculation and derive a unique (per mail) AES/GCM key, using the Noise protocol specification . AES/GCM is an authenticated encryption mechanism. That means the key is used not only to encrypt data, but also calculate a special hash called a \"tag\" that allows detection of modifications to the encrypted data. This matters because 'raw' encryption merely stops someone reading a message: if they already know what some parts of the message say (e.g. because it's a well known data structure) then by flipping bits in the encrypted data, corruption can be created in the decrypted message. In some situations these corruptions could change the way the message is parsed leading to an exploit, for example, by changing a zero to a one and gaining administrator access . Like all symmetric ciphers, for AES/GCM to work both sides must know the same key. But we want to be able to send messages to a target for which we only know a public key, and have never had a chance to securely generate a joint AES key with. This is the problem solved by the Elliptic Curve Diffie-Hellman algorithm . To use it we first select a large random number (256 bits) and then convert that to a coordinate on an elliptic curve - in our case, we use Curve25519, which is a modern and highly robust elliptic curve. The point on the elliptic curve is our public key and can be encoded in another 256 bits (32 bytes). We write this public key after the unencrypted envelope. This key is an ephemeral key - we picked it just for the purposes of creating this mail. We know the target's public key either because the enclave puts it public key into the remote attestation, represented by an EnclaveInstanceInfo object, or because the enclave is replying and obtained the key to reply to from an earlier mail. Two public keys is all that's needed for both parties to compute the same AES key, without any man-in-the-middle being able to calculate the same value. The sender may also have a long term \"static\" public key that the target will recognise. We append an encryption of this public key and repeat the calculation between the enclave's public key and the static key, generating a new AES/GCM key as a result. Note Even if the sender doesn't have a static key a random one is generated and used. This is so that every mail has a valid sender value which allows the enclave to ensure mail is ordered per sender (and topic), as discussed previously . As each step in the handshake progresses, a running hash is maintained that mixes in the hash of the prologue and the various intermediate stages. This allows the unencrypted headers to be tamper-proofed against the host as well, because the host will not be able to recalculate the authentication tag emitted to the end of the handshake. Thus the handshake consists of a random public key, an authenticated encryption of the sender's public key, and an authentication hash. Once this is done the mail's AES key has been computed. The initialization vector for each AES encryption is a counter (an exception will be thrown if the mail is so large the counter would wrap around, as that would potentially reveal information for cryptanalysis, however this cannot happen given the maximum mail size). The encrypted body consists of a set of 64kb packets. Each packet has its own authentication tag, thus data is read from a mail in 64kb chunks. Packets may also contain a true length as distinct from the length of the plaintext. This allows the sender to artificially inflate the size of the encrypted message by simply padding it with zeros, which enables hiding of the true message size. Message sizes can be a giveaway to what exact content it contains.","title":"How does Mail work"},{"location":"mail.html#comparison-to-a-classical-architecture-using-rest-and-ssl","text":"Let's look at why Conclave provides Mail, instead of having clients connect into an enclave using HTTPS. Note The following explanation applies when connecting to the enclave . When connecting to the host you may use whatever transport mechanism you like to pass mail around. Conclave doesn't currently privilege any particular transport over any other. We provide the mail paradigm for these reasons: HTTPS requires a relatively large and complex infrastructure, increasing the size of the TCB. It can go wrong in ways that aren't intuitive. Mail attempts to solve some common security problems before they start. SSL/TLS is not well adapted to enclaves, for example certificates don't make sense, but the protocol requires them. Web servers require the backing of a database to ensure session persistence and atomicity, but this interacts badly with the way enclaves handle time and state. Mail allows for a very simple approach to restarting and upgrading enclaves. The primary reason to use HTTPS+REST is familiarity and installed base of tools. However, none of these tools or libraries understand SGX remote attestation so cannot be used in their regular modes and must be modified or adjusted in complex ways, thus invalidating most of the benefits. We'll now explore these issues in more depth.","title":"Comparison to a classical architecture using REST and SSL"},{"location":"mail.html#tcb-size","text":"The code that handles encrypted messaging is directly exposed to attackers. It is important to minimise the amount of code exposed in this way. For more discussion of how enclaves are designed to minimise code size, please see \"Small is beautiful\" .","title":"TCB size"},{"location":"mail.html#tls-complexity","text":"Mail is based on the Noise protocol framework . Noise is designed by professional cryptographers and is used in WhatsApp, WireGuard and other modern network protocols. Noise was created because TLS is weighed down with complicated historical baggage and web-specific features. A Noise protocol delivers most of the same functionality but in a more modular, cleaner and simpler way. Therefore, outside of the web the primary reason to use TLS is compatibility, not technical excellence. Now there is Noise there isn't much reason to use TLS anymore when designing a new protocol from scratch, unless you really need its features or support. TLS 1.3 recognises this problem and simplifies the protocol, but it's still far more complex than a Noise protocol, and because the purpose of using TLS is compatibility and TLS 1.3 is very new, realistically you will support TLS 1.2 as well. So now you have even more complexity in your enclave because you need both 1.2 and 1.3 support simultaneously. A big source of complexity in TLS is X.509 certificates. Certificates do not make sense for an enclave but TLS absolutely requires them, so some systems try to jam fake pseudo-certificates into TLS, which aren't real but contain the remote attestation in an extension field. Fake certificates can create problems because a lot of organisations have decades of procedures and best practices around all aspects of certificates and X.509, so fake pseudo-certificates can end up harder to deploy and work with than a purely technical analysis would suggest. Noise is more modular - you can provide any arbitrary byte array as part of the handshake, which can thus include a certificate (of any format) if you want that, but it isn't necessary. In Conclave the \"certificate\" is the remote attestation data represented as an EnclaveInstanceInfo object. It will usually make sense to expose this to the client via some app-specific mechanism, for example, returning it in some other API, publishing it on a web server, a network drive, a message queue, even putting it into a distributed hash table. Noise and by extension Conclave doesn't care how you get this data, only that you have it. Certificates don't make sense for enclaves because TLS is all about verifiable names as a form of identity, but enclaves are all about measurements and remote attestations . Thus, any client tool that communicates with an enclave will need to extract a remote attestation from a pseudo-certificate and throw out the rest. Given that you would need complex custom client-side code anyway, TLS buys you little beyond brand recognition. Notice This logic applies when connecting to an enclave . When connecting to a host the domain name identity of the server owner may well matter, and in that case TLS can be useful. TLS stacks have a history of being extremely buggy. The security TLS supposedly adds has a track record of being undermined by bugs in the implementations e.g. Heartbleed. Putting a TLS stack into an enclave makes it much bigger and harder to audit. In Conclave, we could use the JSSE Java SSL implementation and thus avoid memory management errors, but there are other kinds of issues that can be experienced with TLS too, that Java cannot protect us from. We use a pure Java implementation of Noise which ensures there are no buffer overflows in our crypto stack, and it's small enough that we have read every line. By licensing Conclave you can get the code, and then you can read every line too. This is impractical for a TLS stack. Finally, TLS mandates complex session persistence. This is a subtle point that deserves deeper discussion.","title":"TLS complexity"},{"location":"mail.html#sessions-and-forward-secrecy","text":"One of the upgrades Noise gives us is the ability to encrypt in both interactive and one-way modes e.g. for encrypting a file. TLS and HTTPS are fundamentally interactive protocols and cannot do this. TLS is interactive because the modern way to use it (and the only way in TLS 1.3) is with forward secrecy . In a scheme with forward secrecy two sides calculate an ephemeral session symmetric key during the handshake, that is used only for a short period and then deleted - usually this means the ephemeral key is stored only in RAM. In theory this is good, because it means if someone hacks the server/enclave they can't decrypt all the old messages they might have recorded. The private key is used only to establish identity, not actually encrypt any messages. With a purely one-way handshake you don't get this. Forward secrecy is a rather slippery feature. The problem is simple - what does \"short period\" mean? This is surprisingly hard to answer. TLS was designed for the web so at first this meant a TCP connection that carried a few web requests. So, usually a few seconds or perhaps hours if doing a big download. These days it gets used in many other kinds of apps and thus might mean much longer sessions, but fundamentally a TLS session was tied to the lifetime of a socket and therefore it couldn't last very long. Handshaking to set up a new session key is slow, so various optimisations were introduced. Connections were kept alive longer, and TLS added \"session resume\" that allowed session keys to be saved to disk and continued in later connections. For this to actually add any security it has to be harder to steal the cached session keys than the identity keys, but why would this be so when they're both stored in ordinary files ? But there's actually an even deeper conceptual problem. TLS encrypts sockets. It has nothing to say about the wider design of your app - that's out of scope for the people designing TLS. As a consequence TLS sessions don't bear any resemblance to actual user sessions. The intuition behind forward secrecy is a sort of controlled forgetting ... when the session ends the keys that could decrypt it are destroyed, so even if a passive observer stops being passive and hacks someone's private key they can't get the \"forgotten\" data. If web apps forgot everything you uploaded for no better reason than you changed from 4G to Wi-Fi people would get pretty upset. So HTTP has the idea of cookies, but even that is too transient for most users, which is why web apps normally require you to log in to an account. The actual data an attacker cares about is tied to the lifetime of an account, not a TCP connection. To make this work servers must store user session data into a database. This is so obvious and natural we hardly think about it, but it largely obliterates the supposed benefits of forward secrecy - the private key is held on the server, so if you can steal it you can probably steal the database credentials that are also stored on the server. And then you can just steal the valuable user data out of the database, you don't need to decrypt TLS sessions anymore. The biggest risk to an enclave is that the host can read its memory and thus steal its keys. Forward secrecy doesn't help you with this because users (we think) won't tolerate an app that forgets stuff if a TCP connection resets, and operations teams won't tolerate software that can't be safely restarted. So in practice an enclave will immediately re-encrypt data received from a client under a static sealing key, and if you can steal a TLS private key out of an enclave you can also steal a sealing key. So it buys you nothing. Moreover, it's insufficient to simply seal a byte array. You will probably need some sort of minimal database infrastructure, to keep data separated by user and so on. So now you have the complexity of a data management layer in the enclave as well. The result of all this is we don't lose much by using a more asynchronous design in which there isn't an interactive handshake.","title":"Sessions and forward secrecy"},{"location":"mail.html#benefits-of-noise","text":"By losing TLS we can: Eliminate huge complexity from in-enclave code. Avoid pseudo-certificates and other hacks that will open up exploits and hit corporate X.509 bureaucracy. Enable enclaves to talk to each other even if they can't be loaded simultaneously (e.g. on same machine) Move session management and expiry out of the enclave, where it can't be done properly anyway because there's no secure access to the clock. Get various other benefits, like being able to reuse MQ brokers, integrate with Corda flows, store messages to databases, support M-to-1 inbound message collection before processing and so on.","title":"Benefits of Noise"},{"location":"mail.html#messages-vs-streams","text":"There are three main ways for networked programs to communicate: streams, messages and RPCs. The popular REST paradigm is a form of RPC for the purposes of this discussion. Multi-party computations all involve the transmission of relatively small messages, often without needing any immediate reply. For instance, over the course of a day parties may submit a small data structure when a human gets around to it, and get the results back hours later when a deadline or threshold is reached. In other cases submission of data to an enclave may be asynchronous and should not block a business process in case of outage. These requirements are not a good fit for stream-oriented connections that when on top of TCP require app developers to do their own framing (a frequent source of security vulnerabilities), can break due to NAT boxes timing them out, IP address changes, passing through one-way firewalls, require high-availability servers with load balancing, require databases for stored state and so on. With a stream or RPC oriented approach the enclave would be expected to respond to bytes from a client more or less immediately, meaning it has to be always running and would have to persist uploaded data itself. Unfortunately persistence in enclaves is tricky due to the existence of Memento attacks . RPCs (including REST) can be hard to integrate with fully reliable systems that can tolerate restarts at any moment. Because server restarts break connections, in a loosely coupled multi-party system connection-oriented protocols require expensive HA load balancing to ensure users aren't often exposed to errors caused by planned restarts. Even then it isn't possible to eliminate such errors entirely, just reduce their impact. Load balancing in an enclave environment requires special support because the client is intimately aware of the exact CPU the enclave is running on - thus switching a client between servers isn't transparent. Note Future versions of Conclave are planned to add support for enclave clustering. All this suggests the primary paradigm exposed to enclaves should be messages. The host will take care of delivering messages and providing atomic, transactional semantics over them so many kinds of enclaves won't need an encrypted database at all. The untrusted host can also take on the significant burden of moving data around, storing it to disk, sorting it, applying backpressure, exposing to the admin if there are backlogs etc.","title":"Messages vs streams"},{"location":"mockmode.html","text":"Building enclaves in Mock Mode \u00b6 Conclave provides a number of different modes when building your enclave, supporting different stages of the development cycle. Release, debug and simulation modes all require a Linux environment in order to run. This does not prevent running a simulation enclave on MacOS or Windows if you load and run you project in a Docker container, but for convenience it is useful to be able to run your enclave code directly within the host environment. In addition, the build time for simulation, debug and release enclaves can be quite high. With mock mode, the enclave class runs in the same JVM as the host, so interactions between the enclave and host are all just regular function calls. You can expect very short build times, step through using a debugger and enjoy the regular Java development experience. Tip To debug your host application in mock mode from IntelliJ, find the :host:run task in the gradle menu, add the -PenclaveMode=mock argument to the run configuration, and then run the task in debug mode. Using mock mode \u00b6 Mock mode can be used in two different ways. Firstly, you can compile your enclave in mock mode using the -PenclaveMode flag for fast, iterative development. Secondly, when creating an EnclaveHost inside the enclave module, Conclave will automatically create it in mock mode. This means any tests you define in the enclave module will automatically use mock mode - you can write your tests to load and call the enclave without having to explicitly configure a mock enclave. For tests to use any other mode, they must be defined outside the enclave module, for example in the host. Mock mode and the host classpath \u00b6 When loading an enclave from the host, Conclave looks in two places for the enclave class. Firstly, it looks on the current classpath. If the enclave class is present in the classpath then it will assume a mock configuration and load the enclave code directly. Secondly, it looks in the resources for a JAR file that contains a simulation, debug or release enclave. If that is present, it is unpacked and loaded. If the enclave class is on the classpath and the enclave JAR file is present then the host will throw an exception stating that multiple enclave classes have been found. In order to avoid this you need to carefully configure the dependencies in your host project to ensure only a single enclave is present. In most cases you do not require the enclave classes within the host project so all you need to do is set the enclave project as a runtimeOnly dependency. This will then work for all enclave configurations: 1 runtimeOnly project ( path: \":enclave\" , configuration: mode ) If, however, you do need to access the enclave class in your host project in mock mode via the the EnclaveHost.mockEnclave property then you will need to conditionally depend on the enclave project at compile or implementation time by including this in your host build.gradle : 1 2 3 4 5 if ( mode == \"mock\" ) { implementation project ( path: \":enclave\" , configuration: \"mock\" ) } else { runtimeOnly project ( path: \":enclave\" , configuration: mode ) } Info Note that within the enclave project the enclave class is always present on the classpath. This means that all tests defined within the enclave project always use mock mode. Accessing the enclave from the mock host \u00b6 When using mock mode, the host provides access to the enclave instance via the EnclaveHost.mockEnclave property. If you want to look at the internal state of your enclave you can cast this property to your actual enclave class type. 1 ReverseEnclave reverseEnclave = ( ReverseEnclave ) mockHost . getMockEnclave (); Notice The EnclaveHost.mockEnclave property can only be used with mock enclaves. The host does not have access to internal enclave state for any other enclave type. If you attempt to access the property on a non-mock enclave then IllegalStateException will be thrown. Mock mode configuration \u00b6 When you build an enclave in release, debug mode or simulation mode, there are certain environmental parameters that are defined by the trusted computing base and the Conclave configuration. In mock mode, instead of being defined by the platform, these parameters are defined using the MockConfiguration class which is subsequently passed to EnclaveHost.load() . This class can be used to configure these parameters for use when the mock enclave is loaded. This is useful to allow test cases to be written for checking correct enclave operation around version increments and rollbacks. Notice MockConfiguration is only applied when using mock mode. If you provide a mock configuration when loading a non-mock enclave then it is ignored. The MockConfiguration class allows configuration of the following properties. The table below describes each property and shows the SGX equivalent parameter for information. Property SGX Equivalent Allowed values Default Value Description codeHash MRENCLAVE 32 byte array SHA256(enclave class name) Specifies an array of bytes to use as the enclave code hash measurement. codeSigningKeyHash MRSIGNER 32 byte array 32 zero bytes Specifies an array of bytes to use as a hash of the public key used to sign the enclave. The mock enclave will create a public/private key pair based on this value. productID ISVProdId 1-65535 1 The mock product ID of the enclave, used to uniquely identify enclaves signed with the same signing key. revocationLevel ISVSVN 0-65534 0 The mock revocation level of the enclave. tcbLevel CPUSVN 1-65535 1 A mock version number that defines the TCB level, or version number of the TCB. This is equivalent to the SGX CPUSVN but because Conclave uses an integer, the tcbLevel is ordered allowing for easy testing of TCB recovery . If you do not provide a MockConfiguration when loading a mock enclave then the default values are used. If you want to specify your own MockConfiguration you can configure these properties when loading the enclave via the host using code similar to this: 1 2 3 4 5 MockConfiguration config = new MockConfiguration (); config . setProductID ( 2 ); config . setTcbLevel ( 3 ); config . setCodeSigningKeyHash ( SHA256Hash . parse ( \"1234567890123456789012345678901234567890123456789012345678901234\" )); EnclaveHost mockHost = EnclaveHost . load ( \"com.r3.conclave.sample.enclave.ReverseEnclave\" , config ); See here for more information on CPUSVN .","title":"Rapid testing and development with Mock Mode"},{"location":"mockmode.html#building-enclaves-in-mock-mode","text":"Conclave provides a number of different modes when building your enclave, supporting different stages of the development cycle. Release, debug and simulation modes all require a Linux environment in order to run. This does not prevent running a simulation enclave on MacOS or Windows if you load and run you project in a Docker container, but for convenience it is useful to be able to run your enclave code directly within the host environment. In addition, the build time for simulation, debug and release enclaves can be quite high. With mock mode, the enclave class runs in the same JVM as the host, so interactions between the enclave and host are all just regular function calls. You can expect very short build times, step through using a debugger and enjoy the regular Java development experience. Tip To debug your host application in mock mode from IntelliJ, find the :host:run task in the gradle menu, add the -PenclaveMode=mock argument to the run configuration, and then run the task in debug mode.","title":"Building enclaves in Mock Mode"},{"location":"mockmode.html#using-mock-mode","text":"Mock mode can be used in two different ways. Firstly, you can compile your enclave in mock mode using the -PenclaveMode flag for fast, iterative development. Secondly, when creating an EnclaveHost inside the enclave module, Conclave will automatically create it in mock mode. This means any tests you define in the enclave module will automatically use mock mode - you can write your tests to load and call the enclave without having to explicitly configure a mock enclave. For tests to use any other mode, they must be defined outside the enclave module, for example in the host.","title":"Using mock mode"},{"location":"mockmode.html#mock-mode-and-the-host-classpath","text":"When loading an enclave from the host, Conclave looks in two places for the enclave class. Firstly, it looks on the current classpath. If the enclave class is present in the classpath then it will assume a mock configuration and load the enclave code directly. Secondly, it looks in the resources for a JAR file that contains a simulation, debug or release enclave. If that is present, it is unpacked and loaded. If the enclave class is on the classpath and the enclave JAR file is present then the host will throw an exception stating that multiple enclave classes have been found. In order to avoid this you need to carefully configure the dependencies in your host project to ensure only a single enclave is present. In most cases you do not require the enclave classes within the host project so all you need to do is set the enclave project as a runtimeOnly dependency. This will then work for all enclave configurations: 1 runtimeOnly project ( path: \":enclave\" , configuration: mode ) If, however, you do need to access the enclave class in your host project in mock mode via the the EnclaveHost.mockEnclave property then you will need to conditionally depend on the enclave project at compile or implementation time by including this in your host build.gradle : 1 2 3 4 5 if ( mode == \"mock\" ) { implementation project ( path: \":enclave\" , configuration: \"mock\" ) } else { runtimeOnly project ( path: \":enclave\" , configuration: mode ) } Info Note that within the enclave project the enclave class is always present on the classpath. This means that all tests defined within the enclave project always use mock mode.","title":"Mock mode and the host classpath"},{"location":"mockmode.html#accessing-the-enclave-from-the-mock-host","text":"When using mock mode, the host provides access to the enclave instance via the EnclaveHost.mockEnclave property. If you want to look at the internal state of your enclave you can cast this property to your actual enclave class type. 1 ReverseEnclave reverseEnclave = ( ReverseEnclave ) mockHost . getMockEnclave (); Notice The EnclaveHost.mockEnclave property can only be used with mock enclaves. The host does not have access to internal enclave state for any other enclave type. If you attempt to access the property on a non-mock enclave then IllegalStateException will be thrown.","title":"Accessing the enclave from the mock host"},{"location":"mockmode.html#mock-mode-configuration","text":"When you build an enclave in release, debug mode or simulation mode, there are certain environmental parameters that are defined by the trusted computing base and the Conclave configuration. In mock mode, instead of being defined by the platform, these parameters are defined using the MockConfiguration class which is subsequently passed to EnclaveHost.load() . This class can be used to configure these parameters for use when the mock enclave is loaded. This is useful to allow test cases to be written for checking correct enclave operation around version increments and rollbacks. Notice MockConfiguration is only applied when using mock mode. If you provide a mock configuration when loading a non-mock enclave then it is ignored. The MockConfiguration class allows configuration of the following properties. The table below describes each property and shows the SGX equivalent parameter for information. Property SGX Equivalent Allowed values Default Value Description codeHash MRENCLAVE 32 byte array SHA256(enclave class name) Specifies an array of bytes to use as the enclave code hash measurement. codeSigningKeyHash MRSIGNER 32 byte array 32 zero bytes Specifies an array of bytes to use as a hash of the public key used to sign the enclave. The mock enclave will create a public/private key pair based on this value. productID ISVProdId 1-65535 1 The mock product ID of the enclave, used to uniquely identify enclaves signed with the same signing key. revocationLevel ISVSVN 0-65534 0 The mock revocation level of the enclave. tcbLevel CPUSVN 1-65535 1 A mock version number that defines the TCB level, or version number of the TCB. This is equivalent to the SGX CPUSVN but because Conclave uses an integer, the tcbLevel is ordered allowing for easy testing of TCB recovery . If you do not provide a MockConfiguration when loading a mock enclave then the default values are used. If you want to specify your own MockConfiguration you can configure these properties when loading the enclave via the host using code similar to this: 1 2 3 4 5 MockConfiguration config = new MockConfiguration (); config . setProductID ( 2 ); config . setTcbLevel ( 3 ); config . setCodeSigningKeyHash ( SHA256Hash . parse ( \"1234567890123456789012345678901234567890123456789012345678901234\" )); EnclaveHost mockHost = EnclaveHost . load ( \"com.r3.conclave.sample.enclave.ReverseEnclave\" , config ); See here for more information on CPUSVN .","title":"Mock mode configuration"},{"location":"performance.html","text":"Performance Considerations \u00b6 When you use Conclave to build an enclave, Conclave compiles your enclave code into native machine code using GraalVM Native Image. During this process the compiler removes any code that is not used and performs optimisations on the generated codebase. Entering and exiting an enclave causes a context switch which is fairly expensive in terms of CPU clock cycles. Also, memory accesses inside an enclave can be slower, particularly if memory paging is required. This means that performance inside an enclave will normally be lower than with a regular HotSpot JVM. This table shows the performance difference and how they vary between variety of benchmarks taken from the Computer Language Benchmarks Game . Note The \"empty\" benchmark is measuring the overhead of entering and exiting the enclave, without doing any work. As entering/exiting triggers a variety of hardware mechanisms designed to block side channel attacks this is naturally expensive relative to the cost of a regular function call, however, once the enclave is doing real work this transition cost becomes less relevant. Benchmark Environment Score Error Units empty Enclave 51921.076 \u00b1 1697.024 ops/s empty Host 49453365.793 \u00b1 3404118.758 ops/s binary_trees Enclave 454.061 \u00b1 31.089 ops/s binary_trees Host 1758.980 \u00b1 79.428 ops/s fannkuch Enclave 4.181 \u00b1 0.024 ops/s fannkuch Host 5.925 \u00b1 0.063 ops/s fasta Enclave 3.185 \u00b1 0.028 ops/s fasta Host 4.022 \u00b1 0.127 ops/s himeno Enclave 0.179 \u00b1 0.004 ops/s himeno Host 0.366 \u00b1 0.003 ops/s mandelbrot Enclave 5.529 \u00b1 0.134 ops/s mandelbrot Host 6.385 \u00b1 0.132 ops/s nbody Enclave 1.205 \u00b1 0.021 ops/s nbody Host 1.279 \u00b1 0.017 ops/s pidigits Enclave 9.941 \u00b1 0.185 ops/s pidigits Host 24.722 \u00b1 0.301 ops/s spectral_norm Enclave 11.923 \u00b1 0.274 ops/s spectral_norm Host 17.345 \u00b1 0.930 ops/s Higher scores are better. As you can see, the performance hit overall of using an enclave is highly dependent on what exactly the code is doing (primarily, memory access patterns).","title":"Performance"},{"location":"performance.html#performance-considerations","text":"When you use Conclave to build an enclave, Conclave compiles your enclave code into native machine code using GraalVM Native Image. During this process the compiler removes any code that is not used and performs optimisations on the generated codebase. Entering and exiting an enclave causes a context switch which is fairly expensive in terms of CPU clock cycles. Also, memory accesses inside an enclave can be slower, particularly if memory paging is required. This means that performance inside an enclave will normally be lower than with a regular HotSpot JVM. This table shows the performance difference and how they vary between variety of benchmarks taken from the Computer Language Benchmarks Game . Note The \"empty\" benchmark is measuring the overhead of entering and exiting the enclave, without doing any work. As entering/exiting triggers a variety of hardware mechanisms designed to block side channel attacks this is naturally expensive relative to the cost of a regular function call, however, once the enclave is doing real work this transition cost becomes less relevant. Benchmark Environment Score Error Units empty Enclave 51921.076 \u00b1 1697.024 ops/s empty Host 49453365.793 \u00b1 3404118.758 ops/s binary_trees Enclave 454.061 \u00b1 31.089 ops/s binary_trees Host 1758.980 \u00b1 79.428 ops/s fannkuch Enclave 4.181 \u00b1 0.024 ops/s fannkuch Host 5.925 \u00b1 0.063 ops/s fasta Enclave 3.185 \u00b1 0.028 ops/s fasta Host 4.022 \u00b1 0.127 ops/s himeno Enclave 0.179 \u00b1 0.004 ops/s himeno Host 0.366 \u00b1 0.003 ops/s mandelbrot Enclave 5.529 \u00b1 0.134 ops/s mandelbrot Host 6.385 \u00b1 0.132 ops/s nbody Enclave 1.205 \u00b1 0.021 ops/s nbody Host 1.279 \u00b1 0.017 ops/s pidigits Enclave 9.941 \u00b1 0.185 ops/s pidigits Host 24.722 \u00b1 0.301 ops/s spectral_norm Enclave 11.923 \u00b1 0.274 ops/s spectral_norm Host 17.345 \u00b1 0.930 ops/s Higher scores are better. As you can see, the performance hit overall of using an enclave is highly dependent on what exactly the code is doing (primarily, memory access patterns).","title":"Performance Considerations"},{"location":"renewability.html","text":"Renewability and TCB recovery \u00b6 All tamperproof systems need a way to be re-secured in the field after someone finds a way to breach their security. This property is called renewability. For Intel SGX renewability is obtained via a process called \"TCB recovery\". What is a TCB? \u00b6 The trusted computing base is defined as the set of computing technologies that must be working correctly and not be malicious or compromised for a security system to operate. The larger a TCB is, the more easily can something go wrong. In SGX the TCB is very small relative to comparable systems. It consists of: The CPU itself, including: The silicon The upgradeable microcode The system enclaves like the 'quoting enclave' which produces material for remote attestation. The runtime code linked into an enclave that's not direct business logic. For Conclave that means: The trts (trusted runtime system) from the Intel Linux SDK. The Conclave JVM and message routing code. Other components you might expect to be a part of the TCB aren't, for instance the operating system isn't, nor is the the BIOS nor the aesmd daemon that handles interaction with Intel's remote attestation assessment servers. Only small parts of the SGX infrastructure and code that runs inside enclaves needs to be operating correctly. Intel systems also have a chip called the 'management engine' (ME). Although some SGX apps use capabilities from this chip, Conclave doesn't use any ME services and thus the ME isn't a part of the trusted computing base. By implication bugs in the ME have no effect on your enclave. Recovering the TCB \u00b6 When bugs or security weaknesses are found the replaceable parts of the TCB are upgraded via normal software updates. The version of the TCB a computer is using is a part of the remote attestation, so enclave clients can check if the operator of an enclave has upgraded their TCB correctly and refuse to upload data if not. In this state the EnclaveInstanceInfo.securityInfoFromServer.summary property will be set to STALE , indicating that the system is running in a secure mode but there are known reasons to upgrade. To perform TCB recovery one or more of the following actions may be required by the owner of the hardware (i.e. either you or your cloud vendor): Applying operating system updates (as these include new microcode) Upgrading Conclave Recompiling the enclave and distributing a new version Altering the BIOS/UEFI configuration In cases where you're running on virtualised hardware, contact your cloud provider to learn about their schedule for performing TCB recoveries. If a new version of Conclave is required that will be communicated to licensees when it becomes available. New versions may also provide more detailed advice on what to do in the EnclaveSecurityInfo object. Converting an EnclaveInstanceInfo object to a string will usually include a textual summary explaining why a machine is judged to be insecure or stale and what can be done to resolve the problem. Key rotation and the SGX CPU Security Version Number \u00b6 When a TCB recovery occurs, enclave keys must be changed. This is to stop someone upgrading their machine past the security fix, convincing someone to send them data, then downgrading the machine so the data can be accessed. Recovery must be a one way door: new enclaves should be able to read old data, but old enclaves should not be able to read new data. The current state of the TCB is identified by the SGX CPU Security Version Number (CPUSVN). This is an array of bytes that is used to uniquely identify the security state of the the CPU platform, including the CPU SGX microcode revision. Whenever a TCB recovery takes place, the CPUSVN will change. This means that whenever a TCB recovery occurs, the CPUSVN changes and all data that is sealed after the recovery will use a new key. The enclave can request the generation of a sealing key using the current CPUSVN or a previous CPUSVN. This gives an enclave the ability to read data sealed using previous TCB states. However, the reverse is not possible - an enclave cannot request a key based on a future value of the CPUSVN. Conclave Mail handles TCB recovery automatically. Mails sent to the enclave prior to a TCB recovery are still decryptable after the recovery. Once clients have downloaded a fresh EnclaveInstanceInfo any new mails sent to the enclave using it will not be decryptable by the old system, or one that's been downgraded. Mock Mode and the SGX CPUSVN \u00b6 It is a good idea to test your enclave's ability to handle TCB recovery, checking that any data persisted by the enclave is still accessible when the CPUSVN value changes and that rolling back the CPUSVN (as an attacker might do) prevents the enclave from being able to access data with a later CPUSVN. In order to test this Conclave gives you the ability to set the SGX CPUSVN when using mock mode . Rather than providing an array of bytes, Conclave simplifies the setting of mock CPUSVN values by providing an integer tcbLevel setting. This allows you to specify an integer between 1 and 65535 which is hashed internally in the mock enclave using SHA256 and the resulting byte array is used as the mock CPUSVN. The use of an integer for tcbLevel means it is easy to test with ordered version numbers, allowing you to test how your enclave reacts to incrementing and decrementing TCB level values, simulating TCB recovery and downgrades. You can set the TCB level to use for testing by providing a MockConfiguration when loading your enclave in mock mode. For example, the following configuration sets the SGX CPUSVN while specifying the default values for everything else: 1 2 3 MockConfiguration config = new MockConfiguration (); config . setTcbLevel ( 5 ); EnclaveHost mockHost = EnclaveHost . load ( \"com.r3.conclave.sample.enclave.ReverseEnclave\" , config ); The above example sets the CPUSVN value to SHA256(5). This will allow sealing keys to be created inside your enclave for any CPUSVN from 1 to 5. Enclave-specific TCB recovery \u00b6 The enclave itself makes up a part of the overall system's TCB, because it's trusted to work correctly. If there's a security bug in the enclave business logic itself (or in Conclave) you will need to do an enclave-specific TCB recovery. This is easy: just increment the revocationLevel in your enclave configuration . Enclaves with a higher revocation level can read mail sent to enclaves with a lower level, but not vice-versa. When clients download a fresh EnclaveInstanceInfo then they will start sending mail that can't be decrypted by the revoked enclave. The final step is for clients to adjust their enclave constraint to require the new revocation level, thus forcing the server to run the upgraded version. Timeframes for TCB recovery \u00b6 When a global TCB recovery begins Intel announce it via their website. Deadlines are provided at which time remote attestations from non-upgraded systems will become labelled as STALE . This doesn't happen immediately: time is provided with which to implement any required changes and upgrade. This is to avoid apps that require fully upgraded systems from unexpectedly breaking on the day of the security announcements. CPU Security Version Number \u00b6 The current security revision of an Intel SGX platform is identified by the CPU Security Version Number (CPUSVN). This is an array of bytes that is used to uniquely identify the security state of the the CPU platform, including the CPU SGX microcode version. Whenever a TCB recovery takes place, the CPUSVN will change. The CPUSVN is used (along with other parameters) to derive the keys used to seal data that is sent outside the enclave. This means that whenever a TCB recovery occurs, the CPUSVN changes and all sealed data after the recovery will use a new key.","title":"Renewability"},{"location":"renewability.html#renewability-and-tcb-recovery","text":"All tamperproof systems need a way to be re-secured in the field after someone finds a way to breach their security. This property is called renewability. For Intel SGX renewability is obtained via a process called \"TCB recovery\".","title":"Renewability and TCB recovery"},{"location":"renewability.html#what-is-a-tcb","text":"The trusted computing base is defined as the set of computing technologies that must be working correctly and not be malicious or compromised for a security system to operate. The larger a TCB is, the more easily can something go wrong. In SGX the TCB is very small relative to comparable systems. It consists of: The CPU itself, including: The silicon The upgradeable microcode The system enclaves like the 'quoting enclave' which produces material for remote attestation. The runtime code linked into an enclave that's not direct business logic. For Conclave that means: The trts (trusted runtime system) from the Intel Linux SDK. The Conclave JVM and message routing code. Other components you might expect to be a part of the TCB aren't, for instance the operating system isn't, nor is the the BIOS nor the aesmd daemon that handles interaction with Intel's remote attestation assessment servers. Only small parts of the SGX infrastructure and code that runs inside enclaves needs to be operating correctly. Intel systems also have a chip called the 'management engine' (ME). Although some SGX apps use capabilities from this chip, Conclave doesn't use any ME services and thus the ME isn't a part of the trusted computing base. By implication bugs in the ME have no effect on your enclave.","title":"What is a TCB?"},{"location":"renewability.html#recovering-the-tcb","text":"When bugs or security weaknesses are found the replaceable parts of the TCB are upgraded via normal software updates. The version of the TCB a computer is using is a part of the remote attestation, so enclave clients can check if the operator of an enclave has upgraded their TCB correctly and refuse to upload data if not. In this state the EnclaveInstanceInfo.securityInfoFromServer.summary property will be set to STALE , indicating that the system is running in a secure mode but there are known reasons to upgrade. To perform TCB recovery one or more of the following actions may be required by the owner of the hardware (i.e. either you or your cloud vendor): Applying operating system updates (as these include new microcode) Upgrading Conclave Recompiling the enclave and distributing a new version Altering the BIOS/UEFI configuration In cases where you're running on virtualised hardware, contact your cloud provider to learn about their schedule for performing TCB recoveries. If a new version of Conclave is required that will be communicated to licensees when it becomes available. New versions may also provide more detailed advice on what to do in the EnclaveSecurityInfo object. Converting an EnclaveInstanceInfo object to a string will usually include a textual summary explaining why a machine is judged to be insecure or stale and what can be done to resolve the problem.","title":"Recovering the TCB"},{"location":"renewability.html#key-rotation-and-the-sgx-cpu-security-version-number","text":"When a TCB recovery occurs, enclave keys must be changed. This is to stop someone upgrading their machine past the security fix, convincing someone to send them data, then downgrading the machine so the data can be accessed. Recovery must be a one way door: new enclaves should be able to read old data, but old enclaves should not be able to read new data. The current state of the TCB is identified by the SGX CPU Security Version Number (CPUSVN). This is an array of bytes that is used to uniquely identify the security state of the the CPU platform, including the CPU SGX microcode revision. Whenever a TCB recovery takes place, the CPUSVN will change. This means that whenever a TCB recovery occurs, the CPUSVN changes and all data that is sealed after the recovery will use a new key. The enclave can request the generation of a sealing key using the current CPUSVN or a previous CPUSVN. This gives an enclave the ability to read data sealed using previous TCB states. However, the reverse is not possible - an enclave cannot request a key based on a future value of the CPUSVN. Conclave Mail handles TCB recovery automatically. Mails sent to the enclave prior to a TCB recovery are still decryptable after the recovery. Once clients have downloaded a fresh EnclaveInstanceInfo any new mails sent to the enclave using it will not be decryptable by the old system, or one that's been downgraded.","title":"Key rotation and the SGX CPU Security Version Number"},{"location":"renewability.html#mock-mode-and-the-sgx-cpusvn","text":"It is a good idea to test your enclave's ability to handle TCB recovery, checking that any data persisted by the enclave is still accessible when the CPUSVN value changes and that rolling back the CPUSVN (as an attacker might do) prevents the enclave from being able to access data with a later CPUSVN. In order to test this Conclave gives you the ability to set the SGX CPUSVN when using mock mode . Rather than providing an array of bytes, Conclave simplifies the setting of mock CPUSVN values by providing an integer tcbLevel setting. This allows you to specify an integer between 1 and 65535 which is hashed internally in the mock enclave using SHA256 and the resulting byte array is used as the mock CPUSVN. The use of an integer for tcbLevel means it is easy to test with ordered version numbers, allowing you to test how your enclave reacts to incrementing and decrementing TCB level values, simulating TCB recovery and downgrades. You can set the TCB level to use for testing by providing a MockConfiguration when loading your enclave in mock mode. For example, the following configuration sets the SGX CPUSVN while specifying the default values for everything else: 1 2 3 MockConfiguration config = new MockConfiguration (); config . setTcbLevel ( 5 ); EnclaveHost mockHost = EnclaveHost . load ( \"com.r3.conclave.sample.enclave.ReverseEnclave\" , config ); The above example sets the CPUSVN value to SHA256(5). This will allow sealing keys to be created inside your enclave for any CPUSVN from 1 to 5.","title":"Mock Mode and the SGX CPUSVN"},{"location":"renewability.html#enclave-specific-tcb-recovery","text":"The enclave itself makes up a part of the overall system's TCB, because it's trusted to work correctly. If there's a security bug in the enclave business logic itself (or in Conclave) you will need to do an enclave-specific TCB recovery. This is easy: just increment the revocationLevel in your enclave configuration . Enclaves with a higher revocation level can read mail sent to enclaves with a lower level, but not vice-versa. When clients download a fresh EnclaveInstanceInfo then they will start sending mail that can't be decrypted by the revoked enclave. The final step is for clients to adjust their enclave constraint to require the new revocation level, thus forcing the server to run the upgraded version.","title":"Enclave-specific TCB recovery"},{"location":"renewability.html#timeframes-for-tcb-recovery","text":"When a global TCB recovery begins Intel announce it via their website. Deadlines are provided at which time remote attestations from non-upgraded systems will become labelled as STALE . This doesn't happen immediately: time is provided with which to implement any required changes and upgrade. This is to avoid apps that require fully upgraded systems from unexpectedly breaking on the day of the security announcements.","title":"Timeframes for TCB recovery"},{"location":"renewability.html#cpu-security-version-number","text":"The current security revision of an Intel SGX platform is identified by the CPU Security Version Number (CPUSVN). This is an array of bytes that is used to uniquely identify the security state of the the CPU platform, including the CPU SGX microcode version. Whenever a TCB recovery takes place, the CPUSVN will change. The CPUSVN is used (along with other parameters) to derive the keys used to seal data that is sent outside the enclave. This means that whenever a TCB recovery occurs, the CPUSVN changes and all sealed data after the recovery will use a new key.","title":"CPU Security Version Number"},{"location":"security.html","text":"In this section we discuss some security issues inherent to the enclave model which may not be immediately apparent. Secure time access \u00b6 The trusted computing base is very small in the SGX architecture. Only the CPU and some support software needs to be trusted to work correctly. That means anything else in the computer other than the CPU is assumed to be broken or malicious, and defended against using encryption and authentication. This has implications for reading the system clock. The current time is maintained by a battery powered real-time clock chip outside the CPU, which can be tampered with by the untrusted machine owner at any time. For this reason inside the enclave the current time should only be used with care, e.g. when errors in it aren't security critical. Trying to read it will yield a time from the host that may not map to real time, may be invalid, or have other problems. Inside an instance of an enclave, Conclave will always return a time value that is greater than or equal to any previously presented time. If the host rewinds the clock then the enclave time will pause until the host time again catches up with the latest time in the enclave. However, if the enclave is restarted then the time inside the enclave could be earlier than in a previous instance of the enclave. Additionally, the host may pause execution of an enclave at any moment for an arbitrary duration without the enclave code being aware of that, so if you were to read a timestamp it might be very old at the moment you actually used it. However the protocol for accessing the timestamp doesn't involve doing any calls out of the enclave, so, the host can't observe the program's progress by watching OCALLs (which would otherwise be a side channel). Memento/rewind/replay attacks \u00b6 Your enclave has protected RAM which it uses to store normal, in-memory data. Reads are guaranteed to observe prior writes. But an enclave is just an ordinary piece of code running in an ordinary program. That means it cannot directly access hardware. Like any other program it has to ask the kernel to handle requests on its behalf, because the kernel is the only program running in the CPU's supervisor mode where hardware can be controlled (\"ring 0\" on Intel architecture chips). In fact, inside an enclave there is no direct access to the operating system at all. The only thing you can do is exchange messages with the host code. The host may choose to relay your requests through the kernel to the hardware honestly, or any of those components (host software, kernel, the hardware itself) may have been modified maliciously. The enclave protections are a feature of the CPU , not the entire computer, and the CPU maintains state only until it is reset or the power is lost. You can think of this another way. If the enclave stores some data to disk, nothing stops the owner of the computer stopping the enclave host process and then editing the files on disk. Because enclaves can generate encryption keys private to themselves, encryption and authentication can be used to stop the host editing the data. Data encrypted in this way is called sealed data . Sealed data can be re-requested from the operating system and decrypted inside the enclave. Conclave handles the sealing process for you. Unfortunately there's one class of attack encryption cannot stop. It must instead be considered in the design of your app. That attack is when the host gives you back older data than was requested. The system clock is controlled by the owner of the computer and so can't be relied on. Additionally, the owner can kill and restart the host process whenever they like. Together this means an enclave's sense of time and ordering of events can be tampered with to create confusion. By snapshotting the stored (sealed, encrypted) data an enclave has provided after each network message from a client is delivered, the enclave can be \"rewound\" to any point. Then stored messages from the clients can be replayed back to the enclave in different orders, or with some messages dropped. We call this a Memento attack, after the film in which the protagonist has anterograde amnesia . Warning A full discussion of Memento attacks is beyond the scope of this document. The Conclave project strives to provide you with high level protocol constructs that take them into account, but when writing your own protocols you should consider carefully what happens when messages can be re-ordered and re-tried by the host. Side channel attacks \u00b6 Side channel attacks are a way to break encryption without actually defeating the underlying algorithms, by making very precise observations from the outside of a machine or program doing a secure computation. Those observations may be of timings or power draw fluctuations. Because enclaves run in an environment controlled by an untrusted host, we must assume the operator of the host hardware is doing these kinds of observations in an attempt to break the security of the enclave. Side channel attacks introduce a fundamental tradeoff between performance, scalability and security. A part of Conclave's intended value proposition is to surface these tradeoffs to you in a way that's easy to understand and control, whilst blocking as many attacks as possible automatically. Side channel attacks on enclaves can be divided into two categories: Architectural Micro-architectural These types are discussed more below. Because side channel attacks present tradeoffs between privacy and performance, analysing them requires a different mindset to normal security analysis. Formally, we can say a secret has been leaked via a side channel if we can learn even a single binary bit of data about an encrypted message. However often the leaked data doesn't matter or isn't a secret worth protecting. In these cases it may be better to allow a limited amount of leakage to obtain better performance. Future versions of this guide and the Conclave API will assist you in studying and making these tradeoffs. A standard example is whether a message is of type A or type B, under the assumption that most apps have at least two kinds of message that an enclave can process from clients. Careful requirements analysis may reveal that the number or sequencing of message types doesn't reveal any important information and thus doesn't need to be protected: only the specific data within the messages. Architectural attacks \u00b6 Architectural side channel attacks exploit the nature, structure or specific code of your application architecture to reveal secrets. Here is a non-exhaustive set of examples: Message sizes . If your enclave is known to process only two kinds of message of around 1 kilobyte or 100 kilobytes respectively, then the size of the encrypted message by itself leaks information about what kind of message it is. Message processing time . The same as message sizes but with processing time, e.g. a message type that takes 1 millisecond to process vs 100 milliseconds can leak what kind of message it is by simply observing how much work the enclave does when the host passes it the new data. Storage access patterns . If your enclave doesn't access the database when processing a message of type A, but does when processing a message of type B, or accesses the database with a different sequence, number or type of accesses, the host can learn the message type by observing those accesses. Many of these techniques can be used to reveal fine-grained information, not just message types. For instance if an encrypted piece of data contains a number that's then used to control a loop that does data lookups, counting the number of external data lookups reveals the number. Some kinds of architectural side channel attacks can be mitigated by Conclave for you, for instance, messages can be padded so all encrypted messages look the same size. This sort of approach works if message sizes don't vary too wildly and you can afford to use the bandwidth and storage to set all messages to their maximum possible size. How valuable it is in your situation is a topic for you to consider as you design your app. Micro-architectural \u00b6 Enclave memory is encrypted. Micro-architectural side channel attacks exploit the inner workings of the CPU itself to reveal information whilst it's being processed by the CPU in its normal unencrypted state. There are a variety of different attacks with varying details. They work by exploiting the speculative execution capability of the processor to make an enclave compute on invalid data, which can then be used to bypass normal security mechanisms and leak data out of the enclave - not via normal means (which the CPU doesn't allow) but by affecting the timing of subsequent operations which can then be measured. Micro-architectural side channel attacks can be resolved at a layer lower than the architecture of your own application. They often require reducing the performance of either the enclave or the entire host system however, so it's worth always planning for a large buffer of unused per-host performance. The mitigations suggested for the latest round of micro-architectural side channel attacks (load value injection or LVI attacks) work by effectively disabling speculative execution when in enclave mode. Combined with the overhead of memory encryption, execution inside an enclave can run a lot slower than normal software running outside. Impact of side channel attacks \u00b6 Not all enclaves operate on secret data. Some types of enclave are used for their auditable execution rather than to work with secret data inaccessible to the host. For those kinds of enclave it's sufficient to protect the signing keys rather than all data the enclave accesses. Other types of enclave work purely with secret data, but expect that the host isn't normally malicious: in this scenario enclaves are being used to slow down or stop attackers in the face of a hacked host network. It thus makes up one part of a standard suite of security measures. Because the performance/privacy tradeoff presented by side channel attacks can vary so widely, and this is an active area of academic research, the expectation is that every new Conclave version will provide new tools and tunable settings to control their impact. This will continue for the lifespan of the product. As a developer it's your responsibility to both upgrade to new versions as they come out, and to take side channels into account when planning the architecture and capacity needs of your application. Random numbers \u00b6 Care must be taken when generating random numbers inside the enclave to ensure that you use a suitably strong random number generator that cannot be weakened or influenced by the host by tampering with data that is used to seed the random number generator. The safest way to ensure you are using a safe random number generator is to use the SecureRandom class to generate your random numbers. In Conclave enclaves, the implementation of this class uses the RDRAND instruction to use an on-CPU hardware random number generator. The implementation of the JDK Random class normally uses the system time as a seed, XORing it with a fixed value that is updated predictably with each new Random class instance. This provides an attack surface for the host as the time inside the enclave is provided directly by the host. In order to prevent accidental use of an insecure random number generator, Conclave modifies this behaviour so the first instance of a Random class XORs the system time with a truly random number derived from the RDRAND instruction. This results in the class using a truly unique high entropy seed. Subsequent instances of Random transform the seed to ensure no two sequences are the same but the entropy is not renewed using the RDRAND instruction. Therefore for the best quality random data it is still recommended to use SecureRandom .","title":"Maximising the security of your enclave"},{"location":"security.html#secure-time-access","text":"The trusted computing base is very small in the SGX architecture. Only the CPU and some support software needs to be trusted to work correctly. That means anything else in the computer other than the CPU is assumed to be broken or malicious, and defended against using encryption and authentication. This has implications for reading the system clock. The current time is maintained by a battery powered real-time clock chip outside the CPU, which can be tampered with by the untrusted machine owner at any time. For this reason inside the enclave the current time should only be used with care, e.g. when errors in it aren't security critical. Trying to read it will yield a time from the host that may not map to real time, may be invalid, or have other problems. Inside an instance of an enclave, Conclave will always return a time value that is greater than or equal to any previously presented time. If the host rewinds the clock then the enclave time will pause until the host time again catches up with the latest time in the enclave. However, if the enclave is restarted then the time inside the enclave could be earlier than in a previous instance of the enclave. Additionally, the host may pause execution of an enclave at any moment for an arbitrary duration without the enclave code being aware of that, so if you were to read a timestamp it might be very old at the moment you actually used it. However the protocol for accessing the timestamp doesn't involve doing any calls out of the enclave, so, the host can't observe the program's progress by watching OCALLs (which would otherwise be a side channel).","title":"Secure time access"},{"location":"security.html#mementorewindreplay-attacks","text":"Your enclave has protected RAM which it uses to store normal, in-memory data. Reads are guaranteed to observe prior writes. But an enclave is just an ordinary piece of code running in an ordinary program. That means it cannot directly access hardware. Like any other program it has to ask the kernel to handle requests on its behalf, because the kernel is the only program running in the CPU's supervisor mode where hardware can be controlled (\"ring 0\" on Intel architecture chips). In fact, inside an enclave there is no direct access to the operating system at all. The only thing you can do is exchange messages with the host code. The host may choose to relay your requests through the kernel to the hardware honestly, or any of those components (host software, kernel, the hardware itself) may have been modified maliciously. The enclave protections are a feature of the CPU , not the entire computer, and the CPU maintains state only until it is reset or the power is lost. You can think of this another way. If the enclave stores some data to disk, nothing stops the owner of the computer stopping the enclave host process and then editing the files on disk. Because enclaves can generate encryption keys private to themselves, encryption and authentication can be used to stop the host editing the data. Data encrypted in this way is called sealed data . Sealed data can be re-requested from the operating system and decrypted inside the enclave. Conclave handles the sealing process for you. Unfortunately there's one class of attack encryption cannot stop. It must instead be considered in the design of your app. That attack is when the host gives you back older data than was requested. The system clock is controlled by the owner of the computer and so can't be relied on. Additionally, the owner can kill and restart the host process whenever they like. Together this means an enclave's sense of time and ordering of events can be tampered with to create confusion. By snapshotting the stored (sealed, encrypted) data an enclave has provided after each network message from a client is delivered, the enclave can be \"rewound\" to any point. Then stored messages from the clients can be replayed back to the enclave in different orders, or with some messages dropped. We call this a Memento attack, after the film in which the protagonist has anterograde amnesia . Warning A full discussion of Memento attacks is beyond the scope of this document. The Conclave project strives to provide you with high level protocol constructs that take them into account, but when writing your own protocols you should consider carefully what happens when messages can be re-ordered and re-tried by the host.","title":"Memento/rewind/replay attacks"},{"location":"security.html#side-channel-attacks","text":"Side channel attacks are a way to break encryption without actually defeating the underlying algorithms, by making very precise observations from the outside of a machine or program doing a secure computation. Those observations may be of timings or power draw fluctuations. Because enclaves run in an environment controlled by an untrusted host, we must assume the operator of the host hardware is doing these kinds of observations in an attempt to break the security of the enclave. Side channel attacks introduce a fundamental tradeoff between performance, scalability and security. A part of Conclave's intended value proposition is to surface these tradeoffs to you in a way that's easy to understand and control, whilst blocking as many attacks as possible automatically. Side channel attacks on enclaves can be divided into two categories: Architectural Micro-architectural These types are discussed more below. Because side channel attacks present tradeoffs between privacy and performance, analysing them requires a different mindset to normal security analysis. Formally, we can say a secret has been leaked via a side channel if we can learn even a single binary bit of data about an encrypted message. However often the leaked data doesn't matter or isn't a secret worth protecting. In these cases it may be better to allow a limited amount of leakage to obtain better performance. Future versions of this guide and the Conclave API will assist you in studying and making these tradeoffs. A standard example is whether a message is of type A or type B, under the assumption that most apps have at least two kinds of message that an enclave can process from clients. Careful requirements analysis may reveal that the number or sequencing of message types doesn't reveal any important information and thus doesn't need to be protected: only the specific data within the messages.","title":"Side channel attacks"},{"location":"security.html#architectural-attacks","text":"Architectural side channel attacks exploit the nature, structure or specific code of your application architecture to reveal secrets. Here is a non-exhaustive set of examples: Message sizes . If your enclave is known to process only two kinds of message of around 1 kilobyte or 100 kilobytes respectively, then the size of the encrypted message by itself leaks information about what kind of message it is. Message processing time . The same as message sizes but with processing time, e.g. a message type that takes 1 millisecond to process vs 100 milliseconds can leak what kind of message it is by simply observing how much work the enclave does when the host passes it the new data. Storage access patterns . If your enclave doesn't access the database when processing a message of type A, but does when processing a message of type B, or accesses the database with a different sequence, number or type of accesses, the host can learn the message type by observing those accesses. Many of these techniques can be used to reveal fine-grained information, not just message types. For instance if an encrypted piece of data contains a number that's then used to control a loop that does data lookups, counting the number of external data lookups reveals the number. Some kinds of architectural side channel attacks can be mitigated by Conclave for you, for instance, messages can be padded so all encrypted messages look the same size. This sort of approach works if message sizes don't vary too wildly and you can afford to use the bandwidth and storage to set all messages to their maximum possible size. How valuable it is in your situation is a topic for you to consider as you design your app.","title":"Architectural attacks"},{"location":"security.html#micro-architectural","text":"Enclave memory is encrypted. Micro-architectural side channel attacks exploit the inner workings of the CPU itself to reveal information whilst it's being processed by the CPU in its normal unencrypted state. There are a variety of different attacks with varying details. They work by exploiting the speculative execution capability of the processor to make an enclave compute on invalid data, which can then be used to bypass normal security mechanisms and leak data out of the enclave - not via normal means (which the CPU doesn't allow) but by affecting the timing of subsequent operations which can then be measured. Micro-architectural side channel attacks can be resolved at a layer lower than the architecture of your own application. They often require reducing the performance of either the enclave or the entire host system however, so it's worth always planning for a large buffer of unused per-host performance. The mitigations suggested for the latest round of micro-architectural side channel attacks (load value injection or LVI attacks) work by effectively disabling speculative execution when in enclave mode. Combined with the overhead of memory encryption, execution inside an enclave can run a lot slower than normal software running outside.","title":"Micro-architectural"},{"location":"security.html#impact-of-side-channel-attacks","text":"Not all enclaves operate on secret data. Some types of enclave are used for their auditable execution rather than to work with secret data inaccessible to the host. For those kinds of enclave it's sufficient to protect the signing keys rather than all data the enclave accesses. Other types of enclave work purely with secret data, but expect that the host isn't normally malicious: in this scenario enclaves are being used to slow down or stop attackers in the face of a hacked host network. It thus makes up one part of a standard suite of security measures. Because the performance/privacy tradeoff presented by side channel attacks can vary so widely, and this is an active area of academic research, the expectation is that every new Conclave version will provide new tools and tunable settings to control their impact. This will continue for the lifespan of the product. As a developer it's your responsibility to both upgrade to new versions as they come out, and to take side channels into account when planning the architecture and capacity needs of your application.","title":"Impact of side channel attacks"},{"location":"security.html#random-numbers","text":"Care must be taken when generating random numbers inside the enclave to ensure that you use a suitably strong random number generator that cannot be weakened or influenced by the host by tampering with data that is used to seed the random number generator. The safest way to ensure you are using a safe random number generator is to use the SecureRandom class to generate your random numbers. In Conclave enclaves, the implementation of this class uses the RDRAND instruction to use an on-CPU hardware random number generator. The implementation of the JDK Random class normally uses the system time as a seed, XORing it with a fixed value that is updated predictably with each new Random class instance. This provides an attack surface for the host as the time inside the enclave is provided directly by the host. In order to prevent accidental use of an insecure random number generator, Conclave modifies this behaviour so the first instance of a Random class XORs the system time with a truly random number derived from the RDRAND instruction. This results in the class using a truly unique high entropy seed. Subsequent instances of Random transform the seed to ensure no two sequences are the same but the entropy is not renewed using the RDRAND instruction. Therefore for the best quality random data it is still recommended to use SecureRandom .","title":"Random numbers"},{"location":"signing.html","text":"Enclave signing \u00b6 Enclaves must be signed. With modern SGX servers you may self-sign your enclaves, but, a signature is still required. This section covers: Why signing is required Who can sign enclaves How to sign your enclaves Why is signing required? \u00b6 Signing requirements are a part of the Intel SGX architecture. The enclave signature is used for two different purposes: Linking different enclave versions together into an upgrade path, so new enclaves can decrypt data stored by or sent to old enclaves. Authorising which enclaves can be executed on a host. Restricting which enclaves can launch on a host ensures that datacenter providers aren't hosting server processes they can't examine or turn over to law enforcement. It also makes it harder for people to write malware with un-debuggable cores, and is part of the privacy (anti-tracking) infrastructure in SGX. Using signatures to link binaries into a single upgrade path is the same technique used by Android and iOS to move permissions and stored data from old to new apps. Signing is also used to authorise which enclaves can start. By default Intel chips won't start an enclave unless it's signed by an Intel key, but this behaviour can be changed and on Azure (see \"Deploying to Azure\" ) enclaves can be self-signed. If you want to use older hardware getting whitelisted by Intel is free and can be done quickly. It's a similar process to getting an SSL certificate but using different tools. On Xeon E CPUs with Intel FLC support in the chipset, and a recent enough kernel driver, the owner can add their own whitelisting authorities via BIOS/UEFI firmware settings. This means they can replace the default \"must be approved by Intel\" launch control logic with their own (which may e.g. only allow their own enclaves, or may allow any self-signed enclave). How to sign your enclaves \u00b6 Signing keys for simulation and debug enclaves \u00b6 It is not necessary to use a whitelisted signature for enclaves built in simulation and debug modes. However, it is still required that these enclaves are signed. Conclave supports the generation of a dummy key during the build process that can be used for signing simulation and debug enclaves. Obtaining a signing key for release enclaves \u00b6 Firstly, get a commercial license . This is a lightweight process and doesn't cost anything or impose other requirements. Following the instructions provided on that page should allow you to get a signing key. Tip It's up to you whether to store the key in an HSM. Signing configurations \u00b6 There are three different configurations available for signing enclaves using Conclave: Using a dummy key Using a private key Using an external process such as a signing service or HSM Dummy keys are only useful for signing simulation and debug enclaves. A release enclave signed with a dummy key will not be whitelisted on any platform so will not be allowed to load. A private key can be used to sign enclaves directly within the build process. The key must be accessible on the filesystem of the machine building the enclave. An external process is used when the signing key is not available on the machine building the enclave, or a manual or air-gapped process is required to sign the enclave. In this case the Conclave project is built in two steps. The first step generates the material to be signed. The second step provides the signed material to the Conclave build to continue and complete the build process. How to configure signing for your enclaves \u00b6 The signing method used by your enclaves is configured in the build.gradle file for your enclave project. You can specify different signing settings for simulation, debug and release in the same project. The signing configuration is specified inside the relevant enclave type inside the conclave configuration. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 conclave { simulation { // Simulation signing configuration using a dummy key signingType = dummyKey } debug { // Debug signing configuration using a private key signingType = privateKey signingKey = file ( \"../signing/sample_private_key.pem\" ) } release { // Release signing configuration using an external key signingType = externalKey mrsignerSignature = file ( \"../signing/signature.bin\" ) mrsignerPublicKey = file ( \"../signing/external_signing_public.pem\" ) signatureDate = new Date ( 1970 , 0 , 1 ) } } For simulation and debug enclaves signingType defaults to dummyKey so the configuration can be optionally omitted. Release enclaves default to having a signingType of externalKey so the configuration parameters for the external signing type must be specified. Alternatively the signingType can be changed to a different type. Note Changing the signing type of a release enclave to dummyKey will result in an enclave that cannot be used as it will never be whitelisted on an SGX platform. The configuration consists of a set of properties which depend on the signing type. Dummy Key \u00b6 Property Value signingType Must be set to dummyKey . This is the default signing type for simulation and debug enclaves. Private Key \u00b6 Property Value signingType Must be set to privateKey . signingKey The file that contains the private key to use when signing the enclave. This can be an absolute path or relative to the enclave project directory. External Key \u00b6 Property Value signingType Must be set to externalKey . This is the default signing type for release enclaves. signatureDate Specifies the date to be embedded in the material generated in the first stage of the external key signing process. signingMaterial The file that that Conclave will generate when preparing an enclave for signing in the first stage of the external key signing process. The resulting file needs to be signed by the external signing process. This can be an absolute path or relative to the enclave project directory. If this is omitted then the default filename of build/enclave/[Simulation|Debug|Release]/signing_material.bin is used mrsignerSignature Used in the second part of the external key process to specify the file containing the signature generated by the external signing process. This can be an absolute path or relative to the enclave project directory. mrsignerPublicKey Used in the second part of the external key process to specify the file containing the public part of the key that was used to externally sign the signing material. This can be an absolute path or relative to the enclave project directory. Generating keys for signing an enclave \u00b6 When using privateKey or externalKey signing types you can create your own keys for testing or production: Creating an RSA private key suitable for signing enclaves \u00b6 The generated key can be used to sign enclaves using the privateKey or externalKey signing types. When using the externalKey type you will need to generate the public key from the private key. 1 openssl genrsa -out my_private_key.pem -3 3072 Creating a password protected RSA private key suitable for signing enclaves \u00b6 The generated key can only be used for the externalKey signing type as it prompts for a password during use. 1 openssl genrsa -aes128 -out my_private_key.pem -3 3072 Obtaining the public key from a private key \u00b6 The public key is required for the externalKey signing type. 1 openssl rsa -in my_private_key.pem -pubout -out my_public_key.pem Note Make sure to generate the keys using openssl . Other tools, such as ssh-keygen , may not generate keys with properties required by Intel. Building a signed enclave \u00b6 Signing is performed automatically during the build process when using a dummy or private key. Additional steps are required when using an external key. Add the prepareForSigning task to the host build.gradle \u00b6 This is an optional but recommended step to create a more consistent calling convention for invoking Gradle. It adds a Gradle task that can be called regardless of the build type of the enclave. Add the following code to your host build.gradle file. This adds a new Gradle task that can be used to generate the material that will be signed by the external signing process. 1 2 3 tasks . register ( \"prepareForSigning\" ) { it . dependsOn ( \":enclave:generateEnclaveSigningMaterial\" + mode . capitalize ()) } The task works by using the mode Gradle property, which is set to one of simulation , debug or release depending on which enclave type is currently being built, to set a dependency on the relevant Conclave task that generates the signing material. The task makes the following two Gradle invocations equivalent: 1 2 ./gradlew prepareForSigning -PenclaveMode=\"Release\" ./gradlew :enclave:generateEnclaveSigningMaterialRelease See the tutorial and the hello-world sample in the Conclave SDK for an example of this configuration. Generate the signing material \u00b6 Invoke Gradle to generate the files that need to be signed by the external signing process. 1 ./gradlew prepareForSigning -PenclaveMode=\"Release\" The output of this stage is a file that contains the material to be signed in enclave/build/enclave/Release/signing_material.bin Sign the material \u00b6 Perform the required steps to manually sign the file generated in the previous step. This might require copying the file onto a different platform or onto an HSM to generate the signed file. As an example, given a private key the following command can be used to sign the file: 1 openssl dgst -sha256 -out signature.bin -sign my_private_key.pem -keyform PEM signing_material.bin Once completed, copy the signed file and the public key back onto the build system into the location specified in the mrsignerSignature and mrsignerPublicKey properties in the enclave signing configuration. Complete the build \u00b6 Invoke Gradle to complete the build. 1 ./gradlew build -PenclaveMode=\"Release\"","title":"Enclave signing"},{"location":"signing.html#enclave-signing","text":"Enclaves must be signed. With modern SGX servers you may self-sign your enclaves, but, a signature is still required. This section covers: Why signing is required Who can sign enclaves How to sign your enclaves","title":"Enclave signing"},{"location":"signing.html#why-is-signing-required","text":"Signing requirements are a part of the Intel SGX architecture. The enclave signature is used for two different purposes: Linking different enclave versions together into an upgrade path, so new enclaves can decrypt data stored by or sent to old enclaves. Authorising which enclaves can be executed on a host. Restricting which enclaves can launch on a host ensures that datacenter providers aren't hosting server processes they can't examine or turn over to law enforcement. It also makes it harder for people to write malware with un-debuggable cores, and is part of the privacy (anti-tracking) infrastructure in SGX. Using signatures to link binaries into a single upgrade path is the same technique used by Android and iOS to move permissions and stored data from old to new apps. Signing is also used to authorise which enclaves can start. By default Intel chips won't start an enclave unless it's signed by an Intel key, but this behaviour can be changed and on Azure (see \"Deploying to Azure\" ) enclaves can be self-signed. If you want to use older hardware getting whitelisted by Intel is free and can be done quickly. It's a similar process to getting an SSL certificate but using different tools. On Xeon E CPUs with Intel FLC support in the chipset, and a recent enough kernel driver, the owner can add their own whitelisting authorities via BIOS/UEFI firmware settings. This means they can replace the default \"must be approved by Intel\" launch control logic with their own (which may e.g. only allow their own enclaves, or may allow any self-signed enclave).","title":"Why is signing required?"},{"location":"signing.html#how-to-sign-your-enclaves","text":"","title":"How to sign your enclaves"},{"location":"signing.html#signing-keys-for-simulation-and-debug-enclaves","text":"It is not necessary to use a whitelisted signature for enclaves built in simulation and debug modes. However, it is still required that these enclaves are signed. Conclave supports the generation of a dummy key during the build process that can be used for signing simulation and debug enclaves.","title":"Signing keys for simulation and debug enclaves"},{"location":"signing.html#obtaining-a-signing-key-for-release-enclaves","text":"Firstly, get a commercial license . This is a lightweight process and doesn't cost anything or impose other requirements. Following the instructions provided on that page should allow you to get a signing key. Tip It's up to you whether to store the key in an HSM.","title":"Obtaining a signing key for release enclaves"},{"location":"signing.html#signing-configurations","text":"There are three different configurations available for signing enclaves using Conclave: Using a dummy key Using a private key Using an external process such as a signing service or HSM Dummy keys are only useful for signing simulation and debug enclaves. A release enclave signed with a dummy key will not be whitelisted on any platform so will not be allowed to load. A private key can be used to sign enclaves directly within the build process. The key must be accessible on the filesystem of the machine building the enclave. An external process is used when the signing key is not available on the machine building the enclave, or a manual or air-gapped process is required to sign the enclave. In this case the Conclave project is built in two steps. The first step generates the material to be signed. The second step provides the signed material to the Conclave build to continue and complete the build process.","title":"Signing configurations"},{"location":"signing.html#how-to-configure-signing-for-your-enclaves","text":"The signing method used by your enclaves is configured in the build.gradle file for your enclave project. You can specify different signing settings for simulation, debug and release in the same project. The signing configuration is specified inside the relevant enclave type inside the conclave configuration. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 conclave { simulation { // Simulation signing configuration using a dummy key signingType = dummyKey } debug { // Debug signing configuration using a private key signingType = privateKey signingKey = file ( \"../signing/sample_private_key.pem\" ) } release { // Release signing configuration using an external key signingType = externalKey mrsignerSignature = file ( \"../signing/signature.bin\" ) mrsignerPublicKey = file ( \"../signing/external_signing_public.pem\" ) signatureDate = new Date ( 1970 , 0 , 1 ) } } For simulation and debug enclaves signingType defaults to dummyKey so the configuration can be optionally omitted. Release enclaves default to having a signingType of externalKey so the configuration parameters for the external signing type must be specified. Alternatively the signingType can be changed to a different type. Note Changing the signing type of a release enclave to dummyKey will result in an enclave that cannot be used as it will never be whitelisted on an SGX platform. The configuration consists of a set of properties which depend on the signing type.","title":"How to configure signing for your enclaves"},{"location":"signing.html#dummy-key","text":"Property Value signingType Must be set to dummyKey . This is the default signing type for simulation and debug enclaves.","title":"Dummy Key"},{"location":"signing.html#private-key","text":"Property Value signingType Must be set to privateKey . signingKey The file that contains the private key to use when signing the enclave. This can be an absolute path or relative to the enclave project directory.","title":"Private Key"},{"location":"signing.html#external-key","text":"Property Value signingType Must be set to externalKey . This is the default signing type for release enclaves. signatureDate Specifies the date to be embedded in the material generated in the first stage of the external key signing process. signingMaterial The file that that Conclave will generate when preparing an enclave for signing in the first stage of the external key signing process. The resulting file needs to be signed by the external signing process. This can be an absolute path or relative to the enclave project directory. If this is omitted then the default filename of build/enclave/[Simulation|Debug|Release]/signing_material.bin is used mrsignerSignature Used in the second part of the external key process to specify the file containing the signature generated by the external signing process. This can be an absolute path or relative to the enclave project directory. mrsignerPublicKey Used in the second part of the external key process to specify the file containing the public part of the key that was used to externally sign the signing material. This can be an absolute path or relative to the enclave project directory.","title":"External Key"},{"location":"signing.html#generating-keys-for-signing-an-enclave","text":"When using privateKey or externalKey signing types you can create your own keys for testing or production:","title":"Generating keys for signing an enclave"},{"location":"signing.html#creating-an-rsa-private-key-suitable-for-signing-enclaves","text":"The generated key can be used to sign enclaves using the privateKey or externalKey signing types. When using the externalKey type you will need to generate the public key from the private key. 1 openssl genrsa -out my_private_key.pem -3 3072","title":"Creating an RSA private key suitable for signing enclaves"},{"location":"signing.html#creating-a-password-protected-rsa-private-key-suitable-for-signing-enclaves","text":"The generated key can only be used for the externalKey signing type as it prompts for a password during use. 1 openssl genrsa -aes128 -out my_private_key.pem -3 3072","title":"Creating a password protected RSA private key suitable for signing enclaves"},{"location":"signing.html#obtaining-the-public-key-from-a-private-key","text":"The public key is required for the externalKey signing type. 1 openssl rsa -in my_private_key.pem -pubout -out my_public_key.pem Note Make sure to generate the keys using openssl . Other tools, such as ssh-keygen , may not generate keys with properties required by Intel.","title":"Obtaining the public key from a private key"},{"location":"signing.html#building-a-signed-enclave","text":"Signing is performed automatically during the build process when using a dummy or private key. Additional steps are required when using an external key.","title":"Building a signed enclave"},{"location":"signing.html#add-the-prepareforsigning-task-to-the-host-buildgradle","text":"This is an optional but recommended step to create a more consistent calling convention for invoking Gradle. It adds a Gradle task that can be called regardless of the build type of the enclave. Add the following code to your host build.gradle file. This adds a new Gradle task that can be used to generate the material that will be signed by the external signing process. 1 2 3 tasks . register ( \"prepareForSigning\" ) { it . dependsOn ( \":enclave:generateEnclaveSigningMaterial\" + mode . capitalize ()) } The task works by using the mode Gradle property, which is set to one of simulation , debug or release depending on which enclave type is currently being built, to set a dependency on the relevant Conclave task that generates the signing material. The task makes the following two Gradle invocations equivalent: 1 2 ./gradlew prepareForSigning -PenclaveMode=\"Release\" ./gradlew :enclave:generateEnclaveSigningMaterialRelease See the tutorial and the hello-world sample in the Conclave SDK for an example of this configuration.","title":"Add the prepareForSigning task to the host build.gradle"},{"location":"signing.html#generate-the-signing-material","text":"Invoke Gradle to generate the files that need to be signed by the external signing process. 1 ./gradlew prepareForSigning -PenclaveMode=\"Release\" The output of this stage is a file that contains the material to be signed in enclave/build/enclave/Release/signing_material.bin","title":"Generate the signing material"},{"location":"signing.html#sign-the-material","text":"Perform the required steps to manually sign the file generated in the previous step. This might require copying the file onto a different platform or onto an HSM to generate the signed file. As an example, given a private key the following command can be used to sign the file: 1 openssl dgst -sha256 -out signature.bin -sign my_private_key.pem -keyform PEM signing_material.bin Once completed, copy the signed file and the public key back onto the build system into the location specified in the mrsignerSignature and mrsignerPublicKey properties in the enclave signing configuration.","title":"Sign the material"},{"location":"signing.html#complete-the-build","text":"Invoke Gradle to complete the build. 1 ./gradlew build -PenclaveMode=\"Release\"","title":"Complete the build"},{"location":"system-requirements.html","text":"System requirements \u00b6 Operating Systems \u00b6 We test building and running release-mode enclaves on Ubuntu 18.04 LTS Server x86-64. Running \u00b6 With some limitations, it's possible to run Conclave enclaves even if the host Operating System isn't Linux. The table below correlates the Operating System and the possible Conclave running modes . OS Mock Simulation Debug Release Linux macOS Windows : Using WSL or Docker with Linux. Building \u00b6 Although it is not possible to run all modes on every operating system, it is possible to develop and build enclaves on Linux, macOS and Windows. You can develop and test your enclaves using mock mode then build a simulation, debug or release mode enclave for deployment to a Linux platform for testing or production. In order to build a simulation, debug or release mode enclave on macOS or Windows (or to run a simulation mode enclave on macOS or Windows), Conclave needs access to a Linux build environment. This is automatically created during the build process using Docker. If you do not have Docker installed then the build will generate an error prompting you to install Docker on your system. Once Docker is installed and added to your PATH environment variable you can proceed to build Simulation, Debug or Release mode enclaves. Docker is not required if you are using a Linux system. JDKs \u00b6 We test building and running conclave applications using the latest OpenJDK 8 and 11, as of the most recent release. Enclave \u00b6 All code inside the enclave module must be compatible with Java 8. The Conclave gradle plugin will automatically compile the enclave module to Java 8 bytecode, regardless of the Java version used to build the rest of the application. Host and Client \u00b6 The host and client are normal Java libraries targeting Java 8, so all code outside the enclave module can be written and built with any Java version that is 8 or higher.","title":"System requirements"},{"location":"system-requirements.html#system-requirements","text":"","title":"System requirements"},{"location":"system-requirements.html#operating-systems","text":"We test building and running release-mode enclaves on Ubuntu 18.04 LTS Server x86-64.","title":"Operating Systems"},{"location":"system-requirements.html#running","text":"With some limitations, it's possible to run Conclave enclaves even if the host Operating System isn't Linux. The table below correlates the Operating System and the possible Conclave running modes . OS Mock Simulation Debug Release Linux macOS Windows : Using WSL or Docker with Linux.","title":"Running"},{"location":"system-requirements.html#building","text":"Although it is not possible to run all modes on every operating system, it is possible to develop and build enclaves on Linux, macOS and Windows. You can develop and test your enclaves using mock mode then build a simulation, debug or release mode enclave for deployment to a Linux platform for testing or production. In order to build a simulation, debug or release mode enclave on macOS or Windows (or to run a simulation mode enclave on macOS or Windows), Conclave needs access to a Linux build environment. This is automatically created during the build process using Docker. If you do not have Docker installed then the build will generate an error prompting you to install Docker on your system. Once Docker is installed and added to your PATH environment variable you can proceed to build Simulation, Debug or Release mode enclaves. Docker is not required if you are using a Linux system.","title":"Building"},{"location":"system-requirements.html#jdks","text":"We test building and running conclave applications using the latest OpenJDK 8 and 11, as of the most recent release.","title":"JDKs"},{"location":"system-requirements.html#enclave","text":"All code inside the enclave module must be compatible with Java 8. The Conclave gradle plugin will automatically compile the enclave module to Java 8 bytecode, regardless of the Java version used to build the rest of the application.","title":"Enclave"},{"location":"system-requirements.html#host-and-client","text":"The host and client are normal Java libraries targeting Java 8, so all code outside the enclave module can be written and built with any Java version that is 8 or higher.","title":"Host and Client"},{"location":"threads.html","text":"Using threads in enclaves \u00b6 Writing thread safe enclaves \u00b6 Writing a thread safe enclave is no different to writing any other thread safe code in Java, with one exception. Whilst all the same concurrency tools and utilities are available, you must opt-in to multi-threading. If you don't then all threads that enter the enclave will synchronize on the enclave object lock and execute serially. To opt in, override the getThreadSafe method and return true. This is a safety mechanism. It would be easy to write an enclave that isn't thread safe without thinking about it, perhaps because the additional performance isn't important. That would be hard to notice as anyone reading the code would be looking for the absence of something rather than its presence. The host could then multi-thread the enclave without it being prepared for that and corrupt your application-level data structures in ways that might be exploitable. When you return true from getThreadSafe you're asserting to Conclave that you've taken care to ensure your receiveFromUntrustedHost and receiveMail methods can handle concurrent execution, so it's safe for Conclave to stop locking the enclave itself. By requiring an opt-in it becomes visible to other developers and code reviewers, thus reminding them that the code needs to be thread safe. The enclave current context \u00b6 When your code is running inside an enclave the CPU maintains a lot of state about your code and potentially your private data. This information is all securely contained within the boundary of the SGX enclave: Code outside the enclave cannot peek into the enclave CPU state to try to see these secrets. This state information along with other private information such as the current stack contents is called the current context . Now, when a host application calls into an enclave, the host itself has a current context. We could feasibly use the host current context within the enclave as the host isn't hiding secrets from the enclave. However, when we are inside the enclave we may potentially put some secret information into the context structures which we don't want the host to know. When the enclave returns back to the host, how do we make sure that the current context does not contain any enclave secrets? Intel SGX solves this by maintaining a different version of the current context inside the enclave to the context outside the enclave. Whenever you make a call from the host to the enclave the host context is saved, and the context switches to an in-enclave current context that only the enclave can see. When the enclave exits back to the host, the enclave current context is saved in encrypted memory that only the enclave can see, and the host context is restored. Thus the secrets inside the enclave remain safe. Thread Control Structure and threads \u00b6 SGX stores the in-enclave current context in a Thread Control Structure (TCS) and related information in a Save State Area (SSA). These live in a portion of EPC memory which is the encrypted memory that only that exact instance of the enclave can access. When an enclave is first loaded, the SGX platform reserves encrypted memory for the enclave, including any space required for TCS's that will be used by the enclave. This forms part of the memory layout of the enclave that is fixed during the build of the enclave and signed so it cannot be modified once deployed. So, what if you want to execute multiple threads simultaneously inside the enclave? Each time the host calls into the enclave the CPU needs to switch the current context from the host to the enclave context. Therefore there must be enough TCS slots available in EPC memory to store the number of threads that will simultaneously be running inside the enclave. If the enclave runs out of slots then it will not allow the thread to enter the enclave. As mentioned above, the TCS slots form part of the signed memory layout and cannot be dynamically changed, therefore the number of TCS slots available to an enclave needs to be selected carefully by the developer using Conclave configuration . The setting is dependent on the requirements of the host/enclave with regards to threading. Why not just set an arbitrarily large value for the number of TCS slots? This is possible but you have to remember that each TCS, along with the related SSA and stack space takes an amount of EPC. In current generations of SGX hardware, EPC can be very limited. You don't want to use it all up on slots that may not be required. Tip Future SGX hardware will have the ability to dynamically create new threads, removing the limitation with fixed TCS slots. Conclave will be updated to support this when the hardware is available. How Conclave manages threads \u00b6 Conclave attempts to hide many of the complexities that arise due to the fixed number of TCS slots available at enclave runtime. It does this by arbitrating between threads that are contending for the limited TCS slots. Whenever the host calls into the enclave, a TCS slot is consumed. When the thread exits the enclave Conclave releases that TCS back to the pool allowing another thread to consume it. Conclave does not require the context to be maintained between external calls to the enclave. If the host attempts to call into the enclave when no TCS slots are available then the host thread is blocked until another thread exits the enclave and a TCS slot is freed. So, for example, this host code is perfectly acceptable to run on an enclave with 10 TCS slots: 1 2 3 4 5 6 7 int numThreads = 100 ; ExecutorService executor = Executors . newFixedThreadPool ( numThreads ); List < Callable < Object >> todo = new ArrayList < Callable < Object >> ( numThreads ); for ( int i = 0 ; i < numThreads ; ++ i ) { todo . add ( Executors . callable ( new EnclaveRunnable ())); } executor . invokeAll ( todo ); The code above will create 100 threads all trying to call into the enclave simultaneously. When the TCS slots are used up Conclave will block each host thread until a slot becomes available. Threads created inside the enclave \u00b6 When a thread is created in enclave code, rather than in the host, things work a bit differently. Enclaves themselves cannot create threads: SGX does not support creating threads inside of enclaves. When your code inside the enclave wants to create a thread we need to enlist the help of the host to create the thread for us. When a thread is created, the enclave calls out to the host and asks it to create a thread on the enclave's behalf. The host creates a new thread and tells it to call into the enclave. At the same time the original thread returns back to the enclave. This diagram illustrates this. The host consumes the first TCS slot (TCS1) and calls into the enclave. The enclave calls back out to the host on the same thread, still keeping TCS1 as the thread is still valid inside the enclave although the thread is currently executing on the host. The host creates a new thread and returns back to the enclave using TCS1. The new thread calls into the enclave using a new slot, TCS2. What happens if the new thread cannot start due to no TCS slots being available? In this case, in exactly the same way as for threads created outside the enclave, the new thread is blocked from calling into the enclave until a TCS slot becomes available. Handling deadlocks \u00b6 Arbitration between threads where the total thread number exceeds the number of TCS slots available introduces the possibility of deadlock, where a thread is blocked from being created because there are no slots available, but no slots will ever be available because they are all waiting for the new thread to do some work. Expanding on the example in the previous section, the diagram below shows an extreme situation where the enclave has been built to only support a single TCS slot. The host successfully grabs TCS1 and calls into the enclave. The enclave calls the host to create a new thread. This new thread then attempts to get allocate a new TCS slot to call back into the enclave but it is blocked until one is available. However, at the same time the original host thread returns to the enclave which then waits for the (blocked) worker thread to complete. In this situation the enclave is deadlocked. Conclave will detect this deadlock situation and will abort the enclave to alert the developer that the TCS slot count needs to be increased, or that the design of the enclave should be modified to prevent the deadlock. The deadlock detection is achieved by seeing that all threads are waiting for a fixed amount of time. This time defaults to 10 seconds but can be configured when the enclave is built . Tip Ensuring your enclave uses threads safely can be tricky. We recommend talking to R3 support for help if you are unsure how to configure your enclave correctly.","title":"Threads"},{"location":"threads.html#using-threads-in-enclaves","text":"","title":"Using threads in enclaves"},{"location":"threads.html#writing-thread-safe-enclaves","text":"Writing a thread safe enclave is no different to writing any other thread safe code in Java, with one exception. Whilst all the same concurrency tools and utilities are available, you must opt-in to multi-threading. If you don't then all threads that enter the enclave will synchronize on the enclave object lock and execute serially. To opt in, override the getThreadSafe method and return true. This is a safety mechanism. It would be easy to write an enclave that isn't thread safe without thinking about it, perhaps because the additional performance isn't important. That would be hard to notice as anyone reading the code would be looking for the absence of something rather than its presence. The host could then multi-thread the enclave without it being prepared for that and corrupt your application-level data structures in ways that might be exploitable. When you return true from getThreadSafe you're asserting to Conclave that you've taken care to ensure your receiveFromUntrustedHost and receiveMail methods can handle concurrent execution, so it's safe for Conclave to stop locking the enclave itself. By requiring an opt-in it becomes visible to other developers and code reviewers, thus reminding them that the code needs to be thread safe.","title":"Writing thread safe enclaves"},{"location":"threads.html#the-enclave-current-context","text":"When your code is running inside an enclave the CPU maintains a lot of state about your code and potentially your private data. This information is all securely contained within the boundary of the SGX enclave: Code outside the enclave cannot peek into the enclave CPU state to try to see these secrets. This state information along with other private information such as the current stack contents is called the current context . Now, when a host application calls into an enclave, the host itself has a current context. We could feasibly use the host current context within the enclave as the host isn't hiding secrets from the enclave. However, when we are inside the enclave we may potentially put some secret information into the context structures which we don't want the host to know. When the enclave returns back to the host, how do we make sure that the current context does not contain any enclave secrets? Intel SGX solves this by maintaining a different version of the current context inside the enclave to the context outside the enclave. Whenever you make a call from the host to the enclave the host context is saved, and the context switches to an in-enclave current context that only the enclave can see. When the enclave exits back to the host, the enclave current context is saved in encrypted memory that only the enclave can see, and the host context is restored. Thus the secrets inside the enclave remain safe.","title":"The enclave current context"},{"location":"threads.html#thread-control-structure-and-threads","text":"SGX stores the in-enclave current context in a Thread Control Structure (TCS) and related information in a Save State Area (SSA). These live in a portion of EPC memory which is the encrypted memory that only that exact instance of the enclave can access. When an enclave is first loaded, the SGX platform reserves encrypted memory for the enclave, including any space required for TCS's that will be used by the enclave. This forms part of the memory layout of the enclave that is fixed during the build of the enclave and signed so it cannot be modified once deployed. So, what if you want to execute multiple threads simultaneously inside the enclave? Each time the host calls into the enclave the CPU needs to switch the current context from the host to the enclave context. Therefore there must be enough TCS slots available in EPC memory to store the number of threads that will simultaneously be running inside the enclave. If the enclave runs out of slots then it will not allow the thread to enter the enclave. As mentioned above, the TCS slots form part of the signed memory layout and cannot be dynamically changed, therefore the number of TCS slots available to an enclave needs to be selected carefully by the developer using Conclave configuration . The setting is dependent on the requirements of the host/enclave with regards to threading. Why not just set an arbitrarily large value for the number of TCS slots? This is possible but you have to remember that each TCS, along with the related SSA and stack space takes an amount of EPC. In current generations of SGX hardware, EPC can be very limited. You don't want to use it all up on slots that may not be required. Tip Future SGX hardware will have the ability to dynamically create new threads, removing the limitation with fixed TCS slots. Conclave will be updated to support this when the hardware is available.","title":"Thread Control Structure and threads"},{"location":"threads.html#how-conclave-manages-threads","text":"Conclave attempts to hide many of the complexities that arise due to the fixed number of TCS slots available at enclave runtime. It does this by arbitrating between threads that are contending for the limited TCS slots. Whenever the host calls into the enclave, a TCS slot is consumed. When the thread exits the enclave Conclave releases that TCS back to the pool allowing another thread to consume it. Conclave does not require the context to be maintained between external calls to the enclave. If the host attempts to call into the enclave when no TCS slots are available then the host thread is blocked until another thread exits the enclave and a TCS slot is freed. So, for example, this host code is perfectly acceptable to run on an enclave with 10 TCS slots: 1 2 3 4 5 6 7 int numThreads = 100 ; ExecutorService executor = Executors . newFixedThreadPool ( numThreads ); List < Callable < Object >> todo = new ArrayList < Callable < Object >> ( numThreads ); for ( int i = 0 ; i < numThreads ; ++ i ) { todo . add ( Executors . callable ( new EnclaveRunnable ())); } executor . invokeAll ( todo ); The code above will create 100 threads all trying to call into the enclave simultaneously. When the TCS slots are used up Conclave will block each host thread until a slot becomes available.","title":"How Conclave manages threads"},{"location":"threads.html#threads-created-inside-the-enclave","text":"When a thread is created in enclave code, rather than in the host, things work a bit differently. Enclaves themselves cannot create threads: SGX does not support creating threads inside of enclaves. When your code inside the enclave wants to create a thread we need to enlist the help of the host to create the thread for us. When a thread is created, the enclave calls out to the host and asks it to create a thread on the enclave's behalf. The host creates a new thread and tells it to call into the enclave. At the same time the original thread returns back to the enclave. This diagram illustrates this. The host consumes the first TCS slot (TCS1) and calls into the enclave. The enclave calls back out to the host on the same thread, still keeping TCS1 as the thread is still valid inside the enclave although the thread is currently executing on the host. The host creates a new thread and returns back to the enclave using TCS1. The new thread calls into the enclave using a new slot, TCS2. What happens if the new thread cannot start due to no TCS slots being available? In this case, in exactly the same way as for threads created outside the enclave, the new thread is blocked from calling into the enclave until a TCS slot becomes available.","title":"Threads created inside the enclave"},{"location":"threads.html#handling-deadlocks","text":"Arbitration between threads where the total thread number exceeds the number of TCS slots available introduces the possibility of deadlock, where a thread is blocked from being created because there are no slots available, but no slots will ever be available because they are all waiting for the new thread to do some work. Expanding on the example in the previous section, the diagram below shows an extreme situation where the enclave has been built to only support a single TCS slot. The host successfully grabs TCS1 and calls into the enclave. The enclave calls the host to create a new thread. This new thread then attempts to get allocate a new TCS slot to call back into the enclave but it is blocked until one is available. However, at the same time the original host thread returns to the enclave which then waits for the (blocked) worker thread to complete. In this situation the enclave is deadlocked. Conclave will detect this deadlock situation and will abort the enclave to alert the developer that the TCS slot count needs to be increased, or that the design of the enclave should be modified to prevent the deadlock. The deadlock detection is achieved by seeing that all threads are waiting for a fixed amount of time. This time defaults to 10 seconds but can be configured when the enclave is built . Tip Ensuring your enclave uses threads safely can be tricky. We recommend talking to R3 support for help if you are unsure how to configure your enclave correctly.","title":"Handling deadlocks"},{"location":"tutorial.html","text":"Compiling and Running your First Enclave \u00b6 Important You need the Conclave SDK. If you don't have it, grab a copy from conclave.net . This tutorial assumes you've read and understood the conceptual overview and architecture overview . You can find a sample app in the hello-world directory of your SDK. You can use this app as a template for your own if you want a quick start. We will cover: How to set up your machine. How to compile and run the sample app. How to write the sample app . Enclave modes \u00b6 SGX enclaves can be used in one of four modes, in order of increasing realism: Mock : your enclave class is created in the host JVM and no native or SGX specific code is used. This provides a pure Java development experience. Simulation : an enclave is compiled to native machine code and loaded, but SGX hardware doesn't need to be present. Debug : the enclave is loaded using SGX hardware and drivers, but with a back door that allows debugger access to the memory. Release : the enclave is loaded using SGX hardware and drivers, and there's no back door. This is the real deal. Only release mode locks out the host and provides the standard SGX security model. Setting up your machine \u00b6 For this tutorial you will need Java 8 or 11 (your choice). If you use IntelliJ IDEA the IDE can download both a JDK and the Gradle build system for you, so you don't need anything to get started except the IDE itself (the free Community Edition works fine). Currently, we support developing enclaves on Windows, macOS and Linux . However, there are a few platform specific differences to be aware of. Firstly, you need a Linux environment to build and execute enclaves, including for native testing. This is because enclaves are Linux shared libraries with special extensions. If you are not using Linux you will need to install Docker. On Windows and macOS, Conclave uses Docker to build the enclave in a Linux environment. Instructions are provided below to show you how to use Docker on Windows and macOS to run your entire application in \"simulation mode\". Alternatively, for day to day development building an enclave in mock mode is plenty sufficient and allows you to debug into enclave calls as well. Compiling a real enclave is only needed for integration testing against the embedded JVM, or real deployment. Secondly, when building enclaves Conclave internally uses the C++ compiler gcc. This is automatically installed when building on Windows and macOS but on Linux you need to make sure you have installed gcc yourself. If your build system uses the aptitude package manager then you can install everything you need with this command: 1 sudo apt-get install build-essential Enclaves can run in simulation mode without requiring any special setup of Linux or SGX capable hardware. However you of course get no hardware protections. To run against real SGX hardware you must perform some additional machine setup . Compiling the sample enclave \u00b6 Step 1: Import the project Step 2: Look at the Conclave SDK's top level directory Step 3: When notified that there's a Gradle build script, click \"hello-world\" to import the project. Step 4: Double-click on :host:assemble . This is the second highlighted assemble in the screenshot of Intellij's Gradle window below. Voila! You have just built your first enclave. Now explore the build folder. As normal with Gradle, the assemble task has bundled the program into a zip, with startup scripts. These scripts are nothing special - they just set up the classpath. You could also e.g. make a fat JAR if you want. Alternatively you can build you application from the command line as described in the next section. Selecting your mode \u00b6 In the sample app, the assemble task will build the app for simulation mode by default. Use the -PenclaveMode argument to configure the mode. If you are using SGX hardware, you can build the app for debug mode with the command: 1 ./gradlew host:assemble -PenclaveMode=debug If working from inside IntelliJ, start the assemble task for the host project from the tree on the right hand side, and then edit the created run config. Add the -PenclaveMode=debug flag to the arguments section of the run config. If you want to debug into the enclave, or you are running on an OS other than Linux then you can build the app for mock mode with the command: 1 ./gradlew host:assemble -PenclaveMode=mock For release mode , the sample app has been configured (in the build.gradle of the enclave subproject) to use external signing. This means it must be built in multiple stages: Note See Enclave signing for more information. 1 2 3 4 5 6 7 8 // Firstly, build the signing material: ./gradlew prepareForSigning -PenclaveMode = release // Generate a signature from the signing material. The password for the sample external key is '12345' openssl dgst -sha256 -out signing/signature.bin -sign signing/external_signing_private.pem -keyform PEM enclave/build/enclave/Release/signing_material.bin // Finally build the signed enclave: ./gradlew build -PenclaveMode = \"release\" Got this far? Join the community! \u00b6 There's a public mailing list for discussion of using Conclave and we also welcome general SGX talk. A Slack channel is available where you can find the development team during UK office hours (GMT 0900-1700). Join conclave-discuss@groups.io Email us directly Slack us in #conclave Confused about various Gradle commands ( build / assemble / installDist / run )? Here is an explanation. \u00b6 build will build a client, an enclave and a host. This command will also run unit tests (if there are any) for the corresponding components. The build results will go to client/build/distribution/client.tar (or .zip) for the client, and to host/build/distribution/host.tar (or .zip) for the host (an enclave is bundled with the host). These archives contain everything required to run your app (except the JRE) and can be shipped to the customer as-is. 1 ./gradlew build assemble will do the same job as build except that it won't run unit tests. You can assemble all at once or do it separately for the client and for the host. 1 ./gradlew assemble or 1 2 ./gradlew :host:assemble ./gradlew :client:assemble installDist will behave similarly to assemble except that unlike build or assemble , it won't produce the archive files. Instead, it will create a host/build/install and client/build/install directories, whose contents are effectively unpacked host.tar and/or client.tar files. 1 ./gradlew installDist or 1 2 ./gradlew :host:installDist ./gradlew :client:installDist On Linux you can run your app in two slightly different ways - standalone or using Gradle: Standalone 1 2 3 ./gradlew host:installDist cd host/build/install ./host/bin/host 1 2 3 ./gradlew client:installDist cd client/build/install ./client/bin/client Using Gradle 1 ./gradlew :host:run 1 ./gradlew :client:run --args = \"Reverse me\" Note The run task is a part of the Application plugin . Running the host \u00b6 Linux Just run the host app like any app - no special customisation or setup is required with Conclave! Here we will run a shell script generated by Gradle that starts the JVM: 1 2 3 ./gradlew host:installDist cd host/build/install ./host/bin/host Gradle can also create .tar.gz files suitable for copying to the Linux host, fat JARs, WAR files for deployment into servlet containers and various other ways to deploy your app. Note At this time using the JPMS tool jlink is not tested. macOS On macOS there is a script that lets you run Gradle (and by extension anything it runs) inside a Linux environment based on the Conclave build container. It wraps Docker and makes it simpler to work with. Just use the ../scripts/container-gradle script as a replacement for gradlew . You might want to add it to your $PATH variable. To run the host, use this command: 1 ../scripts/container-gradle host:run For more information see the Container Gradle page. Tip Don't be surprised if the application gets built again from scratch! We do this to ensure the build and runtime environments match. Windows On Windows you can still test locally in simulation mode using a Docker container. However you may need to configure mounts and other parameters yourself. Refer to the scripts/container-gradle file to see how this is done on macOS. Windows PowerShell 1 2 gradlew.bat host:installDist docker run -it --rm -p 9999:9999 -v ${PWD}:/project -w /project conclave-build /bin/bash This will build the app on your Windows machine, then mount the app into a Linux container and get a shell. Next, run the app from within the container: 1 2 cd host/build/install ./host/bin/host Tip Please consult the Docker reference manual to understand what switches you can pass to the docker run command. If your Linux machine (or container) doesn't have SGX, you should see something like the following. Don't worry, you can still complete the tutorial because we are using simulation mode : 1 This platform does not support hardware enclaves: SGX_DISABLED_UNSUPPORTED_CPU: SGX is not supported by the CPU in this system You can proceed to Running the client when you see the following: 1 Listening on port 9999. Use the client app to send strings for reversal. IntelliJ configuration \u00b6 If you are using IntelliJ, you may want to create a launch configuration to incorporate the build and deploy stages. If using the container-gradle script on macOS, IntelliJ does expect the command to launch Gradle to be called gradle or gradlew . What you can do is rename gradlew to something else, then copy the scripts/container-gradle script to be called gradlew in your project root. Finally, edit the last line of the script to start the renamed script. Therefore IntelliJ will run the container-gradle script whilst thinking it's running normal Gradle. Running the client \u00b6 The host has opened up a TCP port which will now listen for requests from remote clients. So, let's run the client app: Linux / macOS 1 ./gradlew client:run --args = \"Reverse me\" Windows 1 gradlew.bat client:run --args = \"Reverse me\" Tip Docker is only required to run the host on macOS or windows. The client can be run without Docker. The host will load the enclave, obtain its remote attestation (the EnclaveInstanceInfo object), print it out, and ask the enclave to reverse a string. You should see the following output from the host: 1 2 3 4 5 6 7 8 9 10 11 12 Remote attestation for enclave D4FFB9E1539148401529035C202A9904D7562C83B2A95E33E3B639BE8693E87B: - Mode: SIMULATION - Code signing key hash: 4924CA3A9C8241A3C0AA1A24A407AA86401D2B79FA9FF84932DA798A942166D4 - Public signing key: 302A300506032B657003210007C159388855F2ECD0B34C36C31F00ED276D144F1DC077D294F3F28F542E98B8 - Public encryption key: 4D92642BF5C7B93DDB912D809230DE3BFE09531F9095617BF3E90D720F84E151 - Product ID: 1 - Revocation level: 0 Assessed security level at 2021-01-26T10:31:02.974Z is INSECURE - Enclave is running in simulation mode. Reversing Hello World!: !dlroW olleH The client will connect to the host, download the EnclaveInstanceInfo , check it, print it out, and then send an encrypted string to reverse. The host will deliver this encrypted string to the enclave, and the enclave will send back an encrypted response as a PostMail command. The host will extract an encrypted data from the PostMail command and send it to the client. You should see the following output from the client: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Attempting to connect to localhost:9999 Connected to Remote attestation for enclave D4FFB9E1539148401529035C202A9904D7562C83B2A95E33E3B639BE8693E87B: - Mode: SIMULATION - Code signing key hash: 4924CA3A9C8241A3C0AA1A24A407AA86401D2B79FA9FF84932DA798A942166D4 - Public signing key: 302A300506032B657003210007C159388855F2ECD0B34C36C31F00ED276D144F1DC077D294F3F28F542E98B8 - Public encryption key: 4D92642BF5C7B93DDB912D809230DE3BFE09531F9095617BF3E90D720F84E151 - Product ID: 1 - Revocation level: 0 Assessed security level at 2021-01-26T10:31:02.974Z is INSECURE - Enclave is running in simulation mode. Sending the encrypted mail to the host. Reading reply mail of length 170 bytes. Enclave reversed 'Reverse me' and gave us the answer 'em esreveR' Finally, the host and the client will exit. Try this: Linux / macOS 1 ./gradlew client:run --args = \"aibohphobia\" Windows 1 gradlew.bat client:run --args = \"aibohphobia\" Tip Aibohphobia is the fear of palindromes. If you get stuck join the mailing list and ask for help!","title":"Running your first enclave"},{"location":"tutorial.html#compiling-and-running-your-first-enclave","text":"Important You need the Conclave SDK. If you don't have it, grab a copy from conclave.net . This tutorial assumes you've read and understood the conceptual overview and architecture overview . You can find a sample app in the hello-world directory of your SDK. You can use this app as a template for your own if you want a quick start. We will cover: How to set up your machine. How to compile and run the sample app. How to write the sample app .","title":"Compiling and Running your First Enclave"},{"location":"tutorial.html#enclave-modes","text":"SGX enclaves can be used in one of four modes, in order of increasing realism: Mock : your enclave class is created in the host JVM and no native or SGX specific code is used. This provides a pure Java development experience. Simulation : an enclave is compiled to native machine code and loaded, but SGX hardware doesn't need to be present. Debug : the enclave is loaded using SGX hardware and drivers, but with a back door that allows debugger access to the memory. Release : the enclave is loaded using SGX hardware and drivers, and there's no back door. This is the real deal. Only release mode locks out the host and provides the standard SGX security model.","title":"Enclave modes"},{"location":"tutorial.html#setting-up-your-machine","text":"For this tutorial you will need Java 8 or 11 (your choice). If you use IntelliJ IDEA the IDE can download both a JDK and the Gradle build system for you, so you don't need anything to get started except the IDE itself (the free Community Edition works fine). Currently, we support developing enclaves on Windows, macOS and Linux . However, there are a few platform specific differences to be aware of. Firstly, you need a Linux environment to build and execute enclaves, including for native testing. This is because enclaves are Linux shared libraries with special extensions. If you are not using Linux you will need to install Docker. On Windows and macOS, Conclave uses Docker to build the enclave in a Linux environment. Instructions are provided below to show you how to use Docker on Windows and macOS to run your entire application in \"simulation mode\". Alternatively, for day to day development building an enclave in mock mode is plenty sufficient and allows you to debug into enclave calls as well. Compiling a real enclave is only needed for integration testing against the embedded JVM, or real deployment. Secondly, when building enclaves Conclave internally uses the C++ compiler gcc. This is automatically installed when building on Windows and macOS but on Linux you need to make sure you have installed gcc yourself. If your build system uses the aptitude package manager then you can install everything you need with this command: 1 sudo apt-get install build-essential Enclaves can run in simulation mode without requiring any special setup of Linux or SGX capable hardware. However you of course get no hardware protections. To run against real SGX hardware you must perform some additional machine setup .","title":"Setting up your machine"},{"location":"tutorial.html#compiling-the-sample-enclave","text":"Step 1: Import the project Step 2: Look at the Conclave SDK's top level directory Step 3: When notified that there's a Gradle build script, click \"hello-world\" to import the project. Step 4: Double-click on :host:assemble . This is the second highlighted assemble in the screenshot of Intellij's Gradle window below. Voila! You have just built your first enclave. Now explore the build folder. As normal with Gradle, the assemble task has bundled the program into a zip, with startup scripts. These scripts are nothing special - they just set up the classpath. You could also e.g. make a fat JAR if you want. Alternatively you can build you application from the command line as described in the next section.","title":"Compiling the sample enclave"},{"location":"tutorial.html#selecting-your-mode","text":"In the sample app, the assemble task will build the app for simulation mode by default. Use the -PenclaveMode argument to configure the mode. If you are using SGX hardware, you can build the app for debug mode with the command: 1 ./gradlew host:assemble -PenclaveMode=debug If working from inside IntelliJ, start the assemble task for the host project from the tree on the right hand side, and then edit the created run config. Add the -PenclaveMode=debug flag to the arguments section of the run config. If you want to debug into the enclave, or you are running on an OS other than Linux then you can build the app for mock mode with the command: 1 ./gradlew host:assemble -PenclaveMode=mock For release mode , the sample app has been configured (in the build.gradle of the enclave subproject) to use external signing. This means it must be built in multiple stages: Note See Enclave signing for more information. 1 2 3 4 5 6 7 8 // Firstly, build the signing material: ./gradlew prepareForSigning -PenclaveMode = release // Generate a signature from the signing material. The password for the sample external key is '12345' openssl dgst -sha256 -out signing/signature.bin -sign signing/external_signing_private.pem -keyform PEM enclave/build/enclave/Release/signing_material.bin // Finally build the signed enclave: ./gradlew build -PenclaveMode = \"release\"","title":"Selecting your mode"},{"location":"tutorial.html#got-this-far-join-the-community","text":"There's a public mailing list for discussion of using Conclave and we also welcome general SGX talk. A Slack channel is available where you can find the development team during UK office hours (GMT 0900-1700). Join conclave-discuss@groups.io Email us directly Slack us in #conclave","title":"Got this far? Join the community!"},{"location":"tutorial.html#confused-about-various-gradle-commands-buildassembleinstalldistrun-here-is-an-explanation","text":"build will build a client, an enclave and a host. This command will also run unit tests (if there are any) for the corresponding components. The build results will go to client/build/distribution/client.tar (or .zip) for the client, and to host/build/distribution/host.tar (or .zip) for the host (an enclave is bundled with the host). These archives contain everything required to run your app (except the JRE) and can be shipped to the customer as-is. 1 ./gradlew build assemble will do the same job as build except that it won't run unit tests. You can assemble all at once or do it separately for the client and for the host. 1 ./gradlew assemble or 1 2 ./gradlew :host:assemble ./gradlew :client:assemble installDist will behave similarly to assemble except that unlike build or assemble , it won't produce the archive files. Instead, it will create a host/build/install and client/build/install directories, whose contents are effectively unpacked host.tar and/or client.tar files. 1 ./gradlew installDist or 1 2 ./gradlew :host:installDist ./gradlew :client:installDist On Linux you can run your app in two slightly different ways - standalone or using Gradle: Standalone 1 2 3 ./gradlew host:installDist cd host/build/install ./host/bin/host 1 2 3 ./gradlew client:installDist cd client/build/install ./client/bin/client Using Gradle 1 ./gradlew :host:run 1 ./gradlew :client:run --args = \"Reverse me\" Note The run task is a part of the Application plugin .","title":"Confused about various Gradle commands (build/assemble/installDist/run)? Here is an explanation."},{"location":"tutorial.html#running-the-host","text":"Linux Just run the host app like any app - no special customisation or setup is required with Conclave! Here we will run a shell script generated by Gradle that starts the JVM: 1 2 3 ./gradlew host:installDist cd host/build/install ./host/bin/host Gradle can also create .tar.gz files suitable for copying to the Linux host, fat JARs, WAR files for deployment into servlet containers and various other ways to deploy your app. Note At this time using the JPMS tool jlink is not tested. macOS On macOS there is a script that lets you run Gradle (and by extension anything it runs) inside a Linux environment based on the Conclave build container. It wraps Docker and makes it simpler to work with. Just use the ../scripts/container-gradle script as a replacement for gradlew . You might want to add it to your $PATH variable. To run the host, use this command: 1 ../scripts/container-gradle host:run For more information see the Container Gradle page. Tip Don't be surprised if the application gets built again from scratch! We do this to ensure the build and runtime environments match. Windows On Windows you can still test locally in simulation mode using a Docker container. However you may need to configure mounts and other parameters yourself. Refer to the scripts/container-gradle file to see how this is done on macOS. Windows PowerShell 1 2 gradlew.bat host:installDist docker run -it --rm -p 9999:9999 -v ${PWD}:/project -w /project conclave-build /bin/bash This will build the app on your Windows machine, then mount the app into a Linux container and get a shell. Next, run the app from within the container: 1 2 cd host/build/install ./host/bin/host Tip Please consult the Docker reference manual to understand what switches you can pass to the docker run command. If your Linux machine (or container) doesn't have SGX, you should see something like the following. Don't worry, you can still complete the tutorial because we are using simulation mode : 1 This platform does not support hardware enclaves: SGX_DISABLED_UNSUPPORTED_CPU: SGX is not supported by the CPU in this system You can proceed to Running the client when you see the following: 1 Listening on port 9999. Use the client app to send strings for reversal.","title":"Running the host"},{"location":"tutorial.html#intellij-configuration","text":"If you are using IntelliJ, you may want to create a launch configuration to incorporate the build and deploy stages. If using the container-gradle script on macOS, IntelliJ does expect the command to launch Gradle to be called gradle or gradlew . What you can do is rename gradlew to something else, then copy the scripts/container-gradle script to be called gradlew in your project root. Finally, edit the last line of the script to start the renamed script. Therefore IntelliJ will run the container-gradle script whilst thinking it's running normal Gradle.","title":"IntelliJ configuration"},{"location":"tutorial.html#running-the-client","text":"The host has opened up a TCP port which will now listen for requests from remote clients. So, let's run the client app: Linux / macOS 1 ./gradlew client:run --args = \"Reverse me\" Windows 1 gradlew.bat client:run --args = \"Reverse me\" Tip Docker is only required to run the host on macOS or windows. The client can be run without Docker. The host will load the enclave, obtain its remote attestation (the EnclaveInstanceInfo object), print it out, and ask the enclave to reverse a string. You should see the following output from the host: 1 2 3 4 5 6 7 8 9 10 11 12 Remote attestation for enclave D4FFB9E1539148401529035C202A9904D7562C83B2A95E33E3B639BE8693E87B: - Mode: SIMULATION - Code signing key hash: 4924CA3A9C8241A3C0AA1A24A407AA86401D2B79FA9FF84932DA798A942166D4 - Public signing key: 302A300506032B657003210007C159388855F2ECD0B34C36C31F00ED276D144F1DC077D294F3F28F542E98B8 - Public encryption key: 4D92642BF5C7B93DDB912D809230DE3BFE09531F9095617BF3E90D720F84E151 - Product ID: 1 - Revocation level: 0 Assessed security level at 2021-01-26T10:31:02.974Z is INSECURE - Enclave is running in simulation mode. Reversing Hello World!: !dlroW olleH The client will connect to the host, download the EnclaveInstanceInfo , check it, print it out, and then send an encrypted string to reverse. The host will deliver this encrypted string to the enclave, and the enclave will send back an encrypted response as a PostMail command. The host will extract an encrypted data from the PostMail command and send it to the client. You should see the following output from the client: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Attempting to connect to localhost:9999 Connected to Remote attestation for enclave D4FFB9E1539148401529035C202A9904D7562C83B2A95E33E3B639BE8693E87B: - Mode: SIMULATION - Code signing key hash: 4924CA3A9C8241A3C0AA1A24A407AA86401D2B79FA9FF84932DA798A942166D4 - Public signing key: 302A300506032B657003210007C159388855F2ECD0B34C36C31F00ED276D144F1DC077D294F3F28F542E98B8 - Public encryption key: 4D92642BF5C7B93DDB912D809230DE3BFE09531F9095617BF3E90D720F84E151 - Product ID: 1 - Revocation level: 0 Assessed security level at 2021-01-26T10:31:02.974Z is INSECURE - Enclave is running in simulation mode. Sending the encrypted mail to the host. Reading reply mail of length 170 bytes. Enclave reversed 'Reverse me' and gave us the answer 'em esreveR' Finally, the host and the client will exit. Try this: Linux / macOS 1 ./gradlew client:run --args = \"aibohphobia\" Windows 1 gradlew.bat client:run --args = \"aibohphobia\" Tip Aibohphobia is the fear of palindromes. If you get stuck join the mailing list and ask for help!","title":"Running the client"},{"location":"writing-cordapps.html","text":"Writing the sample CorDapp \u00b6 Corda is R3's open source enterprise blockchain platform. You can think of it as a peer to peer database in which user-written apps can be installed. Enclaves can be used inside \"CorDapps\" to provide multi-party computation over the peer to peer network. Or look at it the other way around: Corda can provide communication and identity services to your enclave. The sample CorDapp builds on the hello-world sample allowing nodes to perform the reverse string task between two nodes, one of which loads the enclave. Smart contracts aren't used in this sample, only flows are needed. The sample divides the code into several pieces. The packages that don't have samples in the name are intended to be copy/pasted into your own code. They'll be turned into a full API in future. The code expects a DCAP capable host, but if you want to use EPID you can edit the enclave startup code to make it use your Intel API keys. Important To understand this tutorial you are expected to have read both the Conclave Hello World tutorial and the Corda tutorials already. Configure your workflow CorDapp module \u00b6 Both Conclave and Corda rely on Gradle build system plugins. Follow the instructions in the hello world tutorial to configure Gradle to include an enclave mode. Add the host libraries to your Corda workflows module: 1 2 3 4 5 6 7 8 9 10 11 12 dependencies { compile project(path: \":enclave\", configuration: mode) compile \"com.r3.conclave:conclave-host:$conclaveVersion\" compile \"com.r3.conclave:conclave-client:$conclaveVersion\" compile \"com.r3.conclave:conclave-common:$conclaveVersion\" compile \"com.r3.conclave:conclave-mail:$conclaveVersion\" // Corda dependencies. cordaCompile \"$corda_core_release_group:corda-core:$corda_core_release_version\" cordaRuntime \"$corda_release_group:corda:$corda_release_version\" testCompile \"$corda_release_group:corda-node-driver:$corda_release_version\" } Important You must use Gradle's compile configurations for the host dependencies. If you use implementation then you will get errors about missing classes when the node starts up, due to issues with fat JARing. The host dependencies section should look like above. Write an enclave host service \u00b6 The enclave will be loaded into a service object. This singleton will be available to flows for later usage, and lets us integrate with the lifecycle of the node. The sample project contains a helper class called EnclaveHostService that you can copy into your project and sub-class. At the moment it isn't a complete or supported API so you may need to edit it to make it work for your use case. 1 2 3 4 5 6 @CordaService public class ReverseEnclaveService extends EnclaveHostService { public ReverseEnclaveService ( @NotNull AppServiceHub serviceHub ) { super ( \"com.r3.conclave.cordapp.sample.enclave.ReverseEnclave\" ); } } This will make a best effort to enable SGX support on the host if necessary, then it loads the sample ReverseEnclave class (which expands on the one already seen in the hello world tutorial). The EnclaveHostService class exposes methods to send and receive mail with the enclave, in a way that lets flows suspend waiting for the enclave to deliver mail. In the next section about relaying a mail from a flow to the Enclave , the above class is used as a parameter to initiate the responder flow that ensures the host service is started. Relaying mail from a flow to the Enclave \u00b6 We've already seen how to create a new subclass of Enclave and how to receive and post mail in the enclave in the hello-world tutorial, and in the coming sections we'll see how some of this boilerplate has been wrapped into an API to simplify setting up secure flows and exchange secure messages between parties. In this tutorial, reversing a string involves two parties: one is the initiator that sends the secret string to reverse, the other is the responder that reverses the string inside the enclave. To implement this we will need a flow used by clients, and a 'responder' flow used by the host node. Here's the responder flow to get the enclave host service up and running, get the enclave attestation and send it to the other party for verification, get, verify and acknowledge the other party's encrypted identity, get the other party's encrypted mail with the string to reverse, deliver it to the enclave, and retrieve the enclave encrypted mail to send to the other party for decryption. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // We start with a few lines of boilerplate: read the Corda tutorials if you aren't sure what these are about. @InitiatedBy ( ReverseFlow . class ) public class ReverseFlowResponder extends FlowLogic < Void > { // private variable private final FlowSession counterpartySession ; // Constructor public ReverseFlowResponder ( FlowSession counterpartySession ) { this . counterpartySession = counterpartySession ; } @Suspendable @Override public Void call () throws FlowException { EnclaveFlowResponder session = EnclaveClientHelper . initiateResponderFlow ( this , counterpartySession , ReverseEnclaveService . class ); session . relayMessageToFromEnclave (); return null ; } } Looking into the responder's flow initiation, we see that this side of the flow starts by ensuring a specific instance of the EnclaveHostService is started and sending the remote attestation. Typically, an interaction with the enclave should start this way, although the attestation may be cached if such logic is required. The flow responder expects to receive an identity during the initialization. An empty identity message can be sent if the party prefers to remain anonymous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Suspendable @Throws ( FlowException :: class ) @JvmStatic @JvmOverloads fun < T : EnclaveHostService > initiateResponderFlow ( flow : FlowLogic <*> , counterPartySession : FlowSession , serviceType : Class < T > ): EnclaveFlowResponder { // Start an instance of the enclave hosting service val host = flow . serviceHub . cordaService ( serviceType ) // Send the other party the enclave identity (remote attestation) for verification. counterPartySession . send ( host . attestationBytes ) val instance = EnclaveFlowResponder ( flow , counterPartySession , host ) // Relay the initial identity message to the enclave and relay the response back instance . relayMessageToFromEnclave () return instance } The EnclaveFlowResponder implements a simple request/response type protocol that receives an encrypted byte array and uses the deliverAndPickUpMail method of the EnclaveHostService class. This returns an operation that can be passed to await . The flow will suspend (thus freeing up its thread), potentially for a long period. There is no requirement that the enclave reply immediately. It can return from processing the delivered mail without replying. When it does choose to reply, the flow will be re-awakened and the encrypted mail returned to the other side. 1 2 3 4 5 6 7 8 9 10 11 @Suspendable @Throws ( FlowException :: class ) fun relayMessageToFromEnclave () { // Other party sends us an encrypted mail. val encryptedMail = session . receive ( ByteArray :: class . java ). unwrap { it } // Deliver and wait for the enclave to reply. The flow will suspend until the enclave chooses to deliver a mail // to this flow, which might not be immediately. val encryptedReply : ByteArray = flow . await ( host . deliverAndPickUpMail ( flow , encryptedMail )) // Send back to the other party the encrypted enclave's reply session . send ( encryptedReply ) } Important Although the Corda flow framework has built in support for it, this sample code does not handle node restarts. And here's the initiator flow that initiates a session with the responder party, get the enclave attestation, validate it, build and send a verifiable identity for the enclave to validate, send the encrypted mail with the string to reverse and read and decrypt the enclave's response. Keep in mind that a verifiable identity is only sent to the enclave if the anonymous property is set to false. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @InitiatingFlow @StartableByRPC public class ReverseFlow extends FlowLogic < String > { private final Party receiver ; private final String message ; private final String constraint ; private final Boolean anonymous ; public ReverseFlow ( Party receiver , String message , String constraint ) { this ( receiver , message , constraint , false ); } public ReverseFlow ( Party receiver , String message , String constraint , Boolean anonymous ) { this . receiver = receiver ; this . message = message ; this . constraint = constraint ; this . anonymous = anonymous ; } @Override @Suspendable public String call () throws FlowException { EnclaveFlowInitiator session = EnclaveClientHelper . initiateFlow ( this , receiver , constraint , anonymous ); byte [] response = session . sendAndReceive ( message . getBytes ( StandardCharsets . UTF_8 )); return new String ( response ); } } The flow initiation starts in the usual manner for a Corda flow. Once a session with the hosting node is established, the flow waits for an EnclaveInstanceInfo to verify it against the constraint passed. If the enclave verifies successfully and doesn't throw an exception, the flow can continue by sending the initiator party identity to the enclave for authentication . The last step is only applicable if the party wishes to share its identity. No party identity is not sent if the parameter anonymous is set to true . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Suspendable @Throws ( FlowException :: class ) @JvmStatic @JvmOverloads fun initiateFlow ( flow : FlowLogic <*> , receiver : Party , constraint : String , anonymous : Boolean = false ): EnclaveFlowInitiator { val session = flow . initiateFlow ( receiver ) // Read the enclave attestation from the peer. val attestation = session . receive ( ByteArray :: class . java ). unwrap { from : ByteArray -> EnclaveInstanceInfo . deserialize ( from ) } // The key hash below (the hex string after 'S') is the public key version of sample_private_key.pem // In a real app you should remove the SEC:INSECURE part, of course. try { EnclaveConstraint . parse ( constraint ). check ( attestation ) } catch ( e : InvalidEnclaveException ) { throw FlowException ( e ) } val instance = EnclaveFlowInitiator ( flow , session , attestation ) instance . sendIdentityToEnclave ( anonymous ) return instance } Once the enclave is successfully verified, and our identity is authenticated by the enclave (if we decided to share our identity), the flow can start securely exchanging encrypted messages with the enclave through the EnclaveFlowInitiator instance returned, which implements a simple send/receive API that encrypts and decrypts the outgoing and incoming data in the form of byte arrays. The send and receive methods use the PostOffice API. The EnclaveFlowInitiator class holds one PostOffice instance which has the topic set to the session's flow id. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Suspendable @Throws ( FlowException :: class ) fun sendAndReceive ( messageBytes : ByteArray ): ByteArray { sendToEnclave ( messageBytes ) return receiveFromEnclave () } @Suspendable @Throws ( FlowException :: class ) private fun sendToEnclave ( messageBytes : ByteArray ) { val encryptedMail = postOffice . encryptMail ( messageBytes ) session . send ( encryptedMail ) } @Suspendable @Throws ( FlowException :: class ) fun receiveFromEnclave (): ByteArray { val reply : EnclaveMail = session . receive ( ByteArray :: class . java ). unwrap { mail : ByteArray -> try { postOffice . decryptMail ( mail ) } catch ( e : IOException ) { throw FlowException ( \"Unable to decrypt mail from Enclave\" , e ) } } return reply . bodyAsBytes } Authenticating sender's identity \u00b6 The enclave can authenticate a sender's identity that belongs to a network where nodes are identified by a X.509 certificate, and the network is controlled by a certificate authority like in a Corda network. The network CA root certificate's public key must be stored in the enclave's resource folder (in this example the path is enclave/src/main/resources/) in a file named trustedroot.cer, so that the enclave can validate the sender identity. The identity is set up by the EnclaveFlowInitiator class during authentication and sent to the enclave who verifies it. Please be aware that the first byte of the identity message indicates whether a party wants to remain anonymous or not. If a party decides to remain anonymous, the identity message is padded with zeros to prevent anyone in the middle from using statistical analysis to guess whether a party is anonymous or not. If a party decides to authenticate itself, the remaining bytes represent the party's identity. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Suspendable private fun buildMailerIdentity (): SenderIdentityImpl { val sharedSecret = encryptionKey . publicKey . encoded val signerPublicKey = flow . ourIdentity . owningKey val signature = flow . serviceHub . keyManagementService . sign ( sharedSecret , signerPublicKey ). withoutKey () val signerCertPath = flow . ourIdentityAndCert . certPath return SenderIdentityImpl ( signerCertPath , signature . bytes ) } @Suspendable @Throws ( FlowException :: class ) fun sendIdentityToEnclave ( isAnonymous : Boolean ) { val serializedIdentity = getSerializedIdentity ( isAnonymous ) sendToEnclave ( serializedIdentity ) val mail : EnclaveMail = session . receive ( ByteArray :: class . java ). unwrap { mail : ByteArray -> try { postOffice . decryptMail ( mail ) } catch ( e : IOException ) { throw FlowException ( \"Unable to decrypt mail from Enclave\" , e ) } } if ( ! mail . topic . contentEquals ( \" $ flowTopic -ack\" )) throw FlowException ( \"The enclave could not validate the identity sent\" ) } When the enclave successfully validates the identity, it stores it in a key based cache. Subsequent messages from the same sender in the same session are paired with the cached identity which is then available from within the receiveMail method through the extra parameter called identity . This identity can be used to uniquely identify a sender but be aware that the parameter might be null if the user decides to remain anonymous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Override protected void receiveMail ( long id , EnclaveMail mail , String routingHint , SenderIdentity identity ) { String reversedString = reverse ( new String ( mail . getBodyAsBytes ())); String responseString ; if ( identity == null ) { responseString = String . format ( \"Reversed string: %s; Sender name: <Anonymous>\" , reversedString ); } else { responseString = String . format ( \"Reversed string: %s; Sender name: %s\" , reversedString , identity . getName ()); } // Get the PostOffice instance for responding back to this mail. Our response will use the same topic. final EnclavePostOffice postOffice = postOffice ( mail ); // Create the encrypted response and send it back to the sender. final byte [] reply = postOffice . encryptMail ( responseString . getBytes ( StandardCharsets . UTF_8 )); postMail ( reply , routingHint ); } The method receiveMail contains the enclave logic and therefore can contain any logic necessary to meet the business requirements. For the example above, the enclave simply reverses a string and returns the result back with the sender name if the party decided not to be anonymous. The mail parameter contains some metadata, and the data which is going to be processed by the enclave. The call mail.getBodyAsBytes() returns the data that is going to be processed by the enclave. As mention previously, the identity parameter object contains the identity of the sender or is set to null if the sender decided to remain anonymous. Important Contrary to the 'hello world' project, the method receiveMail contains an extra parameter called identity. Even though technically this is an overload, the original is final and can't be used. Unit testing \u00b6 The unit tests are completely normal for Corda. However, as the code above will load a real or simulated Linux enclave, they won't run on Windows or macOS. You can build your enclave in mock mode to fix this or on macOS, you can use the container-gradle script to run the tests inside a Linux VM.","title":"Integrating an enclave with Corda"},{"location":"writing-cordapps.html#writing-the-sample-cordapp","text":"Corda is R3's open source enterprise blockchain platform. You can think of it as a peer to peer database in which user-written apps can be installed. Enclaves can be used inside \"CorDapps\" to provide multi-party computation over the peer to peer network. Or look at it the other way around: Corda can provide communication and identity services to your enclave. The sample CorDapp builds on the hello-world sample allowing nodes to perform the reverse string task between two nodes, one of which loads the enclave. Smart contracts aren't used in this sample, only flows are needed. The sample divides the code into several pieces. The packages that don't have samples in the name are intended to be copy/pasted into your own code. They'll be turned into a full API in future. The code expects a DCAP capable host, but if you want to use EPID you can edit the enclave startup code to make it use your Intel API keys. Important To understand this tutorial you are expected to have read both the Conclave Hello World tutorial and the Corda tutorials already.","title":"Writing the sample CorDapp"},{"location":"writing-cordapps.html#configure-your-workflow-cordapp-module","text":"Both Conclave and Corda rely on Gradle build system plugins. Follow the instructions in the hello world tutorial to configure Gradle to include an enclave mode. Add the host libraries to your Corda workflows module: 1 2 3 4 5 6 7 8 9 10 11 12 dependencies { compile project(path: \":enclave\", configuration: mode) compile \"com.r3.conclave:conclave-host:$conclaveVersion\" compile \"com.r3.conclave:conclave-client:$conclaveVersion\" compile \"com.r3.conclave:conclave-common:$conclaveVersion\" compile \"com.r3.conclave:conclave-mail:$conclaveVersion\" // Corda dependencies. cordaCompile \"$corda_core_release_group:corda-core:$corda_core_release_version\" cordaRuntime \"$corda_release_group:corda:$corda_release_version\" testCompile \"$corda_release_group:corda-node-driver:$corda_release_version\" } Important You must use Gradle's compile configurations for the host dependencies. If you use implementation then you will get errors about missing classes when the node starts up, due to issues with fat JARing. The host dependencies section should look like above.","title":"Configure your workflow CorDapp module"},{"location":"writing-cordapps.html#write-an-enclave-host-service","text":"The enclave will be loaded into a service object. This singleton will be available to flows for later usage, and lets us integrate with the lifecycle of the node. The sample project contains a helper class called EnclaveHostService that you can copy into your project and sub-class. At the moment it isn't a complete or supported API so you may need to edit it to make it work for your use case. 1 2 3 4 5 6 @CordaService public class ReverseEnclaveService extends EnclaveHostService { public ReverseEnclaveService ( @NotNull AppServiceHub serviceHub ) { super ( \"com.r3.conclave.cordapp.sample.enclave.ReverseEnclave\" ); } } This will make a best effort to enable SGX support on the host if necessary, then it loads the sample ReverseEnclave class (which expands on the one already seen in the hello world tutorial). The EnclaveHostService class exposes methods to send and receive mail with the enclave, in a way that lets flows suspend waiting for the enclave to deliver mail. In the next section about relaying a mail from a flow to the Enclave , the above class is used as a parameter to initiate the responder flow that ensures the host service is started.","title":"Write an enclave host service"},{"location":"writing-cordapps.html#relaying-mail-from-a-flow-to-the-enclave","text":"We've already seen how to create a new subclass of Enclave and how to receive and post mail in the enclave in the hello-world tutorial, and in the coming sections we'll see how some of this boilerplate has been wrapped into an API to simplify setting up secure flows and exchange secure messages between parties. In this tutorial, reversing a string involves two parties: one is the initiator that sends the secret string to reverse, the other is the responder that reverses the string inside the enclave. To implement this we will need a flow used by clients, and a 'responder' flow used by the host node. Here's the responder flow to get the enclave host service up and running, get the enclave attestation and send it to the other party for verification, get, verify and acknowledge the other party's encrypted identity, get the other party's encrypted mail with the string to reverse, deliver it to the enclave, and retrieve the enclave encrypted mail to send to the other party for decryption. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // We start with a few lines of boilerplate: read the Corda tutorials if you aren't sure what these are about. @InitiatedBy ( ReverseFlow . class ) public class ReverseFlowResponder extends FlowLogic < Void > { // private variable private final FlowSession counterpartySession ; // Constructor public ReverseFlowResponder ( FlowSession counterpartySession ) { this . counterpartySession = counterpartySession ; } @Suspendable @Override public Void call () throws FlowException { EnclaveFlowResponder session = EnclaveClientHelper . initiateResponderFlow ( this , counterpartySession , ReverseEnclaveService . class ); session . relayMessageToFromEnclave (); return null ; } } Looking into the responder's flow initiation, we see that this side of the flow starts by ensuring a specific instance of the EnclaveHostService is started and sending the remote attestation. Typically, an interaction with the enclave should start this way, although the attestation may be cached if such logic is required. The flow responder expects to receive an identity during the initialization. An empty identity message can be sent if the party prefers to remain anonymous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Suspendable @Throws ( FlowException :: class ) @JvmStatic @JvmOverloads fun < T : EnclaveHostService > initiateResponderFlow ( flow : FlowLogic <*> , counterPartySession : FlowSession , serviceType : Class < T > ): EnclaveFlowResponder { // Start an instance of the enclave hosting service val host = flow . serviceHub . cordaService ( serviceType ) // Send the other party the enclave identity (remote attestation) for verification. counterPartySession . send ( host . attestationBytes ) val instance = EnclaveFlowResponder ( flow , counterPartySession , host ) // Relay the initial identity message to the enclave and relay the response back instance . relayMessageToFromEnclave () return instance } The EnclaveFlowResponder implements a simple request/response type protocol that receives an encrypted byte array and uses the deliverAndPickUpMail method of the EnclaveHostService class. This returns an operation that can be passed to await . The flow will suspend (thus freeing up its thread), potentially for a long period. There is no requirement that the enclave reply immediately. It can return from processing the delivered mail without replying. When it does choose to reply, the flow will be re-awakened and the encrypted mail returned to the other side. 1 2 3 4 5 6 7 8 9 10 11 @Suspendable @Throws ( FlowException :: class ) fun relayMessageToFromEnclave () { // Other party sends us an encrypted mail. val encryptedMail = session . receive ( ByteArray :: class . java ). unwrap { it } // Deliver and wait for the enclave to reply. The flow will suspend until the enclave chooses to deliver a mail // to this flow, which might not be immediately. val encryptedReply : ByteArray = flow . await ( host . deliverAndPickUpMail ( flow , encryptedMail )) // Send back to the other party the encrypted enclave's reply session . send ( encryptedReply ) } Important Although the Corda flow framework has built in support for it, this sample code does not handle node restarts. And here's the initiator flow that initiates a session with the responder party, get the enclave attestation, validate it, build and send a verifiable identity for the enclave to validate, send the encrypted mail with the string to reverse and read and decrypt the enclave's response. Keep in mind that a verifiable identity is only sent to the enclave if the anonymous property is set to false. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @InitiatingFlow @StartableByRPC public class ReverseFlow extends FlowLogic < String > { private final Party receiver ; private final String message ; private final String constraint ; private final Boolean anonymous ; public ReverseFlow ( Party receiver , String message , String constraint ) { this ( receiver , message , constraint , false ); } public ReverseFlow ( Party receiver , String message , String constraint , Boolean anonymous ) { this . receiver = receiver ; this . message = message ; this . constraint = constraint ; this . anonymous = anonymous ; } @Override @Suspendable public String call () throws FlowException { EnclaveFlowInitiator session = EnclaveClientHelper . initiateFlow ( this , receiver , constraint , anonymous ); byte [] response = session . sendAndReceive ( message . getBytes ( StandardCharsets . UTF_8 )); return new String ( response ); } } The flow initiation starts in the usual manner for a Corda flow. Once a session with the hosting node is established, the flow waits for an EnclaveInstanceInfo to verify it against the constraint passed. If the enclave verifies successfully and doesn't throw an exception, the flow can continue by sending the initiator party identity to the enclave for authentication . The last step is only applicable if the party wishes to share its identity. No party identity is not sent if the parameter anonymous is set to true . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Suspendable @Throws ( FlowException :: class ) @JvmStatic @JvmOverloads fun initiateFlow ( flow : FlowLogic <*> , receiver : Party , constraint : String , anonymous : Boolean = false ): EnclaveFlowInitiator { val session = flow . initiateFlow ( receiver ) // Read the enclave attestation from the peer. val attestation = session . receive ( ByteArray :: class . java ). unwrap { from : ByteArray -> EnclaveInstanceInfo . deserialize ( from ) } // The key hash below (the hex string after 'S') is the public key version of sample_private_key.pem // In a real app you should remove the SEC:INSECURE part, of course. try { EnclaveConstraint . parse ( constraint ). check ( attestation ) } catch ( e : InvalidEnclaveException ) { throw FlowException ( e ) } val instance = EnclaveFlowInitiator ( flow , session , attestation ) instance . sendIdentityToEnclave ( anonymous ) return instance } Once the enclave is successfully verified, and our identity is authenticated by the enclave (if we decided to share our identity), the flow can start securely exchanging encrypted messages with the enclave through the EnclaveFlowInitiator instance returned, which implements a simple send/receive API that encrypts and decrypts the outgoing and incoming data in the form of byte arrays. The send and receive methods use the PostOffice API. The EnclaveFlowInitiator class holds one PostOffice instance which has the topic set to the session's flow id. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Suspendable @Throws ( FlowException :: class ) fun sendAndReceive ( messageBytes : ByteArray ): ByteArray { sendToEnclave ( messageBytes ) return receiveFromEnclave () } @Suspendable @Throws ( FlowException :: class ) private fun sendToEnclave ( messageBytes : ByteArray ) { val encryptedMail = postOffice . encryptMail ( messageBytes ) session . send ( encryptedMail ) } @Suspendable @Throws ( FlowException :: class ) fun receiveFromEnclave (): ByteArray { val reply : EnclaveMail = session . receive ( ByteArray :: class . java ). unwrap { mail : ByteArray -> try { postOffice . decryptMail ( mail ) } catch ( e : IOException ) { throw FlowException ( \"Unable to decrypt mail from Enclave\" , e ) } } return reply . bodyAsBytes }","title":"Relaying mail from a flow to the Enclave"},{"location":"writing-cordapps.html#authenticating-senders-identity","text":"The enclave can authenticate a sender's identity that belongs to a network where nodes are identified by a X.509 certificate, and the network is controlled by a certificate authority like in a Corda network. The network CA root certificate's public key must be stored in the enclave's resource folder (in this example the path is enclave/src/main/resources/) in a file named trustedroot.cer, so that the enclave can validate the sender identity. The identity is set up by the EnclaveFlowInitiator class during authentication and sent to the enclave who verifies it. Please be aware that the first byte of the identity message indicates whether a party wants to remain anonymous or not. If a party decides to remain anonymous, the identity message is padded with zeros to prevent anyone in the middle from using statistical analysis to guess whether a party is anonymous or not. If a party decides to authenticate itself, the remaining bytes represent the party's identity. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Suspendable private fun buildMailerIdentity (): SenderIdentityImpl { val sharedSecret = encryptionKey . publicKey . encoded val signerPublicKey = flow . ourIdentity . owningKey val signature = flow . serviceHub . keyManagementService . sign ( sharedSecret , signerPublicKey ). withoutKey () val signerCertPath = flow . ourIdentityAndCert . certPath return SenderIdentityImpl ( signerCertPath , signature . bytes ) } @Suspendable @Throws ( FlowException :: class ) fun sendIdentityToEnclave ( isAnonymous : Boolean ) { val serializedIdentity = getSerializedIdentity ( isAnonymous ) sendToEnclave ( serializedIdentity ) val mail : EnclaveMail = session . receive ( ByteArray :: class . java ). unwrap { mail : ByteArray -> try { postOffice . decryptMail ( mail ) } catch ( e : IOException ) { throw FlowException ( \"Unable to decrypt mail from Enclave\" , e ) } } if ( ! mail . topic . contentEquals ( \" $ flowTopic -ack\" )) throw FlowException ( \"The enclave could not validate the identity sent\" ) } When the enclave successfully validates the identity, it stores it in a key based cache. Subsequent messages from the same sender in the same session are paired with the cached identity which is then available from within the receiveMail method through the extra parameter called identity . This identity can be used to uniquely identify a sender but be aware that the parameter might be null if the user decides to remain anonymous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Override protected void receiveMail ( long id , EnclaveMail mail , String routingHint , SenderIdentity identity ) { String reversedString = reverse ( new String ( mail . getBodyAsBytes ())); String responseString ; if ( identity == null ) { responseString = String . format ( \"Reversed string: %s; Sender name: <Anonymous>\" , reversedString ); } else { responseString = String . format ( \"Reversed string: %s; Sender name: %s\" , reversedString , identity . getName ()); } // Get the PostOffice instance for responding back to this mail. Our response will use the same topic. final EnclavePostOffice postOffice = postOffice ( mail ); // Create the encrypted response and send it back to the sender. final byte [] reply = postOffice . encryptMail ( responseString . getBytes ( StandardCharsets . UTF_8 )); postMail ( reply , routingHint ); } The method receiveMail contains the enclave logic and therefore can contain any logic necessary to meet the business requirements. For the example above, the enclave simply reverses a string and returns the result back with the sender name if the party decided not to be anonymous. The mail parameter contains some metadata, and the data which is going to be processed by the enclave. The call mail.getBodyAsBytes() returns the data that is going to be processed by the enclave. As mention previously, the identity parameter object contains the identity of the sender or is set to null if the sender decided to remain anonymous. Important Contrary to the 'hello world' project, the method receiveMail contains an extra parameter called identity. Even though technically this is an overload, the original is final and can't be used.","title":"Authenticating sender's identity"},{"location":"writing-cordapps.html#unit-testing","text":"The unit tests are completely normal for Corda. However, as the code above will load a real or simulated Linux enclave, they won't run on Windows or macOS. You can build your enclave in mock mode to fix this or on macOS, you can use the container-gradle script to run the tests inside a Linux VM.","title":"Unit testing"},{"location":"writing-hello-world.html","text":"Writing the sample enclave \u00b6 The sample \"hello world\" enclave just reverses whatever string is passed into it. We'll do these things to make our own version of the hello enclave project: Configure Gradle. At this time Conclave projects must use Gradle as their build system. Implement an enclave object that accepts both local calls from the host, and encrypted messages from a client. Write the host program that loads the enclave. Run the host and enclave in simulation and debug modes. Write the client that sends the enclave encrypted messages via the host. Configure your modules \u00b6 Create a new Gradle project via whatever mechanism you prefer, e.g. IntelliJ can do this via the New Project wizard. Create three modules defined in the project: one for the host, one for the enclave and one for the client. The host program may be an existing server program of some kind, e.g. a web server, but in this tutorial we'll write a command line host. The client may likewise be a GUI app or integrated with some other program (like a server), but in this case to keep it simple the client will also be a command line app. Root settings.gradle file \u00b6 In the unzipped SDK there is a directory called repo that contains a local Maven repository. This is where the libraries and Gradle plugin can be found. We need to tell Gradle to look there for plugins. Create or modify a file called settings.gradle in your project root directory so it looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 pluginManagement { repositories { maven { def repoPath = file ( rootDir . relativePath ( file ( conclaveRepo ))) if ( repoPath == null ) throw new Exception ( \"Make sure the 'conclaveRepo' setting exists in gradle.properties, or your \\$HOME/gradle.properties file. See the Conclave tutorial on https://docs.conclave.net\" ) else if (! new File ( repoPath , \"com\" ). isDirectory ()) throw new Exception ( \"The $repoPath directory doesn't seem to exist or isn't a Maven repository; it should be the SDK 'repo' subdirectory. See the Conclave tutorial on https://docs.conclave.net\" ) url = repoPath } // Add standard repositories back. gradlePluginPortal () jcenter () mavenCentral () } plugins { id 'com.r3.conclave.enclave' version conclaveVersion apply false } } include 'enclave' include 'host' include 'client' This boilerplate is unfortunately necessary to copy/paste into each project that uses Conclave. It sets up Gradle to locate the plugin that configures the rest of the boilerplate build logic for you The pluginManagement block tells Gradle to use a property called conclaveRepo to find the repo directory in your SDK download. Because developers on your team could unpack the SDK anywhere, they must configure the path before the build will work. The code above will print a helpful error if they forget or get it wrong. To set the value, add a couple of lines to the gradle.properties file like this: 1 2 conclaveRepo=/path/to/sdk/repo conclaveVersion=1.1 Gradle properties can be set using a file in the project directory, or more usefully in the developer's home directory. You may wish to put the version in the project's gradle.properties file and the path in each developer's personal gradle.properties . Alternatively just add a sdk directory to the .gitignore and require everyone to unpack the SDK to the source tree. Root build.gradle file \u00b6 Add the following code to your root build.gradle file to import the repository: 1 2 3 4 5 6 7 8 subprojects { repositories { maven { url = rootProject . file ( conclaveRepo ) } mavenCentral () } } IDE Documentation in the root build.gradle file \u00b6 Some IDEs are able to automatically display Conclave SDK documentation whilst editing code. In order for this to work you may need to add some configuration to the root build.gradle depending on your IDE. Start by adding the Gradle plugin required to support your IDE. Note that Visual Studio Code shares the configuration provided by the eclipse plugin. 1 2 3 4 5 plugins { id 'java' id 'idea' id 'eclipse' } Then add sections to tell the IDEs to download Javadoc for dependencies. 1 2 3 4 5 6 7 8 9 10 11 eclipse { classpath { downloadJavadoc = true } } idea { module { downloadJavadoc = true } } Finally apply the same configuration to all subprojects. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 subprojects { apply plugin: 'idea' apply plugin: 'eclipse' idea { module { downloadJavadoc = true } } eclipse { classpath { downloadJavadoc = true } } repositories { Info At the moment, IntelliJ IDEA has an issue that means it does not correctly display the documentation for Conclave, even if you provide this configuration. Instead, please refer to the online Javadocs for Conclave. Configure the host module \u00b6 Add this bit of code to your host build.gradle file to let the mode be chosen from the command line: 1 2 // Override the default (simulation) with -PenclaveMode= def mode = findProperty ( \"enclaveMode\" )?. toString ()?. toLowerCase () ?: \"simulation\" We can apply the Gradle application plugin and set the mainClassName property in the usual manner to let us run the host from the command line: 1 2 3 4 5 6 7 8 plugins { id 'java' id 'application' } application { mainClassName = \"com.superfirm.host.Host\" // CHANGE THIS } Then add the following dependencies, also to the host's build.gradle : 1 2 3 4 5 6 7 dependencies { implementation \"com.r3.conclave:conclave-host:$conclaveVersion\" runtimeOnly project ( path: \":enclave\" , configuration: mode ) runtimeOnly \"org.slf4j:slf4j-simple:1.7.30\" testImplementation \"org.junit.jupiter:junit-jupiter:5.6.0\" } This says that at runtime (but not compile time) the :enclave module must be on the classpath, and configures dependencies to respect the three different variants of the enclave. That is, the enclave module will expose tasks to compile and use either mock, simulation, debug or release mode. Which task to use is actually selected by the host build. Tip Don't worry if you see the error Could not resolve project :enclave . This will be resolved when we configure the enclave module in the next section. For this simple tutorial we also add a runtime-only dependency on the popular SLF4J library which Conclave uses to do logging. SLF4J enables you to send Conclave's logging to any of the major logging frameworks used in Java, but here, we add the \"simple\" backend which just causes it to log to the console. Finally we configure unit testing using JUnit 5. If you intend to use an external signing process to sign your enclave then add the following lines to the Gradle file: 1 2 3 4 // Create a task that can be used for generating signing materials tasks . register ( \"prepareForSigning\" ) { it . dependsOn ( \":enclave:generateEnclaveSigningMaterial\" + mode . capitalize ()) } This creates a new task that can be invoked using Gradle to halt the build after generating materials that need to be signed by an external signing process. After the material has been signed the build can be resumed. Configure the enclave module \u00b6 Add the Conclave Gradle plugin to your enclave build.gradle file: 1 2 3 plugins { id 'com.r3.conclave.enclave' } and a dependency on the Conclave enclave library and a test dependency on the Conclave host library: 1 2 3 4 5 dependencies { implementation \"com.r3.conclave:conclave-enclave\" testImplementation \"com.r3.conclave:conclave-host\" testImplementation \"org.junit.jupiter:junit-jupiter:5.6.0\" } This time you don't have to specify the Conclave version because the plugin will set that for you automatically. Specify the enclave's runtime environment, product ID and revocation level: 1 2 3 4 conclave { productID = 1 revocationLevel = 0 } These settings are described in detail in the page on enclave configuration . A summary of these settings follows: Conclave needs access to a Linux build environment in order to build enclaves. On MacOS and Windows this is automatically created during the build process using Docker. If you do not have Docker installed then the build will generate an error prompting you to install Docker on your system. Once Docker is installed and added to your PATH environment variable you can proceed to build Simulation, Debug or Release mode enclaves. Docker is not required if you are using a Linux system. The product ID is an arbitrary number that can be used to distinguish between different enclaves produced by the same organisation (which may for internal reasons wish to use a single signing key). This value should not change once you have picked it. The revocation level should be incremented if a weakness in the enclave code is discovered and fixed; doing this will enable clients to avoid connecting to old, compromised enclaves. The revocation level should not be incremented on every new release, but only when security improvements have been made. Signing keys \u00b6 Specify the signing methods for each of the build types. You could keep your private key in a file for both debug and release enclaves if you like, but some organisations require private keys to be held in an offline system or HSM. In that case, configure it like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 conclave { productID = 1 revocationLevel = 0 // For simulation, we want to use the default signing type of dummyKey so // we do not need to specify a configuration. debug { signingType = privateKey signingKey = file ( \"../signing/sample_private_key.pem\" ) } release { // To protect our release private key with an HSM, the enclave needs to be built in stages. // Firstly, build the signing material: // ./gradlew prepareForSigning -PenclaveMode=\"Release\" // // Generate a signature from the signing material. // // Finally build the signed enclave: // ./gradlew build -PenclaveMode=\"Release\" // signingType = externalKey signatureDate = new Date ( 1970 , 0 , 1 ) mrsignerSignature = file ( \"../signing/signature.bin\" ) mrsignerPublicKey = file ( \"../signing/external_signing_public.pem\" ) } } The example configuration above specifies different signing configurations for each of the different build types. Simulation builds use the default dummy key. Debug builds use a private key stored in a file. Release builds use a private key managed by some external signing process. The hello-world sample in the SDK contains some example keys that can be used with the privateKey and externalKey signing types. These can be found in hello-world/signing/ . Key Files Description sample_private_key.pem A 3072 bit RSA private key that can be used to test the privateKey signing type external_signing_*.pem An AES encrypted 3072 bit RSA public/private key pair that can be used to test the externalKey signing type. The private key can be accessed with the password '12345' Copy the signing directory from the SDK into your project and/or update the paths in the enclave build.gradle . Alternatively you can provide or generate your own keys. Important These keys aren't whitelisted by Intel so you can't use them for real release builds. Only use these sample keys for the tutorial. Don't use them for signing your own enclaves! Configure the client module \u00b6 The client module is the simplest of all. This is literally a bog-standard hello world command line app Gradle build, with a single dependency on the Conclave client library: 1 2 3 4 5 6 7 8 9 10 11 12 plugins { id 'java' id 'application' } application { mainClassName = \"com.superfirm.client.Client\" // CHANGE THIS } dependencies { implementation \"com.r3.conclave:conclave-client:$conclaveVersion\" } And with that, we're done configuring the module. Create a new subclass of Enclave \u00b6 Enclaves are similar to standalone programs and as such have an equivalent to a \"main class\". This class must be a subclass of Enclave . Create your enclave class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.superfirm.enclave // CHANGE THIS import com.r3.conclave.enclave.Enclave ; /** * Simply reverses the bytes that are passed in. */ public class ReverseEnclave extends Enclave { @Override public byte [] receiveFromUntrustedHost ( byte [] bytes ) { byte [] result = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) result [ i ] = bytes [ bytes . length - 1 - i ] ; return result ; } } The Enclave class by itself doesn't require you to support direct communication with the host. This is because sometimes you don't need that and shouldn't have to implement message handlers. In this case we'll use that functionality because it's a good place to start learning, so we also override and implement the receiveFromUntrustedHost method which takes a byte array and optionally returns a byte array back. Here we just reverse the contents. Tip In a real app you would use the byte array to hold serialised data structures. You can use whatever data formats you like. You could use a simple string format or a binary format like protocol buffers. Threading \u00b6 In this tutorial we won't write a multi-threaded enclave. If you want to do this, you'll need to override the boolean isThreadSafe() method in the Enclave class (use override val threadSafe: Boolean get() = true in Kotlin). This tells Conclave to allow multiple threads into the enclave simultaneously. You're required to opt-in to allowing multi-threading to avoid accidents when someone writes a simple enclave that isn't thread safe, and forgets that the host is malicious and can enter your code with multiple threads simultaneously even if you aren't ready for it, corrupting your application level data via race conditions. By blocking multi-threading until you indicate readiness, the hope is that some types of attack can be avoided. See the page on enclave threading to learn more. Write a simple host program \u00b6 An enclave by itself is just a library: you must therefore load it from inside a host program. It's easy to load then pass data to and from an enclave. Let's start with the skeleton of a little command line app: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.superfirm.host // CHANGE THIS import com.r3.conclave.host.EnclaveHost ; import com.r3.conclave.host.EnclaveLoadException ; /** * This class demonstrates how to load an enclave and use it. */ public class Host { public static void main ( String [] args ) throws EnclaveLoadException { // TODO: Fill this out } public static String callEnclave ( EnclaveHost enclave , String input ) { // TODO: Fill this out. } } At first we will be building and running our enclave in simulation mode. This does not require the platform hardware to support SGX. However simulation mode does require us to be using Linux. If we are not using Linux as our host OS then we can use a Linux container or virtual machine as described in Running the host . Alternatively we could use mock mode instead of simulation mode. When we want to switch to loading either a debug or release build of the enclave we need to ensure the platform supports SGX. By adding the code below to the main method we can determine whether the platform can load debug and release enclaves. This method reports the actual hardware status even if you are currently working with mock or simulation enclaves. 1 2 3 4 5 6 7 8 public static void main ( String [] args ) throws EnclaveLoadException { try { EnclaveHost . checkPlatformSupportsEnclaves ( true ); System . out . println ( \"This platform supports enclaves in simulation, debug and release mode.\" ); } catch ( EnclaveLoadException e ) { System . out . println ( \"This platform does not support hardware enclaves: \" + e . getMessage ()); } } If SGX is not supported the function throws an exception which describes the reason why. There are a number of common reasons why SGX may not be supported including: The CPU or the system BIOS does not support SGX. The host operating system is Windows or Mac OS. Conclave currently only supports loading enclaves in simulation, debug or release modes on Linux. SGX is disabled in the BIOS and must be manually enabled by the user. SGX is disabled but can be enabled in software. If SGX is disabled but can be enabled in software the code below attempts to automatically enable SGX support by specifying the 'true' parameter. It might be necessary to run this application with root access and/or reboot the system in order to successfully enable SGX. The exception message will describe if this is the case. To load the enclave we'll put this after the platform check: 1 2 3 4 5 6 7 8 9 String className = \"com.superfirm.enclave.ReverseEnclave\" // CHANGE THIS try ( EnclaveHost enclave = EnclaveHost . load ( className )) { enclave . start ( null , null ); System . out . println ( callEnclave ( enclave , \"Hello world!\" )); // !dlrow olleH :-) // TODO: Get the remote attestation } This code starts by creating an EnclaveHost object. This names the class and then attempts to load it inside another JVM running inside an enclave. A remote attestation procedure is then performed involving Intel's servers. This procedure can fail if attempting to load a debug or release enclave and the platform does not support SGX. This is why it is important to perform the platform check we made in the code above. If the enclave does fail to load for any reason then an exception is thrown describing the reason why. Tip You can use the command EnclaveHost.getCapabilitiesDiagnostics() to print out some diagnostic information about the CPU, which can be helpful for troubleshooting. We then call start which initialises the enclave and the MyEnclave class inside it. You can load multiple enclaves at once but they must all use same mode, and each enclave will get its own isolated JVM. Note that an EnclaveHost allocates memory out of a pool called the \"enclave page cache\" which is a machine-wide limited resource. It'll be freed if the host JVM quits, but it's good practice to close the EnclaveHost object by calling close on it when done. Therefore we also make sure the .close() method is called on the enclave no matter what using a try-with-resources statement. This doesn't actually matter in such a tiny hello world sample, because the enclave will be unloaded by the kernel once we exit like any other resource. It's just here to remind you that an enclave must be explicitly unloaded if you need to reinitialise it for whatever reason, or if you need the memory back. Warning Starting and stopping/closing an enclave is not free, so don't load the enclave, use it and immediately close it again as in the above example. Cost-wise it's like starting a regular process even though no process will actually exist. Treat the enclave like any other expensive resource and keep it around for as long as you might need it. Once we started the enclave, we call it passing in a string as bytes. The enclave will reverse it and we'll print out the answer. This is as easy as calling EnclaveHost.callEnclave , so put this in the callEnclave static method defined above: 1 2 // We'll convert strings to bytes and back. return new String ( enclave . callEnclave ( input . getBytes ())); So we just convert the string to bytes, send it to the enclave, and convert the response from bytes back to a string. Remote attestation \u00b6 There's no point in using an enclave to protect purely local data, as the data must ultimately come from the (assumed malicious/compromised) host in that scenario. That's why you need remote attestation, which lets an enclave prove its identity to the third parties who will upload secret data. If this paragraph doesn't make sense please review the Architecture overview and the Enclaves section. Before we can set up communication with a client, we must therefore get remote attestation working. Using remote attestation is easy! Just obtain an EnclaveInstanceInfo and serialize/deserialize it using the provided methods. Add these lines to the end of the main function of your Host class: 1 2 3 final EnclaveInstanceInfo attestation = enclave . getEnclaveInstanceInfo (); final byte [] attestationBytes = attestation . serialize (); System . out . println ( EnclaveInstanceInfo . deserialize ( attestationBytes )); The EnclaveInstanceInfo has a useful toString function that will print out something like this: 1 2 3 4 5 6 7 8 9 10 Remote attestation for enclave F86798C4B12BE12073B87C3F57E66BCE7A541EE3D0DDA4FE8853471139C9393F: - Mode: SIMULATION - Code signing key hash: 01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B - Public signing key: 302A300506032B65700321000568034F335BE25386FD405A5997C25F49508AA173E0B413113F9A80C9BBF542 - Public encryption key: A0227D6D11078AAB73407D76DB9135C0D43A22BEACB0027D166937C18C5A7973 - Product ID: 1 - Revocation level: 0 Assessed security level at 2020-07-17T16:31:51.894697Z is INSECURE - Enclave is running in simulation mode. The hash in the first line is the measurement . This is a hash of the code of the enclave. It includes both all the Java code inside the enclave as a fat-JAR, and all the support and JVM runtime code required. As such it will change any time you alter the code of your enclave, the version of Conclave in use or the mode (simulation/debug/release) of the enclave. The enclave measurement should be stable across builds and machines, so clients can audit the enclave by repeating the Gradle build and comparing the value they get in the EnclaveInstanceInfo against what the build process prints out. Tip All this data is available via individual getters on the EnclaveInstanceInfo so you should never feel a need to parse the output of toString . EnclaveInstanceInfo is an interface so you can easily build mock attestations in your tests. When not in simulation mode the timestamp is signed by Intel and comes from their servers. An instance has a security assessment, which can change in response to discovery of vulnerabilities in the infrastructure (i.e. without anything changing about the host or enclave itself). As we can see this enclave isn't actually considered secure yet because we're running in simulation mode still. An enclave can be SECURE , STALE , or INSECURE . A assessment of STALE means there is a software/firmware/microcode update available for the platform that improves security in some way. The client may wish to observe when this starts being reported and define a time span in which the remote enclave operator must upgrade. We can send the serialized bytes to a client via whatever network mechanism we want. The bytes are essentially a large, complex digital signature, so it's safe to publish them publicly. For simplicity in this tutorial we are just going to copy them manually and hard-code them in the client, but more on that later . An attestation doesn't inherently expire but because the SGX ecosystem is always moving, client code will typically have some frequency with which it expects the host code to refresh the EnclaveInstanceInfo . At present this is done by stopping/closing and then restarting the enclave. Configure attestation \u00b6 To use SGX remote attestation for real we need to do some additional work. Remember how we wrote enclave.start(null, null); above? The first parameter contains configuration data required to use an attestation service. There are three kinds of attestation service: EPID. This older protocol is supported by some desktop/laptop class Intel CPUs. The EPID protocol includes some consumer privacy cryptography, and involves talking directly to Intel's IAS service to generate an attestation. For that you need to obtain an API key and service provider ID from Intel. You can sign-up easily and for free. Learn more about IAS . Please note that Intel does not provide EPID attestation support for Xeon scalable CPUs including Ice Lake and future generations. You need to use DCAP attestation on these platforms. Azure DCAP. The datacenter attestation primitives protocol is newer and designed for servers. When running on a Microsoft Azure Confidential Compute VM or Kubernetes pod, you don't need any parameters. It's all configured out of the box. Generic DCAP. When not running on Azure, you need to obtain API keys for Intel's PCCS service. We'll target Azure for now to keep things simple. Replace the call to EnclaveHost.start above with this snippet: 1 enclave . start ( new AttestationParameters . DCAP (), null ); Info Why does Conclave need to contact Intel's servers? It's because those servers contain the most up to date information about what CPUs and system enclave versions are considered secure. Over time these servers will change their assessment of the host system and this will be visible in the responses, as security improvements are made. Run what we've got so far \u00b6 Now everything should be ready to run the host from the command line. Run gradlew host:run and it should print \"Hello World!\" backwards along with the security info as shown above. Note If you are using Windows or macOS then please follow the instructions for your operating system, which you can find in the Running the host section. During the build you should see output like this: 1 2 3 4 > Task :enclave:generateEnclaveMetadataSimulation Succeed. Enclave code hash: 61AE6A28838CE9EFBE16A7078F9A506D69BBA70B69FAD229F1FBDB45AA786109 Enclave code signer: 4924CA3A9C8241A3C0AA1A24A407AA86401D2B79FA9FF84932DA798A942166D4 The code hash will correspond to the value found in the EnclaveInstanceInfo.getEnclaveInfo().getCodeHash() property and the code signer will be EnclaveInstanceInfo.getEnclaveInfo().getCodeSigningKeyHash() . Tip Make a note of the value of Enclave code signer . We will need it later on to verify the enclave's identity from the client. You can switch to debug mode by specifying the enclaveMode property. In debug mode the real hardware is used and virtually everything is identical to how it will be in production, but there's a small back door that can be used by debuggers to read/write the enclave's memory. You will need to run this on an Azure Confidential VM . 1 ./gradlew -PenclaveMode = debug host:run Encrypted messaging \u00b6 The enclave isn't of much use to the host, because the host already trusts itself. It's only useful to remote clients that want to use the enclave for computation without having to trust the host machine or software. We're now going to wire up encrypted messaging. Conclave provides an API for this called Mail. Conclave Mail handles all the encryption for you, but leaves it up to you how the bytes themselves are moved around. You could use a REST API, a gRPC API, JMS message queues, a simple TCP socket as in this tutorial, or even files. Info Learn more about the design of Conclave Mail , and compare it to TLS . Receiving and posting mail in the enclave \u00b6 Firstly we need to upgrade our little enclave to be able to receive mails from clients. This is easy! Just override the receiveMail method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Simply reverses the bytes that are passed in. */ public class ReverseEnclave extends Enclave { @Override public byte [] receiveFromUntrustedHost ( byte [] bytes ) { byte [] result = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { result [ i ] = bytes [ bytes . length - 1 - i ] ; } return result ; } @Override protected void receiveMail ( long id , EnclaveMail mail , String routingHint ) { byte [] reversed = receiveFromUntrustedHost ( mail . getBodyAsBytes ()); byte [] responseBytes = postOffice ( mail ). encryptMail ( reversed ); postMail ( responseBytes , routingHint ); } } The receiveFromUntrustedHost method here isn't really needed, it's just because we're already using this to demonstrate local calls. The new part is receiveMail . This method takes three parameters: the first is an identifier that the host gets to pick, which doesn't mean anything but we can use to acknowledge the mail if we want to using Enclave.acknowledgeMail . Acknowledgement can be used to tell the host the enclave is done processing the mail if it doesn't want to reply immediately. It will be discussed more in future tutorials. In this simple tutorial we reply immediately so don't need to use this feature, and thus we ignore the ID. The third parameter is a routing hint string. It's also provided by the host and it helps the host route replies when dealing with multiple clients. It's passed into postMail when the enclave posts a reply. In our example the host only deals with one client and so it's not used. Mail headers \u00b6 The second parameter is an EnclaveMail . This object gives us access to the body bytes that the client sent, but it also exposes some other header fields: A topic . This can be used to distinguish between different streams of mail from the same client. It's a string and can be thought of as equivalent to an email subject. Topics are scoped per-sender and are not global. The client can send multiple streams of related mail by using a different topic for each stream, and it can do this concurrently. The topic is not parsed by Conclave and, to avoid replay attacks, should never be reused for an unrelated set of mails in the future. A good value might thus contain a random UUID. Topics may be logged and used by your software to route or split mail streams in useful ways. The sequence number . Starting from zero, this is incremented by one for every mail delivered on a topic. Conclave will automatically reject messages if this doesn't hold true, thus ensuring to the client that the stream of related mail is received by the enclave in the order they were sent, and that the host is unable to re-order or drop them. The envelope . This is a slot that can hold any arbitrary byte array the sender likes. It's a holding zone for app specific data that should be authenticated but unencrypted. These header fields are available to the host and therefore should not contain secrets . It may seem odd to have data that's unencrypted, but it's often useful for the client, host and enclave to collaborate in various ways related to storage and routing of data. Even when the host is untrusted it may still be useful for the client to send data that is readable by the host and enclave simultaneously, but which the host cannot tamper with. Inside the enclave you can be assured that the header fields contain the values set by the client, because they're checked before receiveMail is invoked. In addition to the headers there is also the authenticated sender public key . This is the public key of the client that sent the mail. Like the body it's encrypted so that the host cannot learn the client identities. It's called \"authenticated\" because the encryption used by Conclave means you can trust that the mail was encrypted by an entity holding the private key matching this public key. If your enclave recognises the public key this feature can be used as a form of user authentication. In this simple tutorial we only care about the body. We reverse the bytes in the mail body and then create a response mail that will be encrypted to the sender. It contains the reversed bytes. We use the postOffice method to do this. It gives us back a post office object, which is a factory for creating encrypted mail. Because we want to create a response, we pass in the original mail to postOffice and it will give us an instance which is configured to encrypt mail back to the sender. It will also use the same topic as the original mail. encryptMail will encrypt the reversed bytes and add on the authenticated header. The resulting mail bytes are passed to postMail which delivers it to the host. It will emerge in a callback we're about to configure. Tip You can post mail anytime and to anyone you like. It doesn't have to be a response to the sender, you can post multiple mails at once and you can post mails inside receiveFromUntrustedHost (i.e. during a local call). Receiving and posting mail in the host \u00b6 Mail posted by an enclave appears in a callback we pass to EnclaveHost.start . Let's use a really simple implementation: we'll just store the encrypted bytes in a variable, so we can pick it up later. Replace the call to EnclaveHost.start in the main function of your Host class with this snippet: 1 2 3 4 5 6 7 8 9 // Start it up. AtomicReference < byte []> mailToSend = new AtomicReference <> (); enclave . start ( new AttestationParameters . DCAP (), ( commands ) -> { for ( MailCommand command : commands ) { if ( command instanceof MailCommand . PostMail ) { mailToSend . set ((( MailCommand . PostMail ) command ). getEncryptedBytes ()); } } }); Java doesn't let us directly change variables from a callback, so we use an AtomicReference here as a box. Tip Kotlin lets you alter mutable variables from callbacks directly, without needing this sort of trick. The callback is a list of MailCommand objects, and what we're interested in are requests for delivery which are represented as MailCommand.PostMail objects. They contain the encrypted mail bytes to send. More information about the mail commands can be found below . The enclave can provide a routing hint to tell the host where it'd like the message delivered. It's called a \"hint\" because the enclave must always remember that the host is untrusted. It can be arbitrarily malicious and could, for example, not deliver the mail at all, or it could deliver it to the wrong place. However if it does deliver it wrongly, the encryption will ensure the bogus recipient can't do anything with the mail. In this simple hello world tutorial we can only handle one client at once so we're going to ignore the routing hint here. In a more sophisticated server your callback implementation can have access to your connected clients, a database, a durable queue, a ThreadLocal containing a servlet connection and so on. At the bottom of our main method let's add some code to accept TCP connections and send the EnclaveInstanceInfo to whomever connects. You will also need to add throws IOException to the method signature of main . Then we'll accept a mail uploaded by the client, send it to the enclave, and deliver the response back. We'll write the client code in a moment. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int port = 9999 ; System . out . println ( \"Listening on port \" + port + \". Use the client app to send strings for reversal.\" ); ServerSocket acceptor = new ServerSocket ( port ); Socket connection = acceptor . accept (); // Just send the attestation straight to whoever connects. It's signed so that's MITM-safe. DataOutputStream output = new DataOutputStream ( connection . getOutputStream ()); output . writeInt ( attestationBytes . length ); output . write ( attestationBytes ); // Now read some mail from the client. DataInputStream input = new DataInputStream ( connection . getInputStream ()); byte [] mailBytes = new byte [ input . readInt () ] ; input . readFully ( mailBytes ); // Deliver it. The enclave will give us some mail to reply with via the callback we passed in // to the start() method. enclave . deliverMail ( 1 , mailBytes , \"routingHint\" ); byte [] toSend = mailToSend . getAndSet ( null ); output . writeInt ( toSend . length ); output . write ( toSend ); This code is straightforward. In order, it: Opens a socket using the Java sockets API and listens for a connection. Accepts a connection and then sends the serialized EnclaveInstanceInfo to the client. We first send the length so the client knows how many bytes to read. The client will send us a byte array back, which contains an encrypted string. This code can't read the body, it's just encrypted bytes except for a few fields in the headers, which are available to the host. We deliver the encrypted mail bytes to the enclave. We pick up the response from the AtomicReference box that was set by the callback. The first parameter to deliverMail is a \"mail ID\" that the enclave can use to identify this mail to the host. This feature is intended for use with acknowledgement, which allows the enclave to signal that it's done with that message and the work it represents can be atomically/transactionally completed. The routing hint is an arbitrary string that can be used to identify the sender of the mail from the host's perspective, e.g. a connection ID, username, identity - it's up to you. The enclave can use this string to signal to the host that a mail should go to that location. It's called a \"hint\" to remind you that the host code may be modified or written by an attacker, so the enclave can't trust it. However, the encryption on the mail makes it useless for the host to mis-direct mail. Todo In future we will provide APIs to bind enclaves to common transports, to avoid this sort of boilerplate. Mail commands \u00b6 The second parameter to EnclaveHost.start is a callback which returns a list of MailCommand objects from the enclave. There are three commands the host can receive: Post mail . This is when the enclave wants to send mail over the network to a client. The enclave may provide a routing hint with the mail to help the host route the message. The host is also expected to safely store the message in case the enclave is restarted. If that happens then it needs to redeliver all the (unacknowledged) mail back to the enclave in order. Acknowledge mail . This is when the enclave no longer needs the mail to be redelivered to it on restart and the host is thus expected to delete it from its store. There are many reasons why an enclave may not want a message redelivered. For example, the conversation with the client has reached its end and so it acknowledges all the mail in that thread; or the enclave can checkpoint in the middle by creating a mail to itself which condenses all the previous mail, which are then all acknowledged. AcknowledgementReceipt . The enclave will also send this when acknowledging mail. When the host deletes acknowledged mails, the remaining mails will not be in the default sequence (consecutive integers starting from 0). In addition to deleting acknowledged mail, the host has to keep the receipt data and present it to host.start() at the next enclave restart, so the enclave knows what sequence to expect. The host receives these commands grouped together within the scope of a single EnclaveHost.deliverMail or EnclaveHost.callEnclave call. This allows the host to add transactionality when processing the commands. So for example, the delivery of the mail from the client to the enclave and the subsequent reply back can be processed atomically within the same database transaction when the host is providing persistent, durable messaging. Likewise the acknowledgement of any mail can occur within the same transaction. Writing the client \u00b6 The client app will do three things: Connect to the host server and download the EnclaveInstanceInfo from it. Verify the enclave is acceptable: i.e. that it will do what's expected. Send it the command line arguments as a string to reverse and get back the answer, using encrypted mail. Here's the initial boilerplate to grab the user input, connect, download and deserialize the EnclaveInstanceInfo . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import com.r3.conclave.client.InvalidEnclaveException ; import com.r3.conclave.common.EnclaveInstanceInfo ; import java.io.DataInputStream ; import java.io.IOException ; import java.net.Socket ; public class Client { public static void main ( String [] args ) throws IOException , InvalidEnclaveException { if ( args . length == 0 ) { System . err . println ( \"Please pass the string to reverse on the command line\" ); return ; } String toReverse = String . join ( \" \" , args ); // Connect to the host, it will send us a remote attestation (EnclaveInstanceInfo). Socket socket = new Socket ( \"localhost\" , 9999 ); DataInputStream fromHost = new DataInputStream ( socket . getInputStream ()); byte [] attestationBytes = new byte [ fromHost . readInt () ] ; fromHost . readFully ( attestationBytes ); EnclaveInstanceInfo attestation = EnclaveInstanceInfo . deserialize ( attestationBytes ); } } Constraints \u00b6 How do you know the EnclaveInstanceInfo you've got is for the enclave you really intend to interact with? In normal client/server programming you connect to a host using some sort of identity, like a domain name or IP address. TLS is used to ensure the server that picks up is the rightful owner of the domain name you intended to connect to. In enclave programming the location of the enclave might not matter much because the host is untrusted. Instead you have to verify what is running, rather than where it's running. Note The domain name of the server can still be important in some applications, in which case you should use TLS instead of raw sockets as is the case here. One way to do this is by inspecting the properties on the EnclaveInstanceInfo object and hard-coding some logic. That works fine, but testing an EnclaveInstanceInfo is a common pattern in enclave programming, so we provide an API to do it for you. The EnclaveConstraint class takes an EnclaveInstanceInfo and performs some matching against it. A constraint object can be built in code, or it can be loaded from a small domain specific language encoded as a one-line string. The string form is helpful if you anticipate frequent upgrades that should be whitelisted or other frequent changes to the acceptable enclave, as it can be easily put into a configuration file, JSON, XML or command line flags. The constraint lets you specify: Acceptable code hashes (measurements) Acceptable signing public keys The minimum revocation level The product ID The security level of the instance: SECURE , STALE , INSECURE If you specify a signing public key then you must also specify the product ID, otherwise if the organisation that created the enclave makes a second different kind of enclave in future, a malicious host might connect you with the wrong one. If the input/output commands are similar then a confusion attack could be opened up. That's why you must always specify the product ID even if it's zero. The simplest possible string-form constraint looks like this: C:F86798C4B12BE12073B87C3F57E66BCE7A541EE3D0DDA4FE8853471139C9393F It says \"accept exactly one program, with that measurement hash\". In this case the value came from the output of the build process as shown above. This is useful when you don't trust the author nor host of the enclave, and want to audit the source code and then reproduce the build. Often that's too rigid. We trust the developer of the enclave, just not the host. In that case we'll accept any enclave signed by the developer's public key. We can express that by listing code signing key hashes, like this: S:01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B PROD:1 When constraining to a signing key we must also specify the product ID, because a key can be used to sign more than one product. Add this line to the end of the client's main method: 1 2 // Check it's the enclave we expect. This will throw InvalidEnclaveException if not valid. EnclaveConstraint . parse ( \"S:01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B PROD:1 SEC:INSECURE\" ). check ( attestation ); Tip Replace the signing key in the snippet above with the enclave signer hash that was printed when you built the enclave . This line of code parses a simple constraint that says any enclave (even if run in simulation mode) signed by this hash of a code signing key with product ID of 1 is acceptable. Obviously in a real app, you would remove the part that says SEC:INSECURE , but it's convenient to have this whilst developing. You'd probably also retrieve the constraint from a configuration file, system property or command line flag. Finally it uses the check method with the attestation object. If anything is amiss an exception is thrown, so past this point we know we're talking to the real ReverseEnclave we wrote earlier. Tip If needed, more than one key hash could be added to the list of enclave constraints (e.g. if simulation and debug modes use a distinct key from release mode). The enclave is accepted if one key hash matches. 1 2 3 // Below, two distinct signing key hashes can be accepted. EnclaveConstraint . parse ( \"S:5124CA3A9C8241A3C0A51A1909197786401D2B79FA9FF849F2AA798A942165D3 \" + \"S:01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B PROD:1 SEC:INSECURE\" ). check ( attestation ); If you are building an enclave in mock mode then the enclave reports it is using a signing key hash consisting of all zeros. If you want to allow a mock enclave to pass the constraint check then you need to include this dummy signing key in your constraint: 1 2 3 4 // Below, two distinct signing key hashes or the zero dummy hash can be accepted. EnclaveConstraint . parse ( \"S:5124CA3A9C8241A3C0A51A1909197786401D2B79FA9FF849F2AA798A942165D3 \" + \"S:01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B\" + \"S:0000000000000000000000000000000000000000000000000000000000000000 PROD:1 SEC:INSECURE\" ). check ( attestation ); Keys and mail \u00b6 The client wants to receive a response from the enclave, and we want that to be encrypted/tamperproofed too. That means it need a key pair of its own. Conclave uses Curve25519, a state of the art elliptic curve algorithm. For reasons of implementation robustness and avoidance of side channel attacks, this is the only algorithm supported by Conclave Mail. If you want to use other algorithms for some reason you would need to implement your own messaging system on top of host-local calls. Alternatively, use that other algorithm to encrypt/decrypt a Curve25519 private key. Generating such a key is straightforward: 1 PrivateKey myKey = Curve25519PrivateKey . random (); Unfortunately the Java Cryptography Architecture only introduced official support for Curve25519 in Java 11. At the moment in Conclave therefore, you must utilize our Curve25519PublicKey and Curve25519PrivateKey classes. In future we may offer support for using the Java 11 JCA types directly. A Curve25519 private key is simply 32 random bytes, which you can access using the getEncoded() method on PrivateKey . Now we have a key with which to receive the response, we create a mail to the enclave. This is done using the EnclaveInstanceInfo.createPostOffice method, which returns a new PostOffice object. This is similar to the post office inside the enclave and let's us create mail with increasing sequence numbers. We pass in our private key when creating the post office so it's mixed in to the calculations when the mail is encrypted and thus becomes available in getAuthenticatedSender() inside the enclave. 1 2 PostOffice postOffice = attestation . createPostOffice ( myKey , \"reverse\" ); byte [] encryptedMail = postOffice . encryptMail ( toReverse . getBytes ( StandardCharsets . UTF_8 )); We've chosen a topic value of \"reverse\" but any will do as the client uses a random key and only sends one mail using it. However, if a client needs to send multiple mail which are related to each other such that it's important they reach the enclave in the same order then these mail need to all use the same topic and private key. In other words, they need to be created from the same PostOffice instance. The enclave will automatically detect any dropped or reordered messages and throw an exception. Tip Make sure there's only one PostOffice instance per (destination public key, sender private key, topic) triple. This can be done very easily in Kotlin by using a data class with these three properties as a key to a HashMap . The same can be done in Java except it will be slightly more verbose as you will need to override the equals and hashCode methods of your key class. Modern IDEs let you do this very quickly. In more complex apps it might be smart to use the topic in more complex ways, like how a web app can use the URL to separate different functions of the app. Now we have an encrypted message we can write it to the socket and receive the enclave's response. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 System . out . println ( \"Sending the encrypted mail to the host.\" ); DataOutputStream toHost = new DataOutputStream ( socket . getOutputStream ()); toHost . writeInt ( encryptedMail . length ); toHost . write ( encryptedMail ); // Enclave will mail us back. byte [] encryptedReply = new byte [ fromHost . readInt () ] ; System . out . println ( \"Reading reply mail of length \" + encryptedReply . length + \" bytes.\" ); fromHost . readFully ( encryptedReply ); // The same post office will decrypt the response. EnclaveMail reply = postOffice . decryptMail ( encryptedReply ); System . out . println ( \"Enclave reversed '\" + toReverse + \"' and gave us the answer '\" + new String ( reply . getBodyAsBytes ()) + \"'\" ); socket . close (); We write out the length of the mail, then the mail bytes, then read the length of the response and read the response bytes. Finally we use PostOffice.decryptMail on the same instance we used to create our request, passing in the encrypted reply. This method decrypts the bytes using our private key, checks they really did come from that enclave (by checking the authenticated sender key against the enclave's public key in the attestation), decodes the bytes and yields the reply. We can then access the body of the message using EnclaveMail.getBodyAsBytes() . Finally we close the socket, and we're done. Phew! \ud83d\ude05 Testing \u00b6 There are two ways you can test the enclave: using a mock build of the enclave in tests defined as part of your enclave project, or integrating enclave tests in your host project. Mock tests within the enclave project \u00b6 Conclave supports building and running tests within the enclave project itself. When you define tests as part of your enclave project, the enclave classes are loaded along with the tests. Conclave detects this configuration and automatically enables mock mode for the enclave and test host. You do not need to explicitly specify mock mode for your project. This allows you to whitebox test your enclave by running it fully in-memory. There is no need for SGX hardware or a specific OS and thus it is ideal for cross-platform unit testing. To enable mock mode in your enclave project tests you need to include the following test dependency in your enclave module build.gradle file. 1 testImplementation \"com.r3.conclave:conclave-host\" You can then create an instance of the enclave as normal by calling EnclaveHost.load . 1 2 EnclaveHost mockHost = EnclaveHost . load ( \"com.r3.conclave.sample.enclave.ReverseEnclave\" ); mockHost . start ( null , null ); Conclave will detect that the enclave class is on the classpath and will start the enclave in mock mode. You can obtain the enclave instance using the EnclaveHost.mockEnclave property. 1 ReverseEnclave reverseEnclave = ( ReverseEnclave ) mockHost . getMockEnclave (); Integrating enclave tests in your host project \u00b6 When you want to test your enclave on real SGX hardware or in a simulated SGX environment you need to define your tests in a project separate from the enclave project. A suitable place for your tests would be to define them as part of the host project tests. Loading and testing the enclave on real hardware or in a simulated SGX environment is straightforward: the enclave needs to be loaded with EnclaveHost.load . By default this will run the tests in a simulated SGX environment and will require the tests to be executed within Linux. In addition, testing on real hardware will require the tests to be executed within Linux on a system that supports SGX. 1 2 3 4 5 6 7 8 9 10 @EnabledOnOs ( OS . LINUX ) public class NativeTest { private static EnclaveHost enclave ; @BeforeAll static void startup () throws EnclaveLoadException { enclave = EnclaveHost . load ( \"com.r3.conclave.sample.enclave.ReverseEnclave\" ); enclave . start ( new AttestationParameters . DCAP (), null ); } } You'll notice that we annotated the test class with @EnabledOnOs(OS.LINUX) . This is from JUnit 5 and it will make sure the native test isn't run on non-Linux environments. The tests can use any enclave mode: release, debug, simulation or mock. Therefore if you want to run your tests on a non-Linux system then you can configure your tests to depend on a mock mode enclave instead. In this case, remove the @EnabledOnOs(OS.LINUX) annotation from the above code. Note Running your integration tests in mock mode is very similar to Integrating enclave tests in your host project . In both cases the enclave code is loaded and run fully in memory. However for integration tests, you can also choose to run the tests in modes other than mock, which is not possible for enclave project tests. Running 1 ./gradlew host:test will execute the test using a simulation enclave, or not at all if the OS is not Linux. You can switch to a debug enclave and test on real secure hardware by using the -PenclaveMode flag: 1 ./gradlew -PenclaveMode=debug host:test Or you can use a mock enclave and test on a non-Linux platform by removing @EnabledOnOs(OS.LINUX) and by running this command: 1 ./gradlew -PenclaveMode=mock host:test Tip To run the tests in a simulated SGX environment on a non-Linux machine you can use Docker, which manages Linux VMs for you. See the instructions for compiling and running the host for more information.","title":"Writing your first enclave"},{"location":"writing-hello-world.html#writing-the-sample-enclave","text":"The sample \"hello world\" enclave just reverses whatever string is passed into it. We'll do these things to make our own version of the hello enclave project: Configure Gradle. At this time Conclave projects must use Gradle as their build system. Implement an enclave object that accepts both local calls from the host, and encrypted messages from a client. Write the host program that loads the enclave. Run the host and enclave in simulation and debug modes. Write the client that sends the enclave encrypted messages via the host.","title":"Writing the sample enclave"},{"location":"writing-hello-world.html#configure-your-modules","text":"Create a new Gradle project via whatever mechanism you prefer, e.g. IntelliJ can do this via the New Project wizard. Create three modules defined in the project: one for the host, one for the enclave and one for the client. The host program may be an existing server program of some kind, e.g. a web server, but in this tutorial we'll write a command line host. The client may likewise be a GUI app or integrated with some other program (like a server), but in this case to keep it simple the client will also be a command line app.","title":"Configure your modules"},{"location":"writing-hello-world.html#root-settingsgradle-file","text":"In the unzipped SDK there is a directory called repo that contains a local Maven repository. This is where the libraries and Gradle plugin can be found. We need to tell Gradle to look there for plugins. Create or modify a file called settings.gradle in your project root directory so it looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 pluginManagement { repositories { maven { def repoPath = file ( rootDir . relativePath ( file ( conclaveRepo ))) if ( repoPath == null ) throw new Exception ( \"Make sure the 'conclaveRepo' setting exists in gradle.properties, or your \\$HOME/gradle.properties file. See the Conclave tutorial on https://docs.conclave.net\" ) else if (! new File ( repoPath , \"com\" ). isDirectory ()) throw new Exception ( \"The $repoPath directory doesn't seem to exist or isn't a Maven repository; it should be the SDK 'repo' subdirectory. See the Conclave tutorial on https://docs.conclave.net\" ) url = repoPath } // Add standard repositories back. gradlePluginPortal () jcenter () mavenCentral () } plugins { id 'com.r3.conclave.enclave' version conclaveVersion apply false } } include 'enclave' include 'host' include 'client' This boilerplate is unfortunately necessary to copy/paste into each project that uses Conclave. It sets up Gradle to locate the plugin that configures the rest of the boilerplate build logic for you The pluginManagement block tells Gradle to use a property called conclaveRepo to find the repo directory in your SDK download. Because developers on your team could unpack the SDK anywhere, they must configure the path before the build will work. The code above will print a helpful error if they forget or get it wrong. To set the value, add a couple of lines to the gradle.properties file like this: 1 2 conclaveRepo=/path/to/sdk/repo conclaveVersion=1.1 Gradle properties can be set using a file in the project directory, or more usefully in the developer's home directory. You may wish to put the version in the project's gradle.properties file and the path in each developer's personal gradle.properties . Alternatively just add a sdk directory to the .gitignore and require everyone to unpack the SDK to the source tree.","title":"Root settings.gradle file"},{"location":"writing-hello-world.html#root-buildgradle-file","text":"Add the following code to your root build.gradle file to import the repository: 1 2 3 4 5 6 7 8 subprojects { repositories { maven { url = rootProject . file ( conclaveRepo ) } mavenCentral () } }","title":"Root build.gradle file"},{"location":"writing-hello-world.html#ide-documentation-in-the-root-buildgradle-file","text":"Some IDEs are able to automatically display Conclave SDK documentation whilst editing code. In order for this to work you may need to add some configuration to the root build.gradle depending on your IDE. Start by adding the Gradle plugin required to support your IDE. Note that Visual Studio Code shares the configuration provided by the eclipse plugin. 1 2 3 4 5 plugins { id 'java' id 'idea' id 'eclipse' } Then add sections to tell the IDEs to download Javadoc for dependencies. 1 2 3 4 5 6 7 8 9 10 11 eclipse { classpath { downloadJavadoc = true } } idea { module { downloadJavadoc = true } } Finally apply the same configuration to all subprojects. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 subprojects { apply plugin: 'idea' apply plugin: 'eclipse' idea { module { downloadJavadoc = true } } eclipse { classpath { downloadJavadoc = true } } repositories { Info At the moment, IntelliJ IDEA has an issue that means it does not correctly display the documentation for Conclave, even if you provide this configuration. Instead, please refer to the online Javadocs for Conclave.","title":"IDE Documentation in the root build.gradle file"},{"location":"writing-hello-world.html#configure-the-host-module","text":"Add this bit of code to your host build.gradle file to let the mode be chosen from the command line: 1 2 // Override the default (simulation) with -PenclaveMode= def mode = findProperty ( \"enclaveMode\" )?. toString ()?. toLowerCase () ?: \"simulation\" We can apply the Gradle application plugin and set the mainClassName property in the usual manner to let us run the host from the command line: 1 2 3 4 5 6 7 8 plugins { id 'java' id 'application' } application { mainClassName = \"com.superfirm.host.Host\" // CHANGE THIS } Then add the following dependencies, also to the host's build.gradle : 1 2 3 4 5 6 7 dependencies { implementation \"com.r3.conclave:conclave-host:$conclaveVersion\" runtimeOnly project ( path: \":enclave\" , configuration: mode ) runtimeOnly \"org.slf4j:slf4j-simple:1.7.30\" testImplementation \"org.junit.jupiter:junit-jupiter:5.6.0\" } This says that at runtime (but not compile time) the :enclave module must be on the classpath, and configures dependencies to respect the three different variants of the enclave. That is, the enclave module will expose tasks to compile and use either mock, simulation, debug or release mode. Which task to use is actually selected by the host build. Tip Don't worry if you see the error Could not resolve project :enclave . This will be resolved when we configure the enclave module in the next section. For this simple tutorial we also add a runtime-only dependency on the popular SLF4J library which Conclave uses to do logging. SLF4J enables you to send Conclave's logging to any of the major logging frameworks used in Java, but here, we add the \"simple\" backend which just causes it to log to the console. Finally we configure unit testing using JUnit 5. If you intend to use an external signing process to sign your enclave then add the following lines to the Gradle file: 1 2 3 4 // Create a task that can be used for generating signing materials tasks . register ( \"prepareForSigning\" ) { it . dependsOn ( \":enclave:generateEnclaveSigningMaterial\" + mode . capitalize ()) } This creates a new task that can be invoked using Gradle to halt the build after generating materials that need to be signed by an external signing process. After the material has been signed the build can be resumed.","title":"Configure the host module"},{"location":"writing-hello-world.html#configure-the-enclave-module","text":"Add the Conclave Gradle plugin to your enclave build.gradle file: 1 2 3 plugins { id 'com.r3.conclave.enclave' } and a dependency on the Conclave enclave library and a test dependency on the Conclave host library: 1 2 3 4 5 dependencies { implementation \"com.r3.conclave:conclave-enclave\" testImplementation \"com.r3.conclave:conclave-host\" testImplementation \"org.junit.jupiter:junit-jupiter:5.6.0\" } This time you don't have to specify the Conclave version because the plugin will set that for you automatically. Specify the enclave's runtime environment, product ID and revocation level: 1 2 3 4 conclave { productID = 1 revocationLevel = 0 } These settings are described in detail in the page on enclave configuration . A summary of these settings follows: Conclave needs access to a Linux build environment in order to build enclaves. On MacOS and Windows this is automatically created during the build process using Docker. If you do not have Docker installed then the build will generate an error prompting you to install Docker on your system. Once Docker is installed and added to your PATH environment variable you can proceed to build Simulation, Debug or Release mode enclaves. Docker is not required if you are using a Linux system. The product ID is an arbitrary number that can be used to distinguish between different enclaves produced by the same organisation (which may for internal reasons wish to use a single signing key). This value should not change once you have picked it. The revocation level should be incremented if a weakness in the enclave code is discovered and fixed; doing this will enable clients to avoid connecting to old, compromised enclaves. The revocation level should not be incremented on every new release, but only when security improvements have been made.","title":"Configure the enclave module"},{"location":"writing-hello-world.html#signing-keys","text":"Specify the signing methods for each of the build types. You could keep your private key in a file for both debug and release enclaves if you like, but some organisations require private keys to be held in an offline system or HSM. In that case, configure it like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 conclave { productID = 1 revocationLevel = 0 // For simulation, we want to use the default signing type of dummyKey so // we do not need to specify a configuration. debug { signingType = privateKey signingKey = file ( \"../signing/sample_private_key.pem\" ) } release { // To protect our release private key with an HSM, the enclave needs to be built in stages. // Firstly, build the signing material: // ./gradlew prepareForSigning -PenclaveMode=\"Release\" // // Generate a signature from the signing material. // // Finally build the signed enclave: // ./gradlew build -PenclaveMode=\"Release\" // signingType = externalKey signatureDate = new Date ( 1970 , 0 , 1 ) mrsignerSignature = file ( \"../signing/signature.bin\" ) mrsignerPublicKey = file ( \"../signing/external_signing_public.pem\" ) } } The example configuration above specifies different signing configurations for each of the different build types. Simulation builds use the default dummy key. Debug builds use a private key stored in a file. Release builds use a private key managed by some external signing process. The hello-world sample in the SDK contains some example keys that can be used with the privateKey and externalKey signing types. These can be found in hello-world/signing/ . Key Files Description sample_private_key.pem A 3072 bit RSA private key that can be used to test the privateKey signing type external_signing_*.pem An AES encrypted 3072 bit RSA public/private key pair that can be used to test the externalKey signing type. The private key can be accessed with the password '12345' Copy the signing directory from the SDK into your project and/or update the paths in the enclave build.gradle . Alternatively you can provide or generate your own keys. Important These keys aren't whitelisted by Intel so you can't use them for real release builds. Only use these sample keys for the tutorial. Don't use them for signing your own enclaves!","title":"Signing keys"},{"location":"writing-hello-world.html#configure-the-client-module","text":"The client module is the simplest of all. This is literally a bog-standard hello world command line app Gradle build, with a single dependency on the Conclave client library: 1 2 3 4 5 6 7 8 9 10 11 12 plugins { id 'java' id 'application' } application { mainClassName = \"com.superfirm.client.Client\" // CHANGE THIS } dependencies { implementation \"com.r3.conclave:conclave-client:$conclaveVersion\" } And with that, we're done configuring the module.","title":"Configure the client module"},{"location":"writing-hello-world.html#create-a-new-subclass-of-enclave","text":"Enclaves are similar to standalone programs and as such have an equivalent to a \"main class\". This class must be a subclass of Enclave . Create your enclave class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.superfirm.enclave // CHANGE THIS import com.r3.conclave.enclave.Enclave ; /** * Simply reverses the bytes that are passed in. */ public class ReverseEnclave extends Enclave { @Override public byte [] receiveFromUntrustedHost ( byte [] bytes ) { byte [] result = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) result [ i ] = bytes [ bytes . length - 1 - i ] ; return result ; } } The Enclave class by itself doesn't require you to support direct communication with the host. This is because sometimes you don't need that and shouldn't have to implement message handlers. In this case we'll use that functionality because it's a good place to start learning, so we also override and implement the receiveFromUntrustedHost method which takes a byte array and optionally returns a byte array back. Here we just reverse the contents. Tip In a real app you would use the byte array to hold serialised data structures. You can use whatever data formats you like. You could use a simple string format or a binary format like protocol buffers.","title":"Create a new subclass of Enclave"},{"location":"writing-hello-world.html#threading","text":"In this tutorial we won't write a multi-threaded enclave. If you want to do this, you'll need to override the boolean isThreadSafe() method in the Enclave class (use override val threadSafe: Boolean get() = true in Kotlin). This tells Conclave to allow multiple threads into the enclave simultaneously. You're required to opt-in to allowing multi-threading to avoid accidents when someone writes a simple enclave that isn't thread safe, and forgets that the host is malicious and can enter your code with multiple threads simultaneously even if you aren't ready for it, corrupting your application level data via race conditions. By blocking multi-threading until you indicate readiness, the hope is that some types of attack can be avoided. See the page on enclave threading to learn more.","title":"Threading"},{"location":"writing-hello-world.html#write-a-simple-host-program","text":"An enclave by itself is just a library: you must therefore load it from inside a host program. It's easy to load then pass data to and from an enclave. Let's start with the skeleton of a little command line app: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.superfirm.host // CHANGE THIS import com.r3.conclave.host.EnclaveHost ; import com.r3.conclave.host.EnclaveLoadException ; /** * This class demonstrates how to load an enclave and use it. */ public class Host { public static void main ( String [] args ) throws EnclaveLoadException { // TODO: Fill this out } public static String callEnclave ( EnclaveHost enclave , String input ) { // TODO: Fill this out. } } At first we will be building and running our enclave in simulation mode. This does not require the platform hardware to support SGX. However simulation mode does require us to be using Linux. If we are not using Linux as our host OS then we can use a Linux container or virtual machine as described in Running the host . Alternatively we could use mock mode instead of simulation mode. When we want to switch to loading either a debug or release build of the enclave we need to ensure the platform supports SGX. By adding the code below to the main method we can determine whether the platform can load debug and release enclaves. This method reports the actual hardware status even if you are currently working with mock or simulation enclaves. 1 2 3 4 5 6 7 8 public static void main ( String [] args ) throws EnclaveLoadException { try { EnclaveHost . checkPlatformSupportsEnclaves ( true ); System . out . println ( \"This platform supports enclaves in simulation, debug and release mode.\" ); } catch ( EnclaveLoadException e ) { System . out . println ( \"This platform does not support hardware enclaves: \" + e . getMessage ()); } } If SGX is not supported the function throws an exception which describes the reason why. There are a number of common reasons why SGX may not be supported including: The CPU or the system BIOS does not support SGX. The host operating system is Windows or Mac OS. Conclave currently only supports loading enclaves in simulation, debug or release modes on Linux. SGX is disabled in the BIOS and must be manually enabled by the user. SGX is disabled but can be enabled in software. If SGX is disabled but can be enabled in software the code below attempts to automatically enable SGX support by specifying the 'true' parameter. It might be necessary to run this application with root access and/or reboot the system in order to successfully enable SGX. The exception message will describe if this is the case. To load the enclave we'll put this after the platform check: 1 2 3 4 5 6 7 8 9 String className = \"com.superfirm.enclave.ReverseEnclave\" // CHANGE THIS try ( EnclaveHost enclave = EnclaveHost . load ( className )) { enclave . start ( null , null ); System . out . println ( callEnclave ( enclave , \"Hello world!\" )); // !dlrow olleH :-) // TODO: Get the remote attestation } This code starts by creating an EnclaveHost object. This names the class and then attempts to load it inside another JVM running inside an enclave. A remote attestation procedure is then performed involving Intel's servers. This procedure can fail if attempting to load a debug or release enclave and the platform does not support SGX. This is why it is important to perform the platform check we made in the code above. If the enclave does fail to load for any reason then an exception is thrown describing the reason why. Tip You can use the command EnclaveHost.getCapabilitiesDiagnostics() to print out some diagnostic information about the CPU, which can be helpful for troubleshooting. We then call start which initialises the enclave and the MyEnclave class inside it. You can load multiple enclaves at once but they must all use same mode, and each enclave will get its own isolated JVM. Note that an EnclaveHost allocates memory out of a pool called the \"enclave page cache\" which is a machine-wide limited resource. It'll be freed if the host JVM quits, but it's good practice to close the EnclaveHost object by calling close on it when done. Therefore we also make sure the .close() method is called on the enclave no matter what using a try-with-resources statement. This doesn't actually matter in such a tiny hello world sample, because the enclave will be unloaded by the kernel once we exit like any other resource. It's just here to remind you that an enclave must be explicitly unloaded if you need to reinitialise it for whatever reason, or if you need the memory back. Warning Starting and stopping/closing an enclave is not free, so don't load the enclave, use it and immediately close it again as in the above example. Cost-wise it's like starting a regular process even though no process will actually exist. Treat the enclave like any other expensive resource and keep it around for as long as you might need it. Once we started the enclave, we call it passing in a string as bytes. The enclave will reverse it and we'll print out the answer. This is as easy as calling EnclaveHost.callEnclave , so put this in the callEnclave static method defined above: 1 2 // We'll convert strings to bytes and back. return new String ( enclave . callEnclave ( input . getBytes ())); So we just convert the string to bytes, send it to the enclave, and convert the response from bytes back to a string.","title":"Write a simple host program"},{"location":"writing-hello-world.html#remote-attestation","text":"There's no point in using an enclave to protect purely local data, as the data must ultimately come from the (assumed malicious/compromised) host in that scenario. That's why you need remote attestation, which lets an enclave prove its identity to the third parties who will upload secret data. If this paragraph doesn't make sense please review the Architecture overview and the Enclaves section. Before we can set up communication with a client, we must therefore get remote attestation working. Using remote attestation is easy! Just obtain an EnclaveInstanceInfo and serialize/deserialize it using the provided methods. Add these lines to the end of the main function of your Host class: 1 2 3 final EnclaveInstanceInfo attestation = enclave . getEnclaveInstanceInfo (); final byte [] attestationBytes = attestation . serialize (); System . out . println ( EnclaveInstanceInfo . deserialize ( attestationBytes )); The EnclaveInstanceInfo has a useful toString function that will print out something like this: 1 2 3 4 5 6 7 8 9 10 Remote attestation for enclave F86798C4B12BE12073B87C3F57E66BCE7A541EE3D0DDA4FE8853471139C9393F: - Mode: SIMULATION - Code signing key hash: 01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B - Public signing key: 302A300506032B65700321000568034F335BE25386FD405A5997C25F49508AA173E0B413113F9A80C9BBF542 - Public encryption key: A0227D6D11078AAB73407D76DB9135C0D43A22BEACB0027D166937C18C5A7973 - Product ID: 1 - Revocation level: 0 Assessed security level at 2020-07-17T16:31:51.894697Z is INSECURE - Enclave is running in simulation mode. The hash in the first line is the measurement . This is a hash of the code of the enclave. It includes both all the Java code inside the enclave as a fat-JAR, and all the support and JVM runtime code required. As such it will change any time you alter the code of your enclave, the version of Conclave in use or the mode (simulation/debug/release) of the enclave. The enclave measurement should be stable across builds and machines, so clients can audit the enclave by repeating the Gradle build and comparing the value they get in the EnclaveInstanceInfo against what the build process prints out. Tip All this data is available via individual getters on the EnclaveInstanceInfo so you should never feel a need to parse the output of toString . EnclaveInstanceInfo is an interface so you can easily build mock attestations in your tests. When not in simulation mode the timestamp is signed by Intel and comes from their servers. An instance has a security assessment, which can change in response to discovery of vulnerabilities in the infrastructure (i.e. without anything changing about the host or enclave itself). As we can see this enclave isn't actually considered secure yet because we're running in simulation mode still. An enclave can be SECURE , STALE , or INSECURE . A assessment of STALE means there is a software/firmware/microcode update available for the platform that improves security in some way. The client may wish to observe when this starts being reported and define a time span in which the remote enclave operator must upgrade. We can send the serialized bytes to a client via whatever network mechanism we want. The bytes are essentially a large, complex digital signature, so it's safe to publish them publicly. For simplicity in this tutorial we are just going to copy them manually and hard-code them in the client, but more on that later . An attestation doesn't inherently expire but because the SGX ecosystem is always moving, client code will typically have some frequency with which it expects the host code to refresh the EnclaveInstanceInfo . At present this is done by stopping/closing and then restarting the enclave.","title":"Remote attestation"},{"location":"writing-hello-world.html#configure-attestation","text":"To use SGX remote attestation for real we need to do some additional work. Remember how we wrote enclave.start(null, null); above? The first parameter contains configuration data required to use an attestation service. There are three kinds of attestation service: EPID. This older protocol is supported by some desktop/laptop class Intel CPUs. The EPID protocol includes some consumer privacy cryptography, and involves talking directly to Intel's IAS service to generate an attestation. For that you need to obtain an API key and service provider ID from Intel. You can sign-up easily and for free. Learn more about IAS . Please note that Intel does not provide EPID attestation support for Xeon scalable CPUs including Ice Lake and future generations. You need to use DCAP attestation on these platforms. Azure DCAP. The datacenter attestation primitives protocol is newer and designed for servers. When running on a Microsoft Azure Confidential Compute VM or Kubernetes pod, you don't need any parameters. It's all configured out of the box. Generic DCAP. When not running on Azure, you need to obtain API keys for Intel's PCCS service. We'll target Azure for now to keep things simple. Replace the call to EnclaveHost.start above with this snippet: 1 enclave . start ( new AttestationParameters . DCAP (), null ); Info Why does Conclave need to contact Intel's servers? It's because those servers contain the most up to date information about what CPUs and system enclave versions are considered secure. Over time these servers will change their assessment of the host system and this will be visible in the responses, as security improvements are made.","title":"Configure attestation"},{"location":"writing-hello-world.html#run-what-weve-got-so-far","text":"Now everything should be ready to run the host from the command line. Run gradlew host:run and it should print \"Hello World!\" backwards along with the security info as shown above. Note If you are using Windows or macOS then please follow the instructions for your operating system, which you can find in the Running the host section. During the build you should see output like this: 1 2 3 4 > Task :enclave:generateEnclaveMetadataSimulation Succeed. Enclave code hash: 61AE6A28838CE9EFBE16A7078F9A506D69BBA70B69FAD229F1FBDB45AA786109 Enclave code signer: 4924CA3A9C8241A3C0AA1A24A407AA86401D2B79FA9FF84932DA798A942166D4 The code hash will correspond to the value found in the EnclaveInstanceInfo.getEnclaveInfo().getCodeHash() property and the code signer will be EnclaveInstanceInfo.getEnclaveInfo().getCodeSigningKeyHash() . Tip Make a note of the value of Enclave code signer . We will need it later on to verify the enclave's identity from the client. You can switch to debug mode by specifying the enclaveMode property. In debug mode the real hardware is used and virtually everything is identical to how it will be in production, but there's a small back door that can be used by debuggers to read/write the enclave's memory. You will need to run this on an Azure Confidential VM . 1 ./gradlew -PenclaveMode = debug host:run","title":"Run what we've got so far"},{"location":"writing-hello-world.html#encrypted-messaging","text":"The enclave isn't of much use to the host, because the host already trusts itself. It's only useful to remote clients that want to use the enclave for computation without having to trust the host machine or software. We're now going to wire up encrypted messaging. Conclave provides an API for this called Mail. Conclave Mail handles all the encryption for you, but leaves it up to you how the bytes themselves are moved around. You could use a REST API, a gRPC API, JMS message queues, a simple TCP socket as in this tutorial, or even files. Info Learn more about the design of Conclave Mail , and compare it to TLS .","title":"Encrypted messaging"},{"location":"writing-hello-world.html#receiving-and-posting-mail-in-the-enclave","text":"Firstly we need to upgrade our little enclave to be able to receive mails from clients. This is easy! Just override the receiveMail method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Simply reverses the bytes that are passed in. */ public class ReverseEnclave extends Enclave { @Override public byte [] receiveFromUntrustedHost ( byte [] bytes ) { byte [] result = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { result [ i ] = bytes [ bytes . length - 1 - i ] ; } return result ; } @Override protected void receiveMail ( long id , EnclaveMail mail , String routingHint ) { byte [] reversed = receiveFromUntrustedHost ( mail . getBodyAsBytes ()); byte [] responseBytes = postOffice ( mail ). encryptMail ( reversed ); postMail ( responseBytes , routingHint ); } } The receiveFromUntrustedHost method here isn't really needed, it's just because we're already using this to demonstrate local calls. The new part is receiveMail . This method takes three parameters: the first is an identifier that the host gets to pick, which doesn't mean anything but we can use to acknowledge the mail if we want to using Enclave.acknowledgeMail . Acknowledgement can be used to tell the host the enclave is done processing the mail if it doesn't want to reply immediately. It will be discussed more in future tutorials. In this simple tutorial we reply immediately so don't need to use this feature, and thus we ignore the ID. The third parameter is a routing hint string. It's also provided by the host and it helps the host route replies when dealing with multiple clients. It's passed into postMail when the enclave posts a reply. In our example the host only deals with one client and so it's not used.","title":"Receiving and posting mail in the enclave"},{"location":"writing-hello-world.html#mail-headers","text":"The second parameter is an EnclaveMail . This object gives us access to the body bytes that the client sent, but it also exposes some other header fields: A topic . This can be used to distinguish between different streams of mail from the same client. It's a string and can be thought of as equivalent to an email subject. Topics are scoped per-sender and are not global. The client can send multiple streams of related mail by using a different topic for each stream, and it can do this concurrently. The topic is not parsed by Conclave and, to avoid replay attacks, should never be reused for an unrelated set of mails in the future. A good value might thus contain a random UUID. Topics may be logged and used by your software to route or split mail streams in useful ways. The sequence number . Starting from zero, this is incremented by one for every mail delivered on a topic. Conclave will automatically reject messages if this doesn't hold true, thus ensuring to the client that the stream of related mail is received by the enclave in the order they were sent, and that the host is unable to re-order or drop them. The envelope . This is a slot that can hold any arbitrary byte array the sender likes. It's a holding zone for app specific data that should be authenticated but unencrypted. These header fields are available to the host and therefore should not contain secrets . It may seem odd to have data that's unencrypted, but it's often useful for the client, host and enclave to collaborate in various ways related to storage and routing of data. Even when the host is untrusted it may still be useful for the client to send data that is readable by the host and enclave simultaneously, but which the host cannot tamper with. Inside the enclave you can be assured that the header fields contain the values set by the client, because they're checked before receiveMail is invoked. In addition to the headers there is also the authenticated sender public key . This is the public key of the client that sent the mail. Like the body it's encrypted so that the host cannot learn the client identities. It's called \"authenticated\" because the encryption used by Conclave means you can trust that the mail was encrypted by an entity holding the private key matching this public key. If your enclave recognises the public key this feature can be used as a form of user authentication. In this simple tutorial we only care about the body. We reverse the bytes in the mail body and then create a response mail that will be encrypted to the sender. It contains the reversed bytes. We use the postOffice method to do this. It gives us back a post office object, which is a factory for creating encrypted mail. Because we want to create a response, we pass in the original mail to postOffice and it will give us an instance which is configured to encrypt mail back to the sender. It will also use the same topic as the original mail. encryptMail will encrypt the reversed bytes and add on the authenticated header. The resulting mail bytes are passed to postMail which delivers it to the host. It will emerge in a callback we're about to configure. Tip You can post mail anytime and to anyone you like. It doesn't have to be a response to the sender, you can post multiple mails at once and you can post mails inside receiveFromUntrustedHost (i.e. during a local call).","title":"Mail headers"},{"location":"writing-hello-world.html#receiving-and-posting-mail-in-the-host","text":"Mail posted by an enclave appears in a callback we pass to EnclaveHost.start . Let's use a really simple implementation: we'll just store the encrypted bytes in a variable, so we can pick it up later. Replace the call to EnclaveHost.start in the main function of your Host class with this snippet: 1 2 3 4 5 6 7 8 9 // Start it up. AtomicReference < byte []> mailToSend = new AtomicReference <> (); enclave . start ( new AttestationParameters . DCAP (), ( commands ) -> { for ( MailCommand command : commands ) { if ( command instanceof MailCommand . PostMail ) { mailToSend . set ((( MailCommand . PostMail ) command ). getEncryptedBytes ()); } } }); Java doesn't let us directly change variables from a callback, so we use an AtomicReference here as a box. Tip Kotlin lets you alter mutable variables from callbacks directly, without needing this sort of trick. The callback is a list of MailCommand objects, and what we're interested in are requests for delivery which are represented as MailCommand.PostMail objects. They contain the encrypted mail bytes to send. More information about the mail commands can be found below . The enclave can provide a routing hint to tell the host where it'd like the message delivered. It's called a \"hint\" because the enclave must always remember that the host is untrusted. It can be arbitrarily malicious and could, for example, not deliver the mail at all, or it could deliver it to the wrong place. However if it does deliver it wrongly, the encryption will ensure the bogus recipient can't do anything with the mail. In this simple hello world tutorial we can only handle one client at once so we're going to ignore the routing hint here. In a more sophisticated server your callback implementation can have access to your connected clients, a database, a durable queue, a ThreadLocal containing a servlet connection and so on. At the bottom of our main method let's add some code to accept TCP connections and send the EnclaveInstanceInfo to whomever connects. You will also need to add throws IOException to the method signature of main . Then we'll accept a mail uploaded by the client, send it to the enclave, and deliver the response back. We'll write the client code in a moment. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int port = 9999 ; System . out . println ( \"Listening on port \" + port + \". Use the client app to send strings for reversal.\" ); ServerSocket acceptor = new ServerSocket ( port ); Socket connection = acceptor . accept (); // Just send the attestation straight to whoever connects. It's signed so that's MITM-safe. DataOutputStream output = new DataOutputStream ( connection . getOutputStream ()); output . writeInt ( attestationBytes . length ); output . write ( attestationBytes ); // Now read some mail from the client. DataInputStream input = new DataInputStream ( connection . getInputStream ()); byte [] mailBytes = new byte [ input . readInt () ] ; input . readFully ( mailBytes ); // Deliver it. The enclave will give us some mail to reply with via the callback we passed in // to the start() method. enclave . deliverMail ( 1 , mailBytes , \"routingHint\" ); byte [] toSend = mailToSend . getAndSet ( null ); output . writeInt ( toSend . length ); output . write ( toSend ); This code is straightforward. In order, it: Opens a socket using the Java sockets API and listens for a connection. Accepts a connection and then sends the serialized EnclaveInstanceInfo to the client. We first send the length so the client knows how many bytes to read. The client will send us a byte array back, which contains an encrypted string. This code can't read the body, it's just encrypted bytes except for a few fields in the headers, which are available to the host. We deliver the encrypted mail bytes to the enclave. We pick up the response from the AtomicReference box that was set by the callback. The first parameter to deliverMail is a \"mail ID\" that the enclave can use to identify this mail to the host. This feature is intended for use with acknowledgement, which allows the enclave to signal that it's done with that message and the work it represents can be atomically/transactionally completed. The routing hint is an arbitrary string that can be used to identify the sender of the mail from the host's perspective, e.g. a connection ID, username, identity - it's up to you. The enclave can use this string to signal to the host that a mail should go to that location. It's called a \"hint\" to remind you that the host code may be modified or written by an attacker, so the enclave can't trust it. However, the encryption on the mail makes it useless for the host to mis-direct mail. Todo In future we will provide APIs to bind enclaves to common transports, to avoid this sort of boilerplate.","title":"Receiving and posting mail in the host"},{"location":"writing-hello-world.html#mail-commands","text":"The second parameter to EnclaveHost.start is a callback which returns a list of MailCommand objects from the enclave. There are three commands the host can receive: Post mail . This is when the enclave wants to send mail over the network to a client. The enclave may provide a routing hint with the mail to help the host route the message. The host is also expected to safely store the message in case the enclave is restarted. If that happens then it needs to redeliver all the (unacknowledged) mail back to the enclave in order. Acknowledge mail . This is when the enclave no longer needs the mail to be redelivered to it on restart and the host is thus expected to delete it from its store. There are many reasons why an enclave may not want a message redelivered. For example, the conversation with the client has reached its end and so it acknowledges all the mail in that thread; or the enclave can checkpoint in the middle by creating a mail to itself which condenses all the previous mail, which are then all acknowledged. AcknowledgementReceipt . The enclave will also send this when acknowledging mail. When the host deletes acknowledged mails, the remaining mails will not be in the default sequence (consecutive integers starting from 0). In addition to deleting acknowledged mail, the host has to keep the receipt data and present it to host.start() at the next enclave restart, so the enclave knows what sequence to expect. The host receives these commands grouped together within the scope of a single EnclaveHost.deliverMail or EnclaveHost.callEnclave call. This allows the host to add transactionality when processing the commands. So for example, the delivery of the mail from the client to the enclave and the subsequent reply back can be processed atomically within the same database transaction when the host is providing persistent, durable messaging. Likewise the acknowledgement of any mail can occur within the same transaction.","title":"Mail commands"},{"location":"writing-hello-world.html#writing-the-client","text":"The client app will do three things: Connect to the host server and download the EnclaveInstanceInfo from it. Verify the enclave is acceptable: i.e. that it will do what's expected. Send it the command line arguments as a string to reverse and get back the answer, using encrypted mail. Here's the initial boilerplate to grab the user input, connect, download and deserialize the EnclaveInstanceInfo . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import com.r3.conclave.client.InvalidEnclaveException ; import com.r3.conclave.common.EnclaveInstanceInfo ; import java.io.DataInputStream ; import java.io.IOException ; import java.net.Socket ; public class Client { public static void main ( String [] args ) throws IOException , InvalidEnclaveException { if ( args . length == 0 ) { System . err . println ( \"Please pass the string to reverse on the command line\" ); return ; } String toReverse = String . join ( \" \" , args ); // Connect to the host, it will send us a remote attestation (EnclaveInstanceInfo). Socket socket = new Socket ( \"localhost\" , 9999 ); DataInputStream fromHost = new DataInputStream ( socket . getInputStream ()); byte [] attestationBytes = new byte [ fromHost . readInt () ] ; fromHost . readFully ( attestationBytes ); EnclaveInstanceInfo attestation = EnclaveInstanceInfo . deserialize ( attestationBytes ); } }","title":"Writing the client"},{"location":"writing-hello-world.html#constraints","text":"How do you know the EnclaveInstanceInfo you've got is for the enclave you really intend to interact with? In normal client/server programming you connect to a host using some sort of identity, like a domain name or IP address. TLS is used to ensure the server that picks up is the rightful owner of the domain name you intended to connect to. In enclave programming the location of the enclave might not matter much because the host is untrusted. Instead you have to verify what is running, rather than where it's running. Note The domain name of the server can still be important in some applications, in which case you should use TLS instead of raw sockets as is the case here. One way to do this is by inspecting the properties on the EnclaveInstanceInfo object and hard-coding some logic. That works fine, but testing an EnclaveInstanceInfo is a common pattern in enclave programming, so we provide an API to do it for you. The EnclaveConstraint class takes an EnclaveInstanceInfo and performs some matching against it. A constraint object can be built in code, or it can be loaded from a small domain specific language encoded as a one-line string. The string form is helpful if you anticipate frequent upgrades that should be whitelisted or other frequent changes to the acceptable enclave, as it can be easily put into a configuration file, JSON, XML or command line flags. The constraint lets you specify: Acceptable code hashes (measurements) Acceptable signing public keys The minimum revocation level The product ID The security level of the instance: SECURE , STALE , INSECURE If you specify a signing public key then you must also specify the product ID, otherwise if the organisation that created the enclave makes a second different kind of enclave in future, a malicious host might connect you with the wrong one. If the input/output commands are similar then a confusion attack could be opened up. That's why you must always specify the product ID even if it's zero. The simplest possible string-form constraint looks like this: C:F86798C4B12BE12073B87C3F57E66BCE7A541EE3D0DDA4FE8853471139C9393F It says \"accept exactly one program, with that measurement hash\". In this case the value came from the output of the build process as shown above. This is useful when you don't trust the author nor host of the enclave, and want to audit the source code and then reproduce the build. Often that's too rigid. We trust the developer of the enclave, just not the host. In that case we'll accept any enclave signed by the developer's public key. We can express that by listing code signing key hashes, like this: S:01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B PROD:1 When constraining to a signing key we must also specify the product ID, because a key can be used to sign more than one product. Add this line to the end of the client's main method: 1 2 // Check it's the enclave we expect. This will throw InvalidEnclaveException if not valid. EnclaveConstraint . parse ( \"S:01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B PROD:1 SEC:INSECURE\" ). check ( attestation ); Tip Replace the signing key in the snippet above with the enclave signer hash that was printed when you built the enclave . This line of code parses a simple constraint that says any enclave (even if run in simulation mode) signed by this hash of a code signing key with product ID of 1 is acceptable. Obviously in a real app, you would remove the part that says SEC:INSECURE , but it's convenient to have this whilst developing. You'd probably also retrieve the constraint from a configuration file, system property or command line flag. Finally it uses the check method with the attestation object. If anything is amiss an exception is thrown, so past this point we know we're talking to the real ReverseEnclave we wrote earlier. Tip If needed, more than one key hash could be added to the list of enclave constraints (e.g. if simulation and debug modes use a distinct key from release mode). The enclave is accepted if one key hash matches. 1 2 3 // Below, two distinct signing key hashes can be accepted. EnclaveConstraint . parse ( \"S:5124CA3A9C8241A3C0A51A1909197786401D2B79FA9FF849F2AA798A942165D3 \" + \"S:01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B PROD:1 SEC:INSECURE\" ). check ( attestation ); If you are building an enclave in mock mode then the enclave reports it is using a signing key hash consisting of all zeros. If you want to allow a mock enclave to pass the constraint check then you need to include this dummy signing key in your constraint: 1 2 3 4 // Below, two distinct signing key hashes or the zero dummy hash can be accepted. EnclaveConstraint . parse ( \"S:5124CA3A9C8241A3C0A51A1909197786401D2B79FA9FF849F2AA798A942165D3 \" + \"S:01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B\" + \"S:0000000000000000000000000000000000000000000000000000000000000000 PROD:1 SEC:INSECURE\" ). check ( attestation );","title":"Constraints"},{"location":"writing-hello-world.html#keys-and-mail","text":"The client wants to receive a response from the enclave, and we want that to be encrypted/tamperproofed too. That means it need a key pair of its own. Conclave uses Curve25519, a state of the art elliptic curve algorithm. For reasons of implementation robustness and avoidance of side channel attacks, this is the only algorithm supported by Conclave Mail. If you want to use other algorithms for some reason you would need to implement your own messaging system on top of host-local calls. Alternatively, use that other algorithm to encrypt/decrypt a Curve25519 private key. Generating such a key is straightforward: 1 PrivateKey myKey = Curve25519PrivateKey . random (); Unfortunately the Java Cryptography Architecture only introduced official support for Curve25519 in Java 11. At the moment in Conclave therefore, you must utilize our Curve25519PublicKey and Curve25519PrivateKey classes. In future we may offer support for using the Java 11 JCA types directly. A Curve25519 private key is simply 32 random bytes, which you can access using the getEncoded() method on PrivateKey . Now we have a key with which to receive the response, we create a mail to the enclave. This is done using the EnclaveInstanceInfo.createPostOffice method, which returns a new PostOffice object. This is similar to the post office inside the enclave and let's us create mail with increasing sequence numbers. We pass in our private key when creating the post office so it's mixed in to the calculations when the mail is encrypted and thus becomes available in getAuthenticatedSender() inside the enclave. 1 2 PostOffice postOffice = attestation . createPostOffice ( myKey , \"reverse\" ); byte [] encryptedMail = postOffice . encryptMail ( toReverse . getBytes ( StandardCharsets . UTF_8 )); We've chosen a topic value of \"reverse\" but any will do as the client uses a random key and only sends one mail using it. However, if a client needs to send multiple mail which are related to each other such that it's important they reach the enclave in the same order then these mail need to all use the same topic and private key. In other words, they need to be created from the same PostOffice instance. The enclave will automatically detect any dropped or reordered messages and throw an exception. Tip Make sure there's only one PostOffice instance per (destination public key, sender private key, topic) triple. This can be done very easily in Kotlin by using a data class with these three properties as a key to a HashMap . The same can be done in Java except it will be slightly more verbose as you will need to override the equals and hashCode methods of your key class. Modern IDEs let you do this very quickly. In more complex apps it might be smart to use the topic in more complex ways, like how a web app can use the URL to separate different functions of the app. Now we have an encrypted message we can write it to the socket and receive the enclave's response. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 System . out . println ( \"Sending the encrypted mail to the host.\" ); DataOutputStream toHost = new DataOutputStream ( socket . getOutputStream ()); toHost . writeInt ( encryptedMail . length ); toHost . write ( encryptedMail ); // Enclave will mail us back. byte [] encryptedReply = new byte [ fromHost . readInt () ] ; System . out . println ( \"Reading reply mail of length \" + encryptedReply . length + \" bytes.\" ); fromHost . readFully ( encryptedReply ); // The same post office will decrypt the response. EnclaveMail reply = postOffice . decryptMail ( encryptedReply ); System . out . println ( \"Enclave reversed '\" + toReverse + \"' and gave us the answer '\" + new String ( reply . getBodyAsBytes ()) + \"'\" ); socket . close (); We write out the length of the mail, then the mail bytes, then read the length of the response and read the response bytes. Finally we use PostOffice.decryptMail on the same instance we used to create our request, passing in the encrypted reply. This method decrypts the bytes using our private key, checks they really did come from that enclave (by checking the authenticated sender key against the enclave's public key in the attestation), decodes the bytes and yields the reply. We can then access the body of the message using EnclaveMail.getBodyAsBytes() . Finally we close the socket, and we're done. Phew! \ud83d\ude05","title":"Keys and mail"},{"location":"writing-hello-world.html#testing","text":"There are two ways you can test the enclave: using a mock build of the enclave in tests defined as part of your enclave project, or integrating enclave tests in your host project.","title":"Testing"},{"location":"writing-hello-world.html#mock-tests-within-the-enclave-project","text":"Conclave supports building and running tests within the enclave project itself. When you define tests as part of your enclave project, the enclave classes are loaded along with the tests. Conclave detects this configuration and automatically enables mock mode for the enclave and test host. You do not need to explicitly specify mock mode for your project. This allows you to whitebox test your enclave by running it fully in-memory. There is no need for SGX hardware or a specific OS and thus it is ideal for cross-platform unit testing. To enable mock mode in your enclave project tests you need to include the following test dependency in your enclave module build.gradle file. 1 testImplementation \"com.r3.conclave:conclave-host\" You can then create an instance of the enclave as normal by calling EnclaveHost.load . 1 2 EnclaveHost mockHost = EnclaveHost . load ( \"com.r3.conclave.sample.enclave.ReverseEnclave\" ); mockHost . start ( null , null ); Conclave will detect that the enclave class is on the classpath and will start the enclave in mock mode. You can obtain the enclave instance using the EnclaveHost.mockEnclave property. 1 ReverseEnclave reverseEnclave = ( ReverseEnclave ) mockHost . getMockEnclave ();","title":"Mock tests within the enclave project"},{"location":"writing-hello-world.html#integrating-enclave-tests-in-your-host-project","text":"When you want to test your enclave on real SGX hardware or in a simulated SGX environment you need to define your tests in a project separate from the enclave project. A suitable place for your tests would be to define them as part of the host project tests. Loading and testing the enclave on real hardware or in a simulated SGX environment is straightforward: the enclave needs to be loaded with EnclaveHost.load . By default this will run the tests in a simulated SGX environment and will require the tests to be executed within Linux. In addition, testing on real hardware will require the tests to be executed within Linux on a system that supports SGX. 1 2 3 4 5 6 7 8 9 10 @EnabledOnOs ( OS . LINUX ) public class NativeTest { private static EnclaveHost enclave ; @BeforeAll static void startup () throws EnclaveLoadException { enclave = EnclaveHost . load ( \"com.r3.conclave.sample.enclave.ReverseEnclave\" ); enclave . start ( new AttestationParameters . DCAP (), null ); } } You'll notice that we annotated the test class with @EnabledOnOs(OS.LINUX) . This is from JUnit 5 and it will make sure the native test isn't run on non-Linux environments. The tests can use any enclave mode: release, debug, simulation or mock. Therefore if you want to run your tests on a non-Linux system then you can configure your tests to depend on a mock mode enclave instead. In this case, remove the @EnabledOnOs(OS.LINUX) annotation from the above code. Note Running your integration tests in mock mode is very similar to Integrating enclave tests in your host project . In both cases the enclave code is loaded and run fully in memory. However for integration tests, you can also choose to run the tests in modes other than mock, which is not possible for enclave project tests. Running 1 ./gradlew host:test will execute the test using a simulation enclave, or not at all if the OS is not Linux. You can switch to a debug enclave and test on real secure hardware by using the -PenclaveMode flag: 1 ./gradlew -PenclaveMode=debug host:test Or you can use a mock enclave and test on a non-Linux platform by removing @EnabledOnOs(OS.LINUX) and by running this command: 1 ./gradlew -PenclaveMode=mock host:test Tip To run the tests in a simulated SGX environment on a non-Linux machine you can use Docker, which manages Linux VMs for you. See the instructions for compiling and running the host for more information.","title":"Integrating enclave tests in your host project"}]}